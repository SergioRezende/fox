*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        28/09/2015             GERAL.SPR               11:11:08 
*                                                                
*       픔컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        Author's Name                                           
*                                                                
*        Copyright (c) 2015 Company Name                         
*        Address                                                 
*        City,     Zip                                           
*                                                                
*        Description:                                            
*        This program was automatically generated by GENSCRN.    
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴


#REGION 0
REGIONAL m.currarea, m.talkstat, m.compstat

IF SET("TALK") = "ON"
	SET TALK OFF
	m.talkstat = "ON"
ELSE
	m.talkstat = "OFF"
ENDIF
m.compstat = SET("COMPATIBLE")
SET COMPATIBLE FOXPLUS

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                       MS-DOS Window definitions                
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                  GERAL/MS-DOS Setup Code - SECTION 2           
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1


	DO UPCarregaMnu


Return


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                 GERAL_A/MS-DOS Setup Code - SECTION 2          
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 2
	do s0000000.mpr
Return


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                 GERAL_B/MS-DOS Setup Code - SECTION 2          
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 3
	do s0000000.mpr
Return


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                 GERAL_C/MS-DOS Setup Code - SECTION 2          
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 4
	do s0000000.mpr
Return


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                      GERAL/MS-DOS Screen Layout                
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1
@ 16,0 SAY "-SISTEMA GERAL (MENSSAGENS)-" ;
	SIZE 1,28, 0
@ 11,2 GET RTgetValueObj ;
	PICTURE "@*HN RTgetValueObj - Get o Valor de uma Propriedade do Vetor" ;
	SIZE 1,57,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3h4()
@ 12,2 GET RTsetValueObj ;
	PICTURE "@*HN RTsetValueObj - Get o Valor de uma Propriedade do Vetor" ;
	SIZE 1,57,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3he()
@ 13,2 GET RTAcesso ;
	PICTURE "@*HN RTAcesso - Chamada Comum para Registro de Acesso" ;
	SIZE 1,50,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3hl()
@ 34,43 GET GrvLog ;
	PICTURE "@*HN GrvLog - Grava Ocorrencia" ;
	SIZE 1,27,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3hr()
@ 18,2 GET padrao ;
	PICTURE "@*HN UpErrorSys " ;
	SIZE 1,13,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3hz()
@ 35,43 GET LeLog ;
	PICTURE "@*HN LeLog - Ler Ocorrencia" ;
	SIZE 1,24,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3i6()
@ 27,2 GET padrao ;
	PICTURE "@*HN UPprotege  -Ativar Prot de Tela" ;
	SIZE 1,33,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3jw()
@ 26,2 GET padrao ;
	PICTURE "@*HN UPapaga    -Apagar Tela/Montar" ;
	SIZE 1,32,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3jx()
@ 22,43 GET PADRAO ;
	PICTURE "@*HN UPValData" ;
	SIZE 1,11,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3jy()
@ 19,2 GET PADRAO ;
	PICTURE "@*HN Btn_Val    -Validacao p/ WNAVEGA" ;
	SIZE 1,34,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3jz()
@ 32,43 GET UPCripto_1 ;
	PICTURE "@*HN Cripto     - Criptografia" ;
	SIZE 1,27,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3k0()
@ 22,2 GET padrao ;
	PICTURE "@*HN Refresh    -Tela Navega" ;
	SIZE 1,25,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3k1()
@ 30,2 GET padrao ;
	PICTURE "@*HN FoxAlert2  -(Sim/Nao/Cancela)" ;
	SIZE 1,32,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3k2()
@ 33,43 GET PADRAO ;
	PICTURE "@*HN Senha      - Teste Senha" ;
	SIZE 1,27,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3k3()
@ 31,2 GET padrao ;
	PICTURE "@*HN Fox_Alert  -(OK) ou (Sim / Nao) " ;
	SIZE 1,35,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3k7()
@ 19,45 GET padrao ;
	PICTURE "@*HN Pdialog    -Print Dialog" ;
	SIZE 1,27,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3kf()
@ 41,2 GET PADRAO ;
	PICTURE "@*HN UPtermo" ;
	SIZE 1,9,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3kl()
@ 24,2 GET padrao ;
	PICTURE "@*HN UPinterrompe-Tst Tecla Inter Proc" ;
	SIZE 1,35,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3kt()
@ 25,2 GET PADRAO ;
	PICTURE "@*HN UPdescanso" ;
	SIZE 1,12,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3l0()
@ 28,2 GET PADRAO ;
	PICTURE "@*HN UPbeeps" ;
	SIZE 1,9,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3l7()
@ 33,2 GET PADRAO ;
	PICTURE "@*HN UPmarcador - ????" ;
	SIZE 1,19,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3my()
@ 23,43 GET UPlimpStrg ;
	PICTURE "@*HN UPlimpStrg - PARA DOCUMENTO COM MASCARA" ;
	SIZE 1,41,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3mz()
@ 24,43 GET PADRAO ;
	PICTURE "@*HN UPtempopas - Diferenca de Tempo" ;
	SIZE 1,33,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3n0()
@ 27,43 GET PADRAO ;
	PICTURE "@*HN UPtempmais - Somar Tempo" ;
	SIZE 1,26,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3n1()
@ 17,42 GET UPPreImpressao ;
	PICTURE "@*HN UPPreImpressao" ;
	SIZE 1,16,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3n2()
@ 18,45 GET UPimpressao ;
	PICTURE "@*HN UPimpressao" ;
	SIZE 1,13,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3n3()
@ 28,43 GET PADRAO ;
	PICTURE "@*HN Extenso    - " ;
	SIZE 1,15,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3n4()
@ 29,43 GET PADRAO ;
	PICTURE "@*HN UPcalcdig" ;
	SIZE 1,11,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3n5()
@ 30,43 GET PADRAO ;
	PICTURE "@*HN ULdias_ut" ;
	SIZE 1,11,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3n6()
@ 31,43 GET UPdtSaltaUteis ;
	PICTURE "@*HN UPdtSaltaUteis- Retorna data + ou - x Dias Uteis" ;
	SIZE 1,50,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3nb()
@ 10,0 SAY "-SUPORTE A CLASSES / ORIENTACAO OBJETO" ;
	SIZE 1,38, 0
@ 21,41 SAY "-BIBLIOTECA DE FUNCOES " ;
	SIZE 1,23, 0
@ 16,41 SAY "- IMPRESSAO" ;
	SIZE 1,11, 0
@ 5,13 GET fecha ;
	PICTURE "@*HN fecha - CHAMADA EM S0000000.MNX" ;
	SIZE 1,33,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3ni()
@ 3,8 SAY "ROTINAS TRATAMENTO DOMENU S0000000" ;
	SIZE 1,34, 0
@ 6,13 GET ULfechamn ;
	PICTURE "@*HN ULfechamn - CHAMADA EM S0000000.MNX" ;
	SIZE 1,37,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3no()
@ 4,13 GET VAI ;
	PICTURE "@*HN VAI - CHAMADA EM S0000000.MNX" ;
	SIZE 1,31,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3nu()
@ 1,3 GET UPCarregaMnu ;
	PICTURE "@*HN UPCARREGAMNU - CARREGA MENU INICIAL DO SISTEMA - S0000000.MPR" ;
	SIZE 1,63,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3o0()
@ 0,0 SAY "INICIO CARGA DO SISTEMA" ;
	SIZE 1,23, 0
@ 8,0 SAY "------------------------------------------------------------------------" ;
	SIZE 1,72, 0
@ 39,2 GET UPCriatermo ;
	PICTURE "@*HN UPCriatermo - Cria Controle de Progressao" ;
	SIZE 1,43,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3o5()
@ 40,2 GET UPIniciatermo ;
	PICTURE "@*HN UPIniciatermo - Inicializa valores controle de Progressao" ;
	SIZE 1,59,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3oc()
@ 42,2 GET UPEncerratermo ;
	PICTURE "@*HN UPEncerratermo - Encerra controle de Progressao" ;
	SIZE 1,49,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q1()
@ 38,1 SAY "BARRA DE PROGRESSO" ;
	SIZE 1,18, 0
@ 37,2 GET UPLimpaString ;
	PICTURE "@*HN UPLimpaString - Elimina Caracteres especiais de string" ;
	SIZE 1,57,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q2()
@ 25,43 GET PADRAO ;
	PICTURE "@*HN UPFrmtaTempo- Formata tem em minuta p String hora 99:99" ;
	SIZE 1,57,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q3()
@ 20,5 GET GRLAlterarOrion ;
	PICTURE "@*HN GRLAlterarOrion" ;
	SIZE 1,17,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q4()




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                     GERAL_A/MS-DOS Screen Layout               
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 2
@ 0,0 SAY "- ARQUIVOS-" ;
	SIZE 1,11, 0
@ 2,3 GET PADRAO ;
	PICTURE "@*HN UParqvisao - Nome Arq.Imp" ;
	SIZE 1,27,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q5()
@ 3,3 GET PADRAO ;
	PICTURE "@*HN UPnometmp  - Nome Arq.Tmp(ABANDONAR)" ;
	SIZE 1,38,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q6()
@ 4,3 GET PADRAO ;
	PICTURE "@*HN UPabretmp  - Teste Arq.Tmp(ABANDONAR)" ;
	SIZE 1,39,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q7()
@ 5,3 GET PADRAO ;
	PICTURE "@*HN UPopentmp  - Teste Arq.Tmp(NOVA-10/99)" ;
	SIZE 1,40,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q8()
@ 11,1 GET NetArq ;
	PICTURE "@*HN NetArq     - Abertura Arquivos(1oNiv) -(Se ja Aberto Nao abre e Posiciona na Area Aberta)" ;
	SIZE 1,91,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3q9()
@ 12,1 GET NetArqAgain ;
	PICTURE "@*HN NetArqAgain- Abertura Arquivos (Indepndente se ja abertos)" ;
	SIZE 1,60,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3qa()
@ 13,5 GET NetUse ;
	PICTURE "@*HN NetUse     - Abertura Arquivos(2oNiv)" ;
	SIZE 1,39,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3qe()
@ 14,5 GET UPPath ;
	PICTURE "@*HN UPPath     - Obter Path de Arquivo" ;
	SIZE 1,36,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3ql()
@ 15,5 GET PADRAO ;
	PICTURE "@*HN UP_fecha   - Fechamento Arquivos" ;
	SIZE 1,34,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3qs()
@ 16,5 GET PADRAO ;
	PICTURE "@*HN NetErr     - Erros de Abertura" ;
	SIZE 1,32,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3qx()
@ 17,5 GET PADRAO ;
	PICTURE "@*HN UPrecupera" ;
	SIZE 1,12,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3r3()
@ 19,1 GET padrao ;
	PICTURE "@*HN UPtratachv -" ;
	SIZE 1,14,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3rf()
@ 20,1 GET padrao ;
	PICTURE "@*HN Rebloq     -Rebloqueando Registro" ;
	SIZE 1,35,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3rm()
@ 21,1 GET padrao ;
	PICTURE "@*HN Reglock    -Bloqueando Registro" ;
	SIZE 1,33,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3ru()
@ 22,1 GET padrao ;
	PICTURE "@*HN Adireg     -Adicionando Registro" ;
	SIZE 1,34,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3s0()
@ 23,1 GET padrao ;
	PICTURE "@*HN Edithand   -Registro" ;
	SIZE 1,23,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3s7()
@ 29,1 GET padrao ;
	PICTURE "@*HN Escolhe_Indice" ;
	SIZE 1,16,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3sf()
@ 31,1 GET padrao ;
	PICTURE "@*HN UPtransacao" ;
	SIZE 1,13,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3sm()
@ 24,3 GET GRLogClienc ;
	PICTURE "@*HN GRLogClienc-Log Alt.Clie.Orcamento" ;
	SIZE 1,36,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3ss()
@ 33,1 GET PADRAO ;
	PICTURE "@*HN UPtransfdb-Atulz Autom dir \automatic\" ;
	SIZE 1,40,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3uh()
@ 26,1 GET PADRAO ;
	PICTURE "@*HN Loc_dlog   -BROWS" ;
	SIZE 1,19,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3ui()
@ 27,3 GET UPLocDefWindow ;
	PICTURE "@*HN UPLocDefWindow -Define janela para browse" ;
	SIZE 1,43,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3uj()
@ 28,3 GET UPLocRelWindow ;
	PICTURE "@*HN UPLocRelWindow -Define janela para browse" ;
	SIZE 1,43,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3uk()
@ 7,5 GET PADRAO ;
	PICTURE "@*HN UPNovoTmp - Cria novo nome temporario" ;
	SIZE 1,39,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3ul()
@ 8,5 GET PADRAO ;
	PICTURE "@*HN UPDeltmp - Deleta temporarios" ;
	SIZE 1,31,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3um()




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                     GERAL_B/MS-DOS Screen Layout               
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 3
@ 1,0 SAY "- ROTINAS AMBIENTAIS -" ;
	SIZE 1,22, 0
@ 8,2 GET UPambientaliza ;
	PICTURE "@*HN UPambientaliza-Def Ambiente Sistema" ;
	SIZE 1,37,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3un()
@ 25,2 GET PADRAO ;
	PICTURE "@*HN UPmudausr - Altera Usuario " ;
	SIZE 1,29,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3uo()
@ 2,2 GET PADRAO ;
	PICTURE "@*HN antW_DEFPROC  -Redirecionamento Proc" ;
	SIZE 1,38,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3w3() ;
	DISABLE
@ 21,2 GET PADRAO ;
	PICTURE "@*HN UPcapParam - Captura Parametros NA CLASSE" ;
	SIZE 1,43,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3w4()
@ 32,2 GET UPareaWork ;
	PICTURE "@*HN UPareaWork - Escolhe_AREA" ;
	SIZE 1,27,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3w5()
@ 26,2 GET UPloja ;
	PICTURE "@*HN UPloja - Vai para area de Loja ou Central (Vice-Versa)" ;
	SIZE 1,56,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3w6()
@ 30,2 GET UPareaWork ;
	PICTURE "@*HN UPareaWork - Escolhe_AREA" ;
	SIZE 1,27,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3w7()
@ 27,2 GET UPCentral ;
	PICTURE "@*HN UPCentral - Vai para area CENTRAL " ;
	SIZE 1,36,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3w8()
@ 28,2 GET UPOutras ;
	PICTURE "@*HN UPOutras - Navega para outras Areas" ;
	SIZE 1,37,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3w9()
@ 31,2 GET UPaltdir ;
	PICTURE "@*HN UPaltdir - Efetiva Mudanca de Area" ;
	SIZE 1,37,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3wa()
@ 10,6 GET UPVTMeses ;
	PICTURE "@*HN UPVTMeses-Carrega Vetor com Nome de meses em Portugues" ;
	SIZE 1,56,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xl()
@ 11,6 GET UPVTEstados ;
	PICTURE "@*HN UPVTEstados-Carrega Vetor com Nome de Estados Brasileiros" ;
	SIZE 1,59,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xm()
@ 13,6 GET UPSetFox ;
	PICTURE "@*HN UPSetFox-Configuracoes SET do ambiente FOX" ;
	SIZE 1,44,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xn()
@ 12,6 GET UPSetSistema ;
	PICTURE "@*HN UPSetSistema-Configuracoes SET iniciais para o ambiente de SISTEMA SCGC" ;
	SIZE 1,73,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xo()
@ 15,6 GET UPArqComuns ;
	PICTURE "@*HN UPArqComuns-Carrega vetor com ref.ARQPAD arq unicos para todas lojas" ;
	SIZE 1,70,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xp()
@ 16,6 GET UPLoginInicial ;
	PICTURE "@*HN UPLoginInicial-Login Inicial do Usuario" ;
	SIZE 1,41,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xq()
@ 18,6 GET UPRecursosFOX ;
	PICTURE "@*HN UPRecursosFOX-Define ESTACAO / Definicoes do arquivo de recursos do fox" ;
	SIZE 1,73,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xr()
@ 9,6 GET UPPublicVar ;
	PICTURE "@*HN UPPublicVar-Declara variaveis Publicas" ;
	SIZE 1,40,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3xs()
@ 23,2 GET UPEmpresa ;
	PICTURE "@*HN UPEmpresa - Altera Empresa" ;
	SIZE 1,29,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3z4()
@ 3,2 GET PADRAO ;
	PICTURE "@*HN W_DEFPROC  -Redirecionamento Proc" ;
	SIZE 1,35,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3z5()




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                     GERAL_C/MS-DOS Screen Layout               
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 4
@ 0,0 SAY "-FUNCOES DE APOI A AREA COMERCIAL" ;
	SIZE 1,33, 0
@ 1,4 GET PADRAO ;
	PICTURE "@*HN UPdefbanco - " ;
	SIZE 1,15,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3z6()
@ 2,4 GET PADRAO ;
	PICTURE "@*HN UPdadosemp" ;
	SIZE 1,12,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3z7()
@ 3,4 GET PADRAO ;
	PICTURE "@*HN UPcalcusto" ;
	SIZE 1,12,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3z8()
@ 4,4 GET PADRAO ;
	PICTURE "@*HN UPFcalcusto - FUNCAO" ;
	SIZE 1,22,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3z9()
@ 5,4 GET PADRAO ;
	PICTURE "@*HN ULatunf" ;
	SIZE 1,9,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz3za()
@ 7,4 GET PADRAO ;
	PICTURE "@*HN LER TAB RELACIONADAS A TIPOOPER" ;
	SIZE 1,33,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz40i()
@ 8,8 GET PADRAO ;
	PICTURE "@*HN UPlecodigo" ;
	SIZE 1,12,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz40p()
@ 9,8 GET PADRAO ;
	PICTURE "@*HN UPClasNbm" ;
	SIZE 1,12,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz40q()
@ 11,4 GET PADRAO ;
	PICTURE "@*HN UPmsg_cr   - Mens.CR Clientes" ;
	SIZE 1,31,1 ;
	DEFAULT 1 ;
	VALID _4gg0nz40r()



READ


#REGION 0
IF m.talkstat = "ON"
	SET TALK ON
ENDIF
IF m.compstat = "ON"
	SET COMPATIBLE ON
ENDIF


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                       GERAL/MS-DOS Cleanup Code                
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1

RETURN

****Procedures****






************************** ******************

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                      GERAL_A/MS-DOS Cleanup Code               
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 2

RETURN

****Procedures****






************************** ******************

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                      GERAL_B/MS-DOS Cleanup Code               
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 3

RETURN

****Procedures****






************************** ******************

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*                      GERAL_C/MS-DOS Cleanup Code               
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 4

RETURN

****Procedures****






************************** ******************


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*           GERAL/MS-DOS Supporting Procedures and Functions     
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 1
PROCEDURE readdeac
  IF !WEXIST(WOUTPUT()) OR WP_FLGFECHA
    CLEAR READ
    RETURN .T.
  ENDIF
RETURN .F.

PROCEDURE readact
  IF !isediting  AND !wp_flgfecha
******* desativado * 02/09/99  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE readwhen
  IF wp_flgfecha
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE readvalid
  *--------------------------------------------------------------*
  *   Nao aceitar validacao quando janela for encerrada com:
  *		 <ESC>	LASTKEY() = (27),
  *  	TIMEOUT	READKEY() = (20) ou (278)
  *--------------------------------------------------------------*
  IF LASTKEY() = 27  ;
  	OR READKEY() = 20 OR READKEY() = 276
  						 && OR LASTKEY() = 6 OR LASTKEY() = 15
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE objact
  IF !isediting
  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE wizerrorhandler
#DEFINE C_EDITS			'Favor Finalizar a Edicao.'
#DEFINE C_TOPFILE		'Inicio do Arquivo.'
#DEFINE C_ENDFILE		'Final do Arquivo.'
#DEFINE C_BRTITLE		'Localiza Registro.'
#DEFINE C_NOLOCK		'Acesso negado - Registro em uso. '+ALIAS()
#DEFINE C_ECANCEL		'Edicao Cancelada.'
#DEFINE C_DELREC		'Apagar Registro Selecionado ?'
#DEFINE C_NOFEAT		'Feature not available yet.'
#DEFINE C_NOWIZ			'Wizard application is not available.'
#DEFINE C_MAKEREPO		'Creating report with Report Wizard.'
#DEFINE C_NOREPO		'Could not create report.'
#DEFINE C_DELNOTE 		'Deleting records...'
#DEFINE C_BADEXPR		'Expresao invalida.'
#DEFINE C_LOCWIZ		'Locate WIZARD.APP:'
#DEFINE C_MULTITABLE	'You have multiple related tables. Adding records in not allowed.'
	* This very simple error handler is primarily intended
	* to trap for General field OLE errors which may occur
	* during editing from the MODIFY GENERAL window.
	WAIT WINDOW message()
RETURN


PROCEDURE printrec
	  PRIVATE sOldError,wizfname,saverec,savearea,tmpcurs,tmpstr
	  PRIVATE prnt_btn,p_recs,p_output,pr_out,pr_record
	  STORE 1 TO p_recs,p_output
	  STORE 0 TO prnt_btn
	  STORE RECNO() TO saverec
	  m.sOldError=ON('error')
	  DO pdialog
	  IF m.prnt_btn = 2
	    RETURN
	  ENDIF
	  IF !FILE(ALIAS()+'.FRX')
	  	m.wizfname=SYS(2004)+'WIZARDS\'+'WIZARD.APP'
	  	IF !FILE(m.wizfname)
			ON ERROR *
			m.wizfname=LOCFILE('WIZARD.APP','APP',C_LOCWIZ)
			ON ERROR &sOldError
			IF !'WIZARD.APP'$UPPER(m.wizfname)
      			WAIT WINDOW C_NOWIZ
      			RETURN
			ENDIF
	  	ENDIF
     	WAIT WINDOW C_MAKEREPO NOWAIT
		m.savearea=SELECT()
		m.tmpcurs='_'+LEFT(SYS(3),7)
		CREATE CURSOR (m.tmpcurs) (comment m)
		m.tmpstr = '* LAYOUT = COLUMNAR'+CHR(13)+CHR(10)
		INSERT INTO (m.tmpcurs) VALUES(m.tmpstr)
		SELECT (m.savearea)
	  	DO (m.wizfname) WITH '','WZ_QREPO','NOSCRN/CREATE',ALIAS(),m.tmpcurs
		USE IN (m.tmpcurs)
     	WAIT CLEAR
	  	IF !FILE(ALIAS()+'.FRX')  &&wizard could not create report
     		WAIT WINDOW C_NOREPO
     		RETURN
	  	ENDIF
	  ENDIF
	
  	  m.pr_out=IIF(m.p_output=1,'TO PRINT NOCONSOLE','PREVIEW')
	  m.pr_record=IIF(m.p_recs=1,'NEXT 1','ALL')
  	  REPORT FORM (ALIAS()) &pr_out &pr_record
	  GO m.saverec
RETURN


*******                               *******
****     ROTINAS DE APOIO A IMPRESSAO    ****
*******                               *******


FUNCTION UPstatchq    && para programa SCGC301 (altera status chqpag)
*** STATUS => CHQPAG
	=REGLOCK(.T.)
	REPLACE status WITH "NI"
RETURN (" ")
*******-----

FUNCTION VAI_PARA   && evita erro em go tos para arquivo vazio
	ON ERROR do erro_vai	
	GO WP_RECORD    && se wp_record nao existe , nao para o sistema
	ON ERROR DO UPerrosys
RETURN

PROCEDURE ERRO_VAI && desvio de erro em posicionamento de registro

RETURN





*******


FUNCTION UPniv_clas  	&& retorna o nivel digitado na estrt. classifica
	PARAMETERS LSclass
	PRIVATE LSposicao, LNnivel
	*-------------------------------------------------------------*
	LSposicao = STR(LEN(ALLTRIM(LSclass)),2)
	LNnivel   = ASCAN(vclass,LSposicao)
RETURN(LNnivel)




** COM EFEITO SO NO RELATORIO RELOSI PARA PREENCHER COLUNA LATERAL

FUNCTION ULcol_osi
	PARAMETERS LNind, LSordem
	
	IF LSordem = "A"
		RETURN(" "+VLquantis(LNind,2))
	ENDIF

** OPCOES PARA 2a PARTE "B"

	IF LNind = 6
		RETURN(REPLICAT("=",42))
	ENDIF
	
	IF LNind = 7
		RETURN(PADC(STR(m.orcamento,6)+"/"+STR(m.vias_osi,2)+"-<"+m.ordem+">",43))
	ENDIF

	IF LNind = 8
		RETURN(PADC("Liberacao N.F.",43))
	ENDIF

	IF LNind = 11
		RETURN("Cliente :"+m.nome)
	ENDIF
RETURN(" ")	


********************************************************************


*****>>>>>>>>>>--------------------------





*************************************************************************
*****             		   PREVISAO DE VENDAS                  	   ******
*************************************************************************


*<<<<<<<<<<<<<<<<<<<<<<       2o ESTAGIO           >>>>>>>>>>>>>>>>>>>>>


*********************************************************************
* UPobjprev		: RETORNA O REGISTRO DE PREVISAO (PRVITSTQ)
*				MONTADO PARA FILIAL, CODIGO, CLASSIFICA,
*				DATA DE CONSULTA E DIAS DE RETROACAO EM CINCO
*				FAIXAS
*			   EX:
*				CLASSIFICA :
*				FILIAL     : 01
*				DATA 	   : 01/10/98
*				DIAS RETR  :
*							m.qtd_dias_a 	= 180
*							m.qtd_dias_b	= 90
*							m.qtd_dias_c	= 45
*							m.qtd_dias_d	= 25
*							m.qtd_dias_e	= 15
*
*				LFprocesso	: "VAZIO" => NAO PROCESSAR GIRO
*							: "NORMAL" => PROCESSAR GIRO
*									
**********************************************************************

FUNCTION UPprevstq
PARAMETERS  LSclassifica,LNfilial,LDdtcons,LNda,LNdb,LNdc,LNdd,LNde,;
			LNemdias,LNvariacao,LFprocesso

PRIVATE LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
PRIVATE LVqtdatend,LVdtini,LVgiro,LVd,LVdias
PRIVATE LNpercent			&& PERCENTUAL DE DIAS SEM ESTOQUE
PRIVATE LNgiroreal			&& GIRO  REAL A 12 MESES ATRAS
PRIVATE LNvdreal			&& VENDA REAL A 12 MESES ATRAS
PRIVATE LNprcdesvio			&& PERCENT DE DESVIO DA PREV. NO PASSADO
							&& P/ APLICAR NA NOVA PREV (SAZONALIDADE)
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES

PRIVATE LScodANEXO			&& IDENTIFICA CODIGO ANEXO AO PRODUTO SOLICITADO
PRIVATE LSclaANEXO			&& IDENTIFICA CLASSIFICA ANEXO AO PRODUTO SOLICITADO


DIMENSION LVqtd_dia(6),LVvendas(6),LVentradas(6),LVsemstq(6),LVperm_stq(6)
DIMENSION LVcasada(6)
DIMENSION LVqtdatend(6),LVdtini(6),LVgiro(6),LVd(6),LVdias(6)
DIMENSION LVrvvendas(6),LVrvgiro(6)

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent,LNgiroreal,LNprcdesvio,LNdifcons,LNvdreal


SELE prvitstq
SCATTER MEMVAR BLANK

SELE grupo
SET ORDER TO classifica
SEEK LSclassifica
IF !FOUND()
	RETURN
ENDIF	

m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons

*SELE grupoanx
*SET ORDER TO TAG classifica
*SEEK LSclassifica
*IF FOUND()
*	LScodANEXO		= grupoanx.codanx
*	LSclaANEXO		= grupoanx.clasanx
*ELSE
	LScodANEXO		= ""
	LSclaANEXO		= ""
*ENDIF	

**************************************************************************

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent


FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LNd&Lsc
    LVqtd_dia(La)   = LNd&Lsc && USA O VETOR POIS A OCORR(6) = 0 AJUDA
    						  && NA CHAMADA ULdiasvd
NEXT


LVdtini(6) 	 = LDdtcons

************************************************************
* PROCESSO P/ 5 FAIXAS DE DIAS DE RETROCESSO
************************************************************

FOR LNasc = 5 to 1 step -1
    La = LNasc
	Lb = LNasc + 1
	STORE 0 TO wp_retorno
	********************************************************
	* 	Os parametros de codigo anexo e classificacao anexa
	* sao passado para permitir a verificacao de dias de estoque
	* zerado considerando o codigo principal e o anexo
	*
	********************************************************
    LVvendas(La)  = LVvendas(Lb) + ;
	    ULdiasvd(m.classifica,m.codigo,LNfilial,LVdtini(Lb),;
					     LVqtd_dia(La) - LVqtd_dia(Lb),;
					     LScodANEXO,LSclaANEXO, LFprocesso)

    LVcasada(La)  	= LVcasada(Lb) 	 + wp_retorno(9)
    LVrvvendas(La)  = LVrvvendas(Lb) + wp_retorno(7)
    LVentradas(La) =LVentradas(Lb) + wp_retorno(5)  && Qtde entradas
    LVsemstq(La)   =LVsemstq(Lb)   + wp_retorno(2)  && DIAS SEM ESTQ
    LVperm_stq(La) =LVperm_stq(Lb) + wp_retorno(3)
										   		   && ESQ DE FECH DOS DIAS ACM
    LVqtdatend(La) =LVqtdatend(Lb) + wp_retorno(4) && QTDE ATENDI

	IF !EMPTY(LScodANEXO)  && ACUMULAR MOVIMENTO DO CODIGO ANEXO
			***********************************************************
			*   Neste Caso nao e somado a ocorrencia Lb pois esta soma
			*  ja ocorreu no processo do produto principas cambendo
			*  apenas somar os valores especificos do produto ANEXO no
			*  periodo proposto
			*
			***********************************************************
			********************************************************
			* 	Os parametros de codigo anexo e classificacao anexa
			* sao passado nulos pois o processo ja e o do proprio
			* anexo.
			********************************************************
			STORE 0 TO wp_retorno
	    	LVvendas(La)  = LVvendas(La) + ;
			    ULdiasvd(LSclaANEXO,LScodANEXO,LNfilial,LVdtini(Lb),;
						     LVqtd_dia(La) - LVqtd_dia(Lb),;
						     "","", LFprocesso)

		    LVcasada(La)  	= LVcasada(La) 	 + wp_retorno(9)
		    LVrvvendas(La)  = LVrvvendas(La) + wp_retorno(7)
    		LVentradas(La) 	= LVentradas(La) + wp_retorno(5)  && Qtde entradas
**********  LVsemstq(La)   	= LVsemstq(La)   + wp_retorno(2)  && DIAS SEM ESTQ
    		LVperm_stq(La) 	= LVperm_stq(La) + wp_retorno(3)
												&& ESQ DE FECH DOS DIAS ACM
	    	LVqtdatend(La)  = LVqtdatend(La) + wp_retorno(4) && QTDE ATENDI
	ENDIF

    LVdtini(La)    =wp_retorno(6)  && DATA ONDE INICIOU O ULT PROCE.
									   && PARA QUE O PROCESSO ATUAL NAO
									   && AVANCE NESTE PERIODO
									   && JA QUE OS DADOS SERAO SOMADOS
	*----------------------------------------------------------------*
	* 	O calculo do percentual de dias em que o estoque fica zerado
	* indica conforme o seu indice que :
	*		> 70 % => Indica que o produto pode estar sendo atendido
	*					sob encomenda o que provoca um alto  valor
	*					de giro porem falso. Neste caso o giro e feito
	*					sobre todo o periodo e nao somente sobre os dias
	*					com estoque
	*	   <= 70 % => Produto com venda normal e provavelmente nao venda
	*					nos dias zerados pela falta de estoque. Neste
	*					caso o giro e feito sobre os dias com estoque.
	*----------------------------------------------------------------*
	LNpercent = (LVsemstq(La) * 100) / LVqtd_dia(La)

	IF LNpercent > 70
		LVgiro(La) 	= LVvendas(La)   /   LVqtd_dia(La)
		LVrvgiro(La)= LVrvvendas(La) /   LVqtd_dia(La)
		LVd(La)		= LVqtd_dia(La)
		LVdias(La)	= LVqtd_dia(La)
	ELSE
		LVgiro(La) 	= LVvendas(La) / (LVqtd_dia(La) - LVsemstq(La))
		LVrvgiro(La)= LVrvvendas(La)/(LVqtd_dia(La)-LVsemstq(La))
		LVd(La)		= LVqtd_dia(La) - LVsemstq(La)
		LVdias(La)	= LVqtd_dia(La)
	ENDIF
NEXT
************************************************************
* INCORPORADO O SALDO DE ABERTURA DOS PERIODOS				*
************************************************************
FOR La = 5 to 1 step -1
	DO CASE
		CASE LFprocesso = "VAZIO"
		   	 LVentradas(La) =	0
		CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,LVdtini(LA)- 1)

		OTHERWISE
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
	ENDCASE
NEXT
************************************************************
* INCORPORADO O SALDO NA DATA								*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.saldo 	= 0
	CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo = m.saldo + ;
			 	  ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,m.data)
	OTHERWISE
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
ENDCASE
************************************************************
* INCORPORADO GATILHOS DE SALDO DO PRODUTO	(SO DO PRINCIPAL)*
************************************************************

SELE gatilho
SET ORDER TO TAG gatilho
SEEK STR(m.filial,3)+m.codigo
IF FOUND()
	m.gatilho	= gatilho.gatilho
ELSE
	m.gatilho 	= 0
ENDIF

************************************************************
* INCORPORADO O SALDO DE PEDIDOS							*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.pedidotran	=	0
		m.pedidopfat	=	0
	OTHERWISE
		= UPpedido(m.classifica,m.codigo,LNfilial,m.data)
		m.pedidotran	=	wp_retorno(1)
		m.pedidopfat	=	wp_retorno(2)
		IF !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			= UPpedido(LSclaANEXO,LScodANEXO,LNfilial,m.data)
			m.pedidotran	=	m.pedidotran + wp_retorno(1)
			m.pedidopfat	=	m.pedidopfat + wp_retorno(2)
		ENDIF
ENDCASE
************************************************************
*       DEFINE MEDIA DE PERMANENCIA EM ESTOQUE
************************************************************
LNtmp = LVqtd_dia(1)+LVqtd_dia(2)+LVqtd_dia(3)+ ;
				 LVqtd_dia(4)+LVqtd_dia(5)
m.media_perm = 0
IF 	LNtmp > 0
	m.media_perm = ((LVperm_stq(1)/LVdias(1)) * 2 +;
				   (LVperm_stq(2)/LVdias(2))  * 4 +;
				   (LVperm_stq(3)/LVdias(3))  * 3   +;
				   (LVperm_stq(4)/LVdias(4))  * 1   +;
				   (LVperm_stq(5)/LVdias(5))  * 1   )/11
ENDIF
************************************************************
*      DEFINE A GIRO MEDIO VAREJO
************************************************************
m.giromedio =  ((LVgiro(1) * 1)  +;
				(LVgiro(2) * 1)  +;
				(LVgiro(3) * 3)  +;
				(LVgiro(4) * 2)  +;
				(LVgiro(5) * 1)) /8

m.prvvenda_A  = LNemdias * m.giromedio

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
IF m.giromedio > 0.30  OR  m.gatilho = 0 OR m.prvvenda_A > m.gatilho
				m.sugestao_A = (m.prvvenda_A) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_A =   m.sugestao_A + ;
							   (m.sugestao_A * LNvariacao)/100		
ELSE
				m.prvvenda_A = 0		    && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_A = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDIF

****************************************************************
*      DEFINE A GIRO MEDIO REVENDA
****************************************************************
*
*    Devido a irregularidade das vendas realizadas para revendas
* adota-se a media linear
*
****************************************************************

m.rvgiromedi = (((LVrvgiro(1)) * 2)  +;
			    ((LVrvgiro(2)) * 1)  +;
			    ((LVrvgiro(3)) * 1)  +;
			    ((LVrvgiro(4)) * 1)  +;
			    ((LVrvgiro(5)) * 1)) /6

m.rvgiromedi = ((m.giromedio) + (m.giromedio  + m.rvgiromedi)) / 2

*************** A previsao e uma media entre: ******************
*		A) Previsao sem Considerar Revenda
*		B) Previsao Considerando Revenda
****************************************************************

m.prvvenda_B = (LNemdias * m.rvgiromedi)

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_B = 0
	CASE m.rvgiromedi > 0.30  OR  m.gatilho = 0 OR m.prvvenda_B > m.gatilho
				m.sugestao_B = (m.prvvenda_B) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_B =   m.sugestao_B + ;
							   (m.sugestao_B * LNvariacao)/100		
	OTHERWISE
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
											
				m.sugestao_B = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDCASE


**************** DEFINE PEDIR ******************************
**********************  descartando sazonalidade ***********
*m.prvvenda_C = m.prvvenda_B
*m.prvvenda_C = m.prvvenda_C + (m.prvvenda_C * m.indice_saz) / 100
*
*m.pedir      = (m.prvvenda_B + m.gatilho) ;
*				- (m.saldo + m.pedidotran + m.pedidopfat)
*

m.pedir 	 =  m.sugestao_B

*******************************************************************
*	m.gatilho deve conter o valor de gatilho envolvido na operacao
*****************************************************************

IF m.prvvenda_B  >  0		&& PREVISAO FEITA PELO GIRO DESPRESA O GATILHO
	m.gatilho    =  0
ENDIF
************************************************************

m.sugestao_C = m.sugestao_B

************************************************************
*  COLOCACAO DOS CAMPOS PARA GRAVACAO
************************************************************
m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons
m.dias_stoca = LNemdias

FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LVqtd_dia(La)
   	m.qtdatend_&Lsc = LVqtdatend(La)
	m.entradas_&Lsc = LVentradas(La)
	m.vendas_&Lsc 	= LVvendas(La)
	m.vdcasada_&Lsc = LVcasada(La)
	m.rvvendas_&Lsc = LVrvvendas(La)
	m.semstq_&Lsc 	= LVsemstq(La)
	m.giro_&Lsc		= LVgiro(La)
	m.rvgiro_&Lsc	= LVrvgiro(La)
NEXT

m.preco_tab = 0
m.preco_normal= 0
m.preco_vendor= 0
STORE 0 TO desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
			desc_7,desc_8,desc_9,ipi,avindice,apindice

IF USED("tabforn")		&& TABELA DE PRECOS /FORNECEDOR
						&& EM OBJ_ROL1 NAO PRECISA DO PRECO
						&& O ARQ NEM E ABERTO
	SELE tabforn
	SET ORDER TO TAG tabela
	SEEK STR(m.codforn,5)+m.codigo
	IF FOUND()
		IF !EMPTY(tabforn.grp_desc)
			SELE dsctforn
			SET ORDER TO TAG tabela
			SEEK STR(m.codforn,5)+tabforn.grp_desc
			IF !FOUND()
				SELE tabforn
			ENDIF			
		ENDIF
		SCATTER MEMVAR fields desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
						desc_7,desc_8,desc_9,desc_t,;
						avindice,apindice,aliq_ipi
		m.preco_tab  = tabforn.preco_tab
		*------------------- Calculo do Preco Final ------------------*
		STORE 0 TO m.preco_compra
		LNvendor =  m.avindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_normal= m.preco_compra
		*-------------------------------------------------------------*
		LNvendor =  m.apindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_vendor= m.preco_compra
		*-------------------------------------------------------------*
	ENDIF
ENDIF
RETURN

*<<<<<<<<<<<<<<<<<<<<<<< SUB-ROTINAS DE APOIO >>>>>>>>>>>>>>>>>>>>>>>>>>*
*************************************************************************
*************************************************************************


FUNCTION ULdiasvd	&& VENDAS PARA GIRO-3
	******************************************************************
	* Esta rotina nao deve considerar as qtdes vendidas na data base
	* para manter coerencia :
	*   EX: O operador solicita um dia anterior (GIRO-3)
	*		  A rotina deve somar as vendas do dia anterior e div / 1
	*         e se as qtdes da data base forem consideradas o giro
	*		  vai ser alto e contrariar o raciocinio do operador
	*  RETORNO
	*		A rotina devolvera
	*			wp_retorno(1) = QTDE DE VENDAS
	*			wp_retorno(2) = QTDE DE DIAS SEM ESTOQUE
	*			wp_retorno(3) 	Saldos de Fechamento de dias Acumulados
	*			wp_retorno(4) 	Qtde de Atendimento (Registro de Venda)
	*	   		wp_retorno(5) 	A qtde de entradas subtraindo saida p/ tranf
	*						para nao redundar com a entrada na outra filial
	*	   		wp_retorno(6) 	A data de inicio do processo que sera retor-
	*							nada para evitar que o periodo deja repro-
	*							cessado
	*			wp_retorno(7) = QTDE DE VENDAS A REVENDAS
	*			wp_retorno(8) = QTDE DE ATQNDIMENTOS A REVENDAS
	*			wp_retorno(9) = QTDE DE VENDA CASADA
	******************************************************************

	PARAMETERS LSclass,LScod,LNemp,LDdtconsulta,LNdias,;
			     LScodANEXO,LSclaANEXO, LFprocesso

	PRIVATE LNqtentra, LDdtinicio , LSarea, LNsubtr,I,LNctrdias
	PRIVATE LNqtvenda, LNqtatend, LNqtvdrev, LNqtatdrev, LNqtcasada
	PRIVATE LNqtdias , LDdtzera,LDdtentra
	PRIVATE LDdtsld, LNsldpermanencia
	PRIVATE LNregemprocesso && NUMERO DO REGI. ITEMMOVO EM PROCESSO


	LNqtdias    = 0		&& QTDE DE DIAS SEM ESTOQUE
	LNqtentra   = 0     && QTDE ENTRADA
	LNqtvenda 	= 0		&& QTDE VENDIDA
	LNqtcasada	= 0		&& QTDE VENDA CASADA
	LNqtatend   = 0		&& QTDE DE REGISTRO DE VENDAS
	LNqtvdrev	= 0		&& VENDAS P/ REVENDA
	LNqtatdrev	= 0		&& ATEND P/ REVENDA

	LSarea = ALIAS()
	LNtotal  = 0
	LNuteis	 = 0
	LNdiassem = 0	
	wp_retorno(1) = 0
	wp_retorno(2) = 0
	wp_retorno(3) = 0
	wp_retorno(4) = 0
	wp_retorno(5) = 0
	wp_retorno(6) = {}
	wp_retorno(7) = 0
	wp_retorno(8) = 0
	wp_retorno(9) = 0

	******<<< DEFINE A DATA INICIAL CONSID. APENAS DIAS UTEIS >>>*****
	SELE feriado
	SET ORDER TO TAG dtferiado
	DO WHILE LNuteis < LNdias
		LNtotal = LNtotal + 1
		SEEK STR(0,3)+DTOS(LDdtconsulta - LNtotal)
		IF !FOUND() AND DOW(LDdtconsulta - LNtotal) <> 1
			LNuteis = LNuteis +1
		ENDIF
	ENDDO

	LDdtinicio = LDdtconsulta - LNtotal	&& POSICIONA A DATA SUB. DIAS UTEIS

	wp_retorno(6) = LDdtinicio
	
	IF LFprocesso = "VAZIO"	&& RETORNAR SEM PROCESSAR GIRO
		SELE &LSarea	
		RETURN(LNqtvenda)
	ENDIF



	LDdtfim       = LDdtconsulta - 1

	LF1aleitura = .t.   && PERMITIR TRATAR UM REGISTRO DE PRODUTO NOVO
						&& COM SUA 1a ENTRADA PARA SUBTRAIR OS DIAS
						&& EM QUE O MESMO AINDA NAO ERA DISPONIVEL
						&& OU O MESMO VINHA ZERADO DO INICIO DO MES
						&& E RECEBEU SUA ENTRADA
	********************************************************************

	*<<<<<<<<  ACUMULAS SALDO FINAIS DOS DIAS NO PERIODO >>>>>>*
		
	LDdtsld = LDdtinicio
	LNsldpermanencia = 0
	DO WHILE LDdtsld <= LDdtfim		
		IF DOW(LDdtsld) <> 1		&& VER SE E DIA UTIL
			SET PROCEDURE TO ESTOQUE.SPR
			LNsldpermanencia = LNsldpermanencia + ;
						   ESsaldo(LNemp,LScod,LSclass,LDdtsld)
		ENDIF
		LDdtsld = 	LDdtsld + 1
	ENDDO
	wp_retorno(3) = LNsldpermanencia

	*<<<<<<<<<<<< PARA DETERMINAR SALDO INICIAL DO PERIODO >>>>>>>>>>>>>*
			** saldos de entrada sao englobados na rotina chamadora***

	LNqtentra =	0

	*<<<<<<<<<<<<<<<<<<<<<<<<     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>*
	SELE itemmov
	SET ORDER TO  TAG movimento
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+DTOS(LDdtinicio)
	SET NEAR OFF

	DO WHILE itemmov.data < LDdtconsulta AND ;
			 itemmov.empresa = LNemp AND ;
			 itemmov.codigo  = LScod	&& DESCONSIDERA DATA BASE

		*<<<<<<<<<<<< PARA DETERMINAR DIAS SEM ESTOQUE >>>>>>>>>>>>>*
		IF itemmov.sld_estq < 2 OR ;
		   			(LF1aleitura AND ;
		   			 itemmov.sld_estq - itemmov.qtde < 2 AND ;
		  			 LEFT(itemmov.operacao,1) = "E")

 				IF (LF1aleitura AND itemmov.sld_estq - itemmov.qtde < 2 ;
					AND LEFT(itemmov.operacao,1) = "E")
					LDdtzera =  LDdtinicio	&& DIAS APARTI DO INI.PER
					LDdtentra = itemmov.data
				ELSE				
					LDdtzera =  itemmov.data + 1
					SKIP

					IF !EOF() AND LNemp = itemmov.empresa ;
							  AND LScod = itemmov.codigo
						IF itemmov.data > LDdtfim
							LDdtentra = LDdtfim
						ELSE
							LDdtentra = itemmov.data
						ENDIF
					ELSE
						LDdtentra = LDdtfim
					ENDIF

					SKIP -1
				ENDIF

				DO WHILE LDdtzera <= LDdtentra
					IF DOW(LDdtzera) <> 1		&& VER SE E DIA UTIL
					   **********************************************
					   *   Qdo houver um produto anexado ao que esta
					   * em processo sera verificado o saldo do anexo
					   * e so sera contado como dia de estoque = 0
					   * qdo nao hover estoque em ambos
					   **********************************************
					   LNtmp = 0

					   IF !EMPTY(LScodANEXO)
						  LNregemprocesso = RECNO() && NUMERO DO REGI. ITEMMOVO EM PROCESSO
						  SET PROCEDURE TO ESTOQUE.SPR
						  LNtmp = ;
					  		ESsaldo(LNemp,LScodANEXO,LSclaANEXO,LDdtzera)
						  SELE itemmov
						  SET ORDER TO  TAG movimento
						  GO LNregemprocesso
					   ENDIF
					   IF LNtmp < 2	&& QTDE MINIMA DE ESTOQUE
							LNqtdias = LNqtdias +  1
					   ENDIF
					ENDIF
					LDdtzera = LDdtzera + 1
				ENDDO
		ENDIF

		LF1aleitura = .F.  && Desabilita 1a leitura


		***********************************************************
		*  DESPREZANDO VENDAS P/ CLIENTES => VENDA CASADA
		*          NAO PODEM AFETAR O GIRO
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'S' AND ;
				itemmov.ch_opera = "1" 	  AND ;
				itemmov.negociacao = 2			&& VENDA CASADA

			LNqtcasada = LNqtcasada + itemmov.qtde

			SELE itemmov
			SKIP
			LOOP
		ENDIF

		***********************************************************
		*  EXISTEM TRATAMENTOS DIFERENCIADOS PARA IDL E AS OUTRAS
		***********************************************************
		DO CASE
			CASE itemmov.empresa = 10
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S'
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
			OTHERWISE
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli <>  1
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli = 1
					 IF itemmov.movestq = "S"
						 	LNqtvdrev  = LNqtvdrev    + itemmov.qtde
							LNqtatdrev  = LNqtatdrev  + 1
					 ENDIF
				ENDIF
		ENDCASE

		***********************************************************
		*  ABATENDO DEVOLUCOES para REVENDA OU NAO
		***********************************************************
		IF LEFT(itemmov.operacao,1) = 'E' AND itemmov.ch_opera = "4" AND ;
			    itemmov.movestq = "S"
			SELE notaent
			SET ORDER TO TAG boletim
			SEEK STR(itemmov.empresa,3)+;
				 STR(itemmov.orcamento,6)+;
				 STR(itemmov.codforn,5)

			IF FOUND() AND !empty(notaent.nfdevolve)
				SELE nota
				SET ORDER TO TAG nota
				SEEK STR(itemmov.empresa,3)+STR(notaent.nfdevolve,7)
				IF FOUND()
					IF nota.natu_cli = 1     && REVENDEDOR
					 	LNqtvdrev   = LNqtvdrev   - itemmov.qtde
						LNqtatdrev  = LNqtatdrev  - 1
					    IF LNqtvdrev < 0 OR LNqtatdrev < 0
			 				LNqtvdrev = 0
			 				LNqtatdrev= 0
			 			ENDIF
					ELSE
					 	LNqtvenda  = LNqtvenda  - itemmov.qtde
						LNqtatend  = LNqtatend  - 1
					    IF LNqtvenda < 0 OR LNqtatend < 0
			 				LNqtvenda = 0
			 				LNqtatend = 0
			 			ENDIF
					ENDIF
				ENDIF
				SELE notaent
			ENDIF
			SELE itemmov
		ENDIF
		***********************************************************
		*  PARA DETERMINAR QTDE ENTRADADAS NA FORMACAO DE ESTOQUE
		* MENOS DEVOLUCOES
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'E' AND ;
		   itemmov.ch_opera <> "4"
			 IF itemmov.movestq = "S"
				 	LNqtentra  = LNqtentra  + itemmov.qtde
			 ENDIF
		ENDIF
		DO CASE
			CASE itemmov.empresa = 10
						SS=1
			OTHERWISE		
				***********************************************************
				*  CASO A MERCADORIA SAI POR TRANSFERENCIA OU POR MOV.
				* QUE NAO  SEJA VENDA ELA E DESCONSIDERADA
				* DAS ENTRADAS POIS NAO ESTA DESTINADA AO ESTOQUE DE VENDA
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
					itemmov.ch_opera <> "1"	&& SAIDAS DEVERSAS DA VENDA
					IF itemmov.movestq = "S"
				 		LNqtentra  = LNqtentra  - itemmov.qtde
					ENDIF
					IF LNqtentra < 0
			 			LNqtentra = 0
					ENDIF
				ENDIF
		ENDCASE
		SKIP
	ENDDO	

	IF	LF1aleitura   && Nao Entrou no laco nao Encontrou Reg.
		SKIP -1
		IF  itemmov.empresa <> LNemp OR ;
			itemmov.codigo  <> LScod OR ;
			itemmov.sld_estq= 0				&& NAO TEM REG ANTERIOR
			LNqtdias = LNdias
		ENDIF
	ENDIF			
			

	wp_retorno(1) = LNqtvenda
	wp_retorno(2) = LNqtdias
	wp_retorno(4) = LNqtatend
	wp_retorno(5) = LNqtentra   && Quantidade entrada
	wp_retorno(7) = LNqtvdrev
	wp_retorno(8) = LNqtatdrev
	wp_retorno(9) = LNqtcasada

	SELE &LSarea	
RETURN(LNqtvenda)

FUNCTION ULdfgat
	PARAMETERS LNfilial,LScodigo
	PRIVATE LNgatilho, LSarea
	
	LSarea 		= ALIAS()
	**********************************************************
	LNgatilho 	= 0
	SELE gatilho
	SET ORDER TO TAG gatilho
	SEEK STR(LNfilial,3)+LScodigo
	IF FOUND()
		LNgatilho = gatilho.gatilho
	ENDIF
	**********************************************************
	SELE &LSarea
		
RETURN(LNgatilho)


PROCEDURE UPpedido
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [****]   MODULO INDEPENDENTE				 *
	*------------------------------------------------------------*
	* OBJETIVO....: Devolve a qtde em TRANSIO e PENDENTE de 	 *
	*		pedidos do produto    						 *
	*------------------------------------------------------------*
	* COMENTARIO..: Utilizada para abater na sugestao de compra a*
	*	    quantidade ja pedida e pendente              *
	*------------------------------------------------------------*
	* OBS : As informacoes de qtde pedida ficam inconsistentes   *
	*       quando a simulacao for feita no passado pois os itens *
	*       pedidos constaram como fechados (<> B)				 *
	*       o que fatalmente sera contraditorio com os itens que  *
	*       estavam pendentes na epoca							 *
	*------------------------------------------------------------*
	*  TABELAS....: PEDITE
	*------------------------------------------------------------*
	*  PARAMETROS..:
	*		LSclass,LScod..: Classificacao e Codigo p/ Pesquisa
	*		LNemp..........: Empresa
	*		LDdtbase.......: Data final p/ considerar qtdes
	*	    LSarquivo......: Alias da Tabela. EX. OBJ_ROL1 abre
	*				pedite na CENTRAL e na LOJA e qdo solicita
	*				pesquisa informa em qual alias
	*------------------------------------------------------------*
	*  RETORNO.....:                                             *
	*			wp_retorno(1) = QTDE PEDIDO EM TRANSITO          *
	*			wp_retorno(2) = QTDE PEDIDO AGUARD. FATURAMENTO  *
	*------------------------------------------------------------*
	PARAMETERS LSclass,LScod,LNemp,LDdtbase,LSarquivo
	
	PRIVATE LNqttrans		&& ACM. QTDE EM TRANSITO
	PRIVATE LNqtaguarda		&& ACM. QTDE PENDENTE
	PRIVATE LSarea			&& MACADOR DO ALIAS ANTERIOR P/ RETORNAR

	LNqttrans 		= 0
	LNqtaguarda 	= 0
	wp_retorno(1) 	= 0
	wp_retorno(2)	= 0
	LSarea = ALIAS()

	IF TYPE("LSarquivo") $ "UL"  && AREA NAO INFORMADA
		LSarquivo = "pedite"
	ENDIF
	SELECT  &LSarquivo
	SET ORDER TO TAG codsit
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+"B"   && REGISTROS PENDENTES DE PEDIDO
	SET NEAR OFF
	IF BOF() AND EOF()       && ITEMMOV ESTA VAZIO
		SELE &LSarea	
		RETURN(0)
	ENDIF

	DO WHILE !EOF() AND LScod 	  = &LSarquivo .codigo ;
					AND LNemp 	  = &LSarquivo .empresa;
					AND	LDdtbase >= &LSarquivo .data ;
					AND LEFT(&LSarquivo .situacao,1) = "B"
	 	LNqttrans	= LNqttrans 	+ &LSarquivo .qtdetr
	 	LNqtaguarda	= LNqtaguarda 	+ ;
 			(&LSarquivo .qtde - &LSarquivo .qtdetr - &LSarquivo .qtdeatd)
		SKIP
	ENDDO
	SELE &LSarea	
	wp_retorno(1) = LNqttrans
	wp_retorno(2) = LNqtaguarda
RETURN(LNqttrans+LNqtaguarda)

*************************************************




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*          GERAL_A/MS-DOS Supporting Procedures and Functions    
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 2
PROCEDURE readdeac
  IF !WEXIST(WOUTPUT()) OR WP_FLGFECHA
    CLEAR READ
    RETURN .T.
  ENDIF
RETURN .F.

PROCEDURE readact
  IF !isediting  AND !wp_flgfecha
******* desativado * 02/09/99  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE readwhen
  IF wp_flgfecha
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE readvalid
  *--------------------------------------------------------------*
  *   Nao aceitar validacao quando janela for encerrada com:
  *		 <ESC>	LASTKEY() = (27),
  *  	TIMEOUT	READKEY() = (20) ou (278)
  *--------------------------------------------------------------*
  IF LASTKEY() = 27  ;
  	OR READKEY() = 20 OR READKEY() = 276
  						 && OR LASTKEY() = 6 OR LASTKEY() = 15
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE objact
  IF !isediting
  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE wizerrorhandler
#DEFINE C_EDITS			'Favor Finalizar a Edicao.'
#DEFINE C_TOPFILE		'Inicio do Arquivo.'
#DEFINE C_ENDFILE		'Final do Arquivo.'
#DEFINE C_BRTITLE		'Localiza Registro.'
#DEFINE C_NOLOCK		'Acesso negado - Registro em uso. '+ALIAS()
#DEFINE C_ECANCEL		'Edicao Cancelada.'
#DEFINE C_DELREC		'Apagar Registro Selecionado ?'
#DEFINE C_NOFEAT		'Feature not available yet.'
#DEFINE C_NOWIZ			'Wizard application is not available.'
#DEFINE C_MAKEREPO		'Creating report with Report Wizard.'
#DEFINE C_NOREPO		'Could not create report.'
#DEFINE C_DELNOTE 		'Deleting records...'
#DEFINE C_BADEXPR		'Expresao invalida.'
#DEFINE C_LOCWIZ		'Locate WIZARD.APP:'
#DEFINE C_MULTITABLE	'You have multiple related tables. Adding records in not allowed.'
	* This very simple error handler is primarily intended
	* to trap for General field OLE errors which may occur
	* during editing from the MODIFY GENERAL window.
	WAIT WINDOW message()
RETURN


PROCEDURE printrec
	  PRIVATE sOldError,wizfname,saverec,savearea,tmpcurs,tmpstr
	  PRIVATE prnt_btn,p_recs,p_output,pr_out,pr_record
	  STORE 1 TO p_recs,p_output
	  STORE 0 TO prnt_btn
	  STORE RECNO() TO saverec
	  m.sOldError=ON('error')
	  DO pdialog
	  IF m.prnt_btn = 2
	    RETURN
	  ENDIF
	  IF !FILE(ALIAS()+'.FRX')
	  	m.wizfname=SYS(2004)+'WIZARDS\'+'WIZARD.APP'
	  	IF !FILE(m.wizfname)
			ON ERROR *
			m.wizfname=LOCFILE('WIZARD.APP','APP',C_LOCWIZ)
			ON ERROR &sOldError
			IF !'WIZARD.APP'$UPPER(m.wizfname)
      			WAIT WINDOW C_NOWIZ
      			RETURN
			ENDIF
	  	ENDIF
     	WAIT WINDOW C_MAKEREPO NOWAIT
		m.savearea=SELECT()
		m.tmpcurs='_'+LEFT(SYS(3),7)
		CREATE CURSOR (m.tmpcurs) (comment m)
		m.tmpstr = '* LAYOUT = COLUMNAR'+CHR(13)+CHR(10)
		INSERT INTO (m.tmpcurs) VALUES(m.tmpstr)
		SELECT (m.savearea)
	  	DO (m.wizfname) WITH '','WZ_QREPO','NOSCRN/CREATE',ALIAS(),m.tmpcurs
		USE IN (m.tmpcurs)
     	WAIT CLEAR
	  	IF !FILE(ALIAS()+'.FRX')  &&wizard could not create report
     		WAIT WINDOW C_NOREPO
     		RETURN
	  	ENDIF
	  ENDIF
	
  	  m.pr_out=IIF(m.p_output=1,'TO PRINT NOCONSOLE','PREVIEW')
	  m.pr_record=IIF(m.p_recs=1,'NEXT 1','ALL')
  	  REPORT FORM (ALIAS()) &pr_out &pr_record
	  GO m.saverec
RETURN


*******                               *******
****     ROTINAS DE APOIO A IMPRESSAO    ****
*******                               *******


FUNCTION UPstatchq    && para programa SCGC301 (altera status chqpag)
*** STATUS => CHQPAG
	=REGLOCK(.T.)
	REPLACE status WITH "NI"
RETURN (" ")
*******-----

FUNCTION VAI_PARA   && evita erro em go tos para arquivo vazio
	ON ERROR do erro_vai	
	GO WP_RECORD    && se wp_record nao existe , nao para o sistema
	ON ERROR DO UPerrosys
RETURN

PROCEDURE ERRO_VAI && desvio de erro em posicionamento de registro

RETURN





*******


FUNCTION UPniv_clas  	&& retorna o nivel digitado na estrt. classifica
	PARAMETERS LSclass
	PRIVATE LSposicao, LNnivel
	*-------------------------------------------------------------*
	LSposicao = STR(LEN(ALLTRIM(LSclass)),2)
	LNnivel   = ASCAN(vclass,LSposicao)
RETURN(LNnivel)




** COM EFEITO SO NO RELATORIO RELOSI PARA PREENCHER COLUNA LATERAL

FUNCTION ULcol_osi
	PARAMETERS LNind, LSordem
	
	IF LSordem = "A"
		RETURN(" "+VLquantis(LNind,2))
	ENDIF

** OPCOES PARA 2a PARTE "B"

	IF LNind = 6
		RETURN(REPLICAT("=",42))
	ENDIF
	
	IF LNind = 7
		RETURN(PADC(STR(m.orcamento,6)+"/"+STR(m.vias_osi,2)+"-<"+m.ordem+">",43))
	ENDIF

	IF LNind = 8
		RETURN(PADC("Liberacao N.F.",43))
	ENDIF

	IF LNind = 11
		RETURN("Cliente :"+m.nome)
	ENDIF
RETURN(" ")	


********************************************************************


*****>>>>>>>>>>--------------------------





*************************************************************************
*****             		   PREVISAO DE VENDAS                  	   ******
*************************************************************************


*<<<<<<<<<<<<<<<<<<<<<<       2o ESTAGIO           >>>>>>>>>>>>>>>>>>>>>


*********************************************************************
* UPobjprev		: RETORNA O REGISTRO DE PREVISAO (PRVITSTQ)
*				MONTADO PARA FILIAL, CODIGO, CLASSIFICA,
*				DATA DE CONSULTA E DIAS DE RETROACAO EM CINCO
*				FAIXAS
*			   EX:
*				CLASSIFICA :
*				FILIAL     : 01
*				DATA 	   : 01/10/98
*				DIAS RETR  :
*							m.qtd_dias_a 	= 180
*							m.qtd_dias_b	= 90
*							m.qtd_dias_c	= 45
*							m.qtd_dias_d	= 25
*							m.qtd_dias_e	= 15
*
*				LFprocesso	: "VAZIO" => NAO PROCESSAR GIRO
*							: "NORMAL" => PROCESSAR GIRO
*									
**********************************************************************

FUNCTION UPprevstq
PARAMETERS  LSclassifica,LNfilial,LDdtcons,LNda,LNdb,LNdc,LNdd,LNde,;
			LNemdias,LNvariacao,LFprocesso

PRIVATE LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
PRIVATE LVqtdatend,LVdtini,LVgiro,LVd,LVdias
PRIVATE LNpercent			&& PERCENTUAL DE DIAS SEM ESTOQUE
PRIVATE LNgiroreal			&& GIRO  REAL A 12 MESES ATRAS
PRIVATE LNvdreal			&& VENDA REAL A 12 MESES ATRAS
PRIVATE LNprcdesvio			&& PERCENT DE DESVIO DA PREV. NO PASSADO
							&& P/ APLICAR NA NOVA PREV (SAZONALIDADE)
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES

PRIVATE LScodANEXO			&& IDENTIFICA CODIGO ANEXO AO PRODUTO SOLICITADO
PRIVATE LSclaANEXO			&& IDENTIFICA CLASSIFICA ANEXO AO PRODUTO SOLICITADO


DIMENSION LVqtd_dia(6),LVvendas(6),LVentradas(6),LVsemstq(6),LVperm_stq(6)
DIMENSION LVcasada(6)
DIMENSION LVqtdatend(6),LVdtini(6),LVgiro(6),LVd(6),LVdias(6)
DIMENSION LVrvvendas(6),LVrvgiro(6)

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent,LNgiroreal,LNprcdesvio,LNdifcons,LNvdreal


SELE prvitstq
SCATTER MEMVAR BLANK

SELE grupo
SET ORDER TO classifica
SEEK LSclassifica
IF !FOUND()
	RETURN
ENDIF	

m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons

*SELE grupoanx
*SET ORDER TO TAG classifica
*SEEK LSclassifica
*IF FOUND()
*	LScodANEXO		= grupoanx.codanx
*	LSclaANEXO		= grupoanx.clasanx
*ELSE
	LScodANEXO		= ""
	LSclaANEXO		= ""
*ENDIF	

**************************************************************************

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent


FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LNd&Lsc
    LVqtd_dia(La)   = LNd&Lsc && USA O VETOR POIS A OCORR(6) = 0 AJUDA
    						  && NA CHAMADA ULdiasvd
NEXT


LVdtini(6) 	 = LDdtcons

************************************************************
* PROCESSO P/ 5 FAIXAS DE DIAS DE RETROCESSO
************************************************************

FOR LNasc = 5 to 1 step -1
    La = LNasc
	Lb = LNasc + 1
	STORE 0 TO wp_retorno
	********************************************************
	* 	Os parametros de codigo anexo e classificacao anexa
	* sao passado para permitir a verificacao de dias de estoque
	* zerado considerando o codigo principal e o anexo
	*
	********************************************************
    LVvendas(La)  = LVvendas(Lb) + ;
	    ULdiasvd(m.classifica,m.codigo,LNfilial,LVdtini(Lb),;
					     LVqtd_dia(La) - LVqtd_dia(Lb),;
					     LScodANEXO,LSclaANEXO, LFprocesso)

    LVcasada(La)  	= LVcasada(Lb) 	 + wp_retorno(9)
    LVrvvendas(La)  = LVrvvendas(Lb) + wp_retorno(7)
    LVentradas(La) =LVentradas(Lb) + wp_retorno(5)  && Qtde entradas
    LVsemstq(La)   =LVsemstq(Lb)   + wp_retorno(2)  && DIAS SEM ESTQ
    LVperm_stq(La) =LVperm_stq(Lb) + wp_retorno(3)
										   		   && ESQ DE FECH DOS DIAS ACM
    LVqtdatend(La) =LVqtdatend(Lb) + wp_retorno(4) && QTDE ATENDI

	IF !EMPTY(LScodANEXO)  && ACUMULAR MOVIMENTO DO CODIGO ANEXO
			***********************************************************
			*   Neste Caso nao e somado a ocorrencia Lb pois esta soma
			*  ja ocorreu no processo do produto principas cambendo
			*  apenas somar os valores especificos do produto ANEXO no
			*  periodo proposto
			*
			***********************************************************
			********************************************************
			* 	Os parametros de codigo anexo e classificacao anexa
			* sao passado nulos pois o processo ja e o do proprio
			* anexo.
			********************************************************
			STORE 0 TO wp_retorno
	    	LVvendas(La)  = LVvendas(La) + ;
			    ULdiasvd(LSclaANEXO,LScodANEXO,LNfilial,LVdtini(Lb),;
						     LVqtd_dia(La) - LVqtd_dia(Lb),;
						     "","", LFprocesso)

		    LVcasada(La)  	= LVcasada(La) 	 + wp_retorno(9)
		    LVrvvendas(La)  = LVrvvendas(La) + wp_retorno(7)
    		LVentradas(La) 	= LVentradas(La) + wp_retorno(5)  && Qtde entradas
**********  LVsemstq(La)   	= LVsemstq(La)   + wp_retorno(2)  && DIAS SEM ESTQ
    		LVperm_stq(La) 	= LVperm_stq(La) + wp_retorno(3)
												&& ESQ DE FECH DOS DIAS ACM
	    	LVqtdatend(La)  = LVqtdatend(La) + wp_retorno(4) && QTDE ATENDI
	ENDIF

    LVdtini(La)    =wp_retorno(6)  && DATA ONDE INICIOU O ULT PROCE.
									   && PARA QUE O PROCESSO ATUAL NAO
									   && AVANCE NESTE PERIODO
									   && JA QUE OS DADOS SERAO SOMADOS
	*----------------------------------------------------------------*
	* 	O calculo do percentual de dias em que o estoque fica zerado
	* indica conforme o seu indice que :
	*		> 70 % => Indica que o produto pode estar sendo atendido
	*					sob encomenda o que provoca um alto  valor
	*					de giro porem falso. Neste caso o giro e feito
	*					sobre todo o periodo e nao somente sobre os dias
	*					com estoque
	*	   <= 70 % => Produto com venda normal e provavelmente nao venda
	*					nos dias zerados pela falta de estoque. Neste
	*					caso o giro e feito sobre os dias com estoque.
	*----------------------------------------------------------------*
	LNpercent = (LVsemstq(La) * 100) / LVqtd_dia(La)

	IF LNpercent > 70
		LVgiro(La) 	= LVvendas(La)   /   LVqtd_dia(La)
		LVrvgiro(La)= LVrvvendas(La) /   LVqtd_dia(La)
		LVd(La)		= LVqtd_dia(La)
		LVdias(La)	= LVqtd_dia(La)
	ELSE
		LVgiro(La) 	= LVvendas(La) / (LVqtd_dia(La) - LVsemstq(La))
		LVrvgiro(La)= LVrvvendas(La)/(LVqtd_dia(La)-LVsemstq(La))
		LVd(La)		= LVqtd_dia(La) - LVsemstq(La)
		LVdias(La)	= LVqtd_dia(La)
	ENDIF
NEXT
************************************************************
* INCORPORADO O SALDO DE ABERTURA DOS PERIODOS				*
************************************************************
FOR La = 5 to 1 step -1
	DO CASE
		CASE LFprocesso = "VAZIO"
		   	 LVentradas(La) =	0
		CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,LVdtini(LA)- 1)

		OTHERWISE
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
	ENDCASE
NEXT
************************************************************
* INCORPORADO O SALDO NA DATA								*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.saldo 	= 0
	CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo = m.saldo + ;
			 	  ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,m.data)
	OTHERWISE
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
ENDCASE
************************************************************
* INCORPORADO GATILHOS DE SALDO DO PRODUTO	(SO DO PRINCIPAL)*
************************************************************

SELE gatilho
SET ORDER TO TAG gatilho
SEEK STR(m.filial,3)+m.codigo
IF FOUND()
	m.gatilho	= gatilho.gatilho
ELSE
	m.gatilho 	= 0
ENDIF

************************************************************
* INCORPORADO O SALDO DE PEDIDOS							*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.pedidotran	=	0
		m.pedidopfat	=	0
	OTHERWISE
		= UPpedido(m.classifica,m.codigo,LNfilial,m.data)
		m.pedidotran	=	wp_retorno(1)
		m.pedidopfat	=	wp_retorno(2)
		IF !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			= UPpedido(LSclaANEXO,LScodANEXO,LNfilial,m.data)
			m.pedidotran	=	m.pedidotran + wp_retorno(1)
			m.pedidopfat	=	m.pedidopfat + wp_retorno(2)
		ENDIF
ENDCASE
************************************************************
*       DEFINE MEDIA DE PERMANENCIA EM ESTOQUE
************************************************************
LNtmp = LVqtd_dia(1)+LVqtd_dia(2)+LVqtd_dia(3)+ ;
				 LVqtd_dia(4)+LVqtd_dia(5)
m.media_perm = 0
IF 	LNtmp > 0
	m.media_perm = ((LVperm_stq(1)/LVdias(1)) * 2 +;
				   (LVperm_stq(2)/LVdias(2))  * 4 +;
				   (LVperm_stq(3)/LVdias(3))  * 3   +;
				   (LVperm_stq(4)/LVdias(4))  * 1   +;
				   (LVperm_stq(5)/LVdias(5))  * 1   )/11
ENDIF
************************************************************
*      DEFINE A GIRO MEDIO VAREJO
************************************************************
m.giromedio =  ((LVgiro(1) * 1)  +;
				(LVgiro(2) * 1)  +;
				(LVgiro(3) * 3)  +;
				(LVgiro(4) * 2)  +;
				(LVgiro(5) * 1)) /8

m.prvvenda_A  = LNemdias * m.giromedio

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
IF m.giromedio > 0.30  OR  m.gatilho = 0 OR m.prvvenda_A > m.gatilho
				m.sugestao_A = (m.prvvenda_A) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_A =   m.sugestao_A + ;
							   (m.sugestao_A * LNvariacao)/100		
ELSE
				m.prvvenda_A = 0		    && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_A = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDIF

****************************************************************
*      DEFINE A GIRO MEDIO REVENDA
****************************************************************
*
*    Devido a irregularidade das vendas realizadas para revendas
* adota-se a media linear
*
****************************************************************

m.rvgiromedi = (((LVrvgiro(1)) * 2)  +;
			    ((LVrvgiro(2)) * 1)  +;
			    ((LVrvgiro(3)) * 1)  +;
			    ((LVrvgiro(4)) * 1)  +;
			    ((LVrvgiro(5)) * 1)) /6

m.rvgiromedi = ((m.giromedio) + (m.giromedio  + m.rvgiromedi)) / 2

*************** A previsao e uma media entre: ******************
*		A) Previsao sem Considerar Revenda
*		B) Previsao Considerando Revenda
****************************************************************

m.prvvenda_B = (LNemdias * m.rvgiromedi)

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_B = 0
	CASE m.rvgiromedi > 0.30  OR  m.gatilho = 0 OR m.prvvenda_B > m.gatilho
				m.sugestao_B = (m.prvvenda_B) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_B =   m.sugestao_B + ;
							   (m.sugestao_B * LNvariacao)/100		
	OTHERWISE
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
											
				m.sugestao_B = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDCASE


**************** DEFINE PEDIR ******************************
**********************  descartando sazonalidade ***********
*m.prvvenda_C = m.prvvenda_B
*m.prvvenda_C = m.prvvenda_C + (m.prvvenda_C * m.indice_saz) / 100
*
*m.pedir      = (m.prvvenda_B + m.gatilho) ;
*				- (m.saldo + m.pedidotran + m.pedidopfat)
*

m.pedir 	 =  m.sugestao_B

*******************************************************************
*	m.gatilho deve conter o valor de gatilho envolvido na operacao
*****************************************************************

IF m.prvvenda_B  >  0		&& PREVISAO FEITA PELO GIRO DESPRESA O GATILHO
	m.gatilho    =  0
ENDIF
************************************************************

m.sugestao_C = m.sugestao_B

************************************************************
*  COLOCACAO DOS CAMPOS PARA GRAVACAO
************************************************************
m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons
m.dias_stoca = LNemdias

FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LVqtd_dia(La)
   	m.qtdatend_&Lsc = LVqtdatend(La)
	m.entradas_&Lsc = LVentradas(La)
	m.vendas_&Lsc 	= LVvendas(La)
	m.vdcasada_&Lsc = LVcasada(La)
	m.rvvendas_&Lsc = LVrvvendas(La)
	m.semstq_&Lsc 	= LVsemstq(La)
	m.giro_&Lsc		= LVgiro(La)
	m.rvgiro_&Lsc	= LVrvgiro(La)
NEXT

m.preco_tab = 0
m.preco_normal= 0
m.preco_vendor= 0
STORE 0 TO desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
			desc_7,desc_8,desc_9,ipi,avindice,apindice

IF USED("tabforn")		&& TABELA DE PRECOS /FORNECEDOR
						&& EM OBJ_ROL1 NAO PRECISA DO PRECO
						&& O ARQ NEM E ABERTO
	SELE tabforn
	SET ORDER TO TAG tabela
	SEEK STR(m.codforn,5)+m.codigo
	IF FOUND()
		IF !EMPTY(tabforn.grp_desc)
			SELE dsctforn
			SET ORDER TO TAG tabela
			SEEK STR(m.codforn,5)+tabforn.grp_desc
			IF !FOUND()
				SELE tabforn
			ENDIF			
		ENDIF
		SCATTER MEMVAR fields desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
						desc_7,desc_8,desc_9,desc_t,;
						avindice,apindice,aliq_ipi
		m.preco_tab  = tabforn.preco_tab
		*------------------- Calculo do Preco Final ------------------*
		STORE 0 TO m.preco_compra
		LNvendor =  m.avindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_normal= m.preco_compra
		*-------------------------------------------------------------*
		LNvendor =  m.apindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_vendor= m.preco_compra
		*-------------------------------------------------------------*
	ENDIF
ENDIF
RETURN

*<<<<<<<<<<<<<<<<<<<<<<< SUB-ROTINAS DE APOIO >>>>>>>>>>>>>>>>>>>>>>>>>>*
*************************************************************************
*************************************************************************


FUNCTION ULdiasvd	&& VENDAS PARA GIRO-3
	******************************************************************
	* Esta rotina nao deve considerar as qtdes vendidas na data base
	* para manter coerencia :
	*   EX: O operador solicita um dia anterior (GIRO-3)
	*		  A rotina deve somar as vendas do dia anterior e div / 1
	*         e se as qtdes da data base forem consideradas o giro
	*		  vai ser alto e contrariar o raciocinio do operador
	*  RETORNO
	*		A rotina devolvera
	*			wp_retorno(1) = QTDE DE VENDAS
	*			wp_retorno(2) = QTDE DE DIAS SEM ESTOQUE
	*			wp_retorno(3) 	Saldos de Fechamento de dias Acumulados
	*			wp_retorno(4) 	Qtde de Atendimento (Registro de Venda)
	*	   		wp_retorno(5) 	A qtde de entradas subtraindo saida p/ tranf
	*						para nao redundar com a entrada na outra filial
	*	   		wp_retorno(6) 	A data de inicio do processo que sera retor-
	*							nada para evitar que o periodo deja repro-
	*							cessado
	*			wp_retorno(7) = QTDE DE VENDAS A REVENDAS
	*			wp_retorno(8) = QTDE DE ATQNDIMENTOS A REVENDAS
	*			wp_retorno(9) = QTDE DE VENDA CASADA
	******************************************************************

	PARAMETERS LSclass,LScod,LNemp,LDdtconsulta,LNdias,;
			     LScodANEXO,LSclaANEXO, LFprocesso

	PRIVATE LNqtentra, LDdtinicio , LSarea, LNsubtr,I,LNctrdias
	PRIVATE LNqtvenda, LNqtatend, LNqtvdrev, LNqtatdrev, LNqtcasada
	PRIVATE LNqtdias , LDdtzera,LDdtentra
	PRIVATE LDdtsld, LNsldpermanencia
	PRIVATE LNregemprocesso && NUMERO DO REGI. ITEMMOVO EM PROCESSO


	LNqtdias    = 0		&& QTDE DE DIAS SEM ESTOQUE
	LNqtentra   = 0     && QTDE ENTRADA
	LNqtvenda 	= 0		&& QTDE VENDIDA
	LNqtcasada	= 0		&& QTDE VENDA CASADA
	LNqtatend   = 0		&& QTDE DE REGISTRO DE VENDAS
	LNqtvdrev	= 0		&& VENDAS P/ REVENDA
	LNqtatdrev	= 0		&& ATEND P/ REVENDA

	LSarea = ALIAS()
	LNtotal  = 0
	LNuteis	 = 0
	LNdiassem = 0	
	wp_retorno(1) = 0
	wp_retorno(2) = 0
	wp_retorno(3) = 0
	wp_retorno(4) = 0
	wp_retorno(5) = 0
	wp_retorno(6) = {}
	wp_retorno(7) = 0
	wp_retorno(8) = 0
	wp_retorno(9) = 0

	******<<< DEFINE A DATA INICIAL CONSID. APENAS DIAS UTEIS >>>*****
	SELE feriado
	SET ORDER TO TAG dtferiado
	DO WHILE LNuteis < LNdias
		LNtotal = LNtotal + 1
		SEEK STR(0,3)+DTOS(LDdtconsulta - LNtotal)
		IF !FOUND() AND DOW(LDdtconsulta - LNtotal) <> 1
			LNuteis = LNuteis +1
		ENDIF
	ENDDO

	LDdtinicio = LDdtconsulta - LNtotal	&& POSICIONA A DATA SUB. DIAS UTEIS

	wp_retorno(6) = LDdtinicio
	
	IF LFprocesso = "VAZIO"	&& RETORNAR SEM PROCESSAR GIRO
		SELE &LSarea	
		RETURN(LNqtvenda)
	ENDIF



	LDdtfim       = LDdtconsulta - 1

	LF1aleitura = .t.   && PERMITIR TRATAR UM REGISTRO DE PRODUTO NOVO
						&& COM SUA 1a ENTRADA PARA SUBTRAIR OS DIAS
						&& EM QUE O MESMO AINDA NAO ERA DISPONIVEL
						&& OU O MESMO VINHA ZERADO DO INICIO DO MES
						&& E RECEBEU SUA ENTRADA
	********************************************************************

	*<<<<<<<<  ACUMULAS SALDO FINAIS DOS DIAS NO PERIODO >>>>>>*
		
	LDdtsld = LDdtinicio
	LNsldpermanencia = 0
	DO WHILE LDdtsld <= LDdtfim		
		IF DOW(LDdtsld) <> 1		&& VER SE E DIA UTIL
			SET PROCEDURE TO ESTOQUE.SPR
			LNsldpermanencia = LNsldpermanencia + ;
						   ESsaldo(LNemp,LScod,LSclass,LDdtsld)
		ENDIF
		LDdtsld = 	LDdtsld + 1
	ENDDO
	wp_retorno(3) = LNsldpermanencia

	*<<<<<<<<<<<< PARA DETERMINAR SALDO INICIAL DO PERIODO >>>>>>>>>>>>>*
			** saldos de entrada sao englobados na rotina chamadora***

	LNqtentra =	0

	*<<<<<<<<<<<<<<<<<<<<<<<<     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>*
	SELE itemmov
	SET ORDER TO  TAG movimento
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+DTOS(LDdtinicio)
	SET NEAR OFF

	DO WHILE itemmov.data < LDdtconsulta AND ;
			 itemmov.empresa = LNemp AND ;
			 itemmov.codigo  = LScod	&& DESCONSIDERA DATA BASE

		*<<<<<<<<<<<< PARA DETERMINAR DIAS SEM ESTOQUE >>>>>>>>>>>>>*
		IF itemmov.sld_estq < 2 OR ;
		   			(LF1aleitura AND ;
		   			 itemmov.sld_estq - itemmov.qtde < 2 AND ;
		  			 LEFT(itemmov.operacao,1) = "E")

 				IF (LF1aleitura AND itemmov.sld_estq - itemmov.qtde < 2 ;
					AND LEFT(itemmov.operacao,1) = "E")
					LDdtzera =  LDdtinicio	&& DIAS APARTI DO INI.PER
					LDdtentra = itemmov.data
				ELSE				
					LDdtzera =  itemmov.data + 1
					SKIP

					IF !EOF() AND LNemp = itemmov.empresa ;
							  AND LScod = itemmov.codigo
						IF itemmov.data > LDdtfim
							LDdtentra = LDdtfim
						ELSE
							LDdtentra = itemmov.data
						ENDIF
					ELSE
						LDdtentra = LDdtfim
					ENDIF

					SKIP -1
				ENDIF

				DO WHILE LDdtzera <= LDdtentra
					IF DOW(LDdtzera) <> 1		&& VER SE E DIA UTIL
					   **********************************************
					   *   Qdo houver um produto anexado ao que esta
					   * em processo sera verificado o saldo do anexo
					   * e so sera contado como dia de estoque = 0
					   * qdo nao hover estoque em ambos
					   **********************************************
					   LNtmp = 0

					   IF !EMPTY(LScodANEXO)
						  LNregemprocesso = RECNO() && NUMERO DO REGI. ITEMMOVO EM PROCESSO
						  SET PROCEDURE TO ESTOQUE.SPR
						  LNtmp = ;
					  		ESsaldo(LNemp,LScodANEXO,LSclaANEXO,LDdtzera)
						  SELE itemmov
						  SET ORDER TO  TAG movimento
						  GO LNregemprocesso
					   ENDIF
					   IF LNtmp < 2	&& QTDE MINIMA DE ESTOQUE
							LNqtdias = LNqtdias +  1
					   ENDIF
					ENDIF
					LDdtzera = LDdtzera + 1
				ENDDO
		ENDIF

		LF1aleitura = .F.  && Desabilita 1a leitura


		***********************************************************
		*  DESPREZANDO VENDAS P/ CLIENTES => VENDA CASADA
		*          NAO PODEM AFETAR O GIRO
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'S' AND ;
				itemmov.ch_opera = "1" 	  AND ;
				itemmov.negociacao = 2			&& VENDA CASADA

			LNqtcasada = LNqtcasada + itemmov.qtde

			SELE itemmov
			SKIP
			LOOP
		ENDIF

		***********************************************************
		*  EXISTEM TRATAMENTOS DIFERENCIADOS PARA IDL E AS OUTRAS
		***********************************************************
		DO CASE
			CASE itemmov.empresa = 10
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S'
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
			OTHERWISE
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli <>  1
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli = 1
					 IF itemmov.movestq = "S"
						 	LNqtvdrev  = LNqtvdrev    + itemmov.qtde
							LNqtatdrev  = LNqtatdrev  + 1
					 ENDIF
				ENDIF
		ENDCASE

		***********************************************************
		*  ABATENDO DEVOLUCOES para REVENDA OU NAO
		***********************************************************
		IF LEFT(itemmov.operacao,1) = 'E' AND itemmov.ch_opera = "4" AND ;
			    itemmov.movestq = "S"
			SELE notaent
			SET ORDER TO TAG boletim
			SEEK STR(itemmov.empresa,3)+;
				 STR(itemmov.orcamento,6)+;
				 STR(itemmov.codforn,5)

			IF FOUND() AND !empty(notaent.nfdevolve)
				SELE nota
				SET ORDER TO TAG nota
				SEEK STR(itemmov.empresa,3)+STR(notaent.nfdevolve,7)
				IF FOUND()
					IF nota.natu_cli = 1     && REVENDEDOR
					 	LNqtvdrev   = LNqtvdrev   - itemmov.qtde
						LNqtatdrev  = LNqtatdrev  - 1
					    IF LNqtvdrev < 0 OR LNqtatdrev < 0
			 				LNqtvdrev = 0
			 				LNqtatdrev= 0
			 			ENDIF
					ELSE
					 	LNqtvenda  = LNqtvenda  - itemmov.qtde
						LNqtatend  = LNqtatend  - 1
					    IF LNqtvenda < 0 OR LNqtatend < 0
			 				LNqtvenda = 0
			 				LNqtatend = 0
			 			ENDIF
					ENDIF
				ENDIF
				SELE notaent
			ENDIF
			SELE itemmov
		ENDIF
		***********************************************************
		*  PARA DETERMINAR QTDE ENTRADADAS NA FORMACAO DE ESTOQUE
		* MENOS DEVOLUCOES
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'E' AND ;
		   itemmov.ch_opera <> "4"
			 IF itemmov.movestq = "S"
				 	LNqtentra  = LNqtentra  + itemmov.qtde
			 ENDIF
		ENDIF
		DO CASE
			CASE itemmov.empresa = 10
						SS=1
			OTHERWISE		
				***********************************************************
				*  CASO A MERCADORIA SAI POR TRANSFERENCIA OU POR MOV.
				* QUE NAO  SEJA VENDA ELA E DESCONSIDERADA
				* DAS ENTRADAS POIS NAO ESTA DESTINADA AO ESTOQUE DE VENDA
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
					itemmov.ch_opera <> "1"	&& SAIDAS DEVERSAS DA VENDA
					IF itemmov.movestq = "S"
				 		LNqtentra  = LNqtentra  - itemmov.qtde
					ENDIF
					IF LNqtentra < 0
			 			LNqtentra = 0
					ENDIF
				ENDIF
		ENDCASE
		SKIP
	ENDDO	

	IF	LF1aleitura   && Nao Entrou no laco nao Encontrou Reg.
		SKIP -1
		IF  itemmov.empresa <> LNemp OR ;
			itemmov.codigo  <> LScod OR ;
			itemmov.sld_estq= 0				&& NAO TEM REG ANTERIOR
			LNqtdias = LNdias
		ENDIF
	ENDIF			
			

	wp_retorno(1) = LNqtvenda
	wp_retorno(2) = LNqtdias
	wp_retorno(4) = LNqtatend
	wp_retorno(5) = LNqtentra   && Quantidade entrada
	wp_retorno(7) = LNqtvdrev
	wp_retorno(8) = LNqtatdrev
	wp_retorno(9) = LNqtcasada

	SELE &LSarea	
RETURN(LNqtvenda)

FUNCTION ULdfgat
	PARAMETERS LNfilial,LScodigo
	PRIVATE LNgatilho, LSarea
	
	LSarea 		= ALIAS()
	**********************************************************
	LNgatilho 	= 0
	SELE gatilho
	SET ORDER TO TAG gatilho
	SEEK STR(LNfilial,3)+LScodigo
	IF FOUND()
		LNgatilho = gatilho.gatilho
	ENDIF
	**********************************************************
	SELE &LSarea
		
RETURN(LNgatilho)


PROCEDURE UPpedido
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [****]   MODULO INDEPENDENTE				 *
	*------------------------------------------------------------*
	* OBJETIVO....: Devolve a qtde em TRANSIO e PENDENTE de 	 *
	*		pedidos do produto    						 *
	*------------------------------------------------------------*
	* COMENTARIO..: Utilizada para abater na sugestao de compra a*
	*	    quantidade ja pedida e pendente              *
	*------------------------------------------------------------*
	* OBS : As informacoes de qtde pedida ficam inconsistentes   *
	*       quando a simulacao for feita no passado pois os itens *
	*       pedidos constaram como fechados (<> B)				 *
	*       o que fatalmente sera contraditorio com os itens que  *
	*       estavam pendentes na epoca							 *
	*------------------------------------------------------------*
	*  TABELAS....: PEDITE
	*------------------------------------------------------------*
	*  PARAMETROS..:
	*		LSclass,LScod..: Classificacao e Codigo p/ Pesquisa
	*		LNemp..........: Empresa
	*		LDdtbase.......: Data final p/ considerar qtdes
	*	    LSarquivo......: Alias da Tabela. EX. OBJ_ROL1 abre
	*				pedite na CENTRAL e na LOJA e qdo solicita
	*				pesquisa informa em qual alias
	*------------------------------------------------------------*
	*  RETORNO.....:                                             *
	*			wp_retorno(1) = QTDE PEDIDO EM TRANSITO          *
	*			wp_retorno(2) = QTDE PEDIDO AGUARD. FATURAMENTO  *
	*------------------------------------------------------------*
	PARAMETERS LSclass,LScod,LNemp,LDdtbase,LSarquivo
	
	PRIVATE LNqttrans		&& ACM. QTDE EM TRANSITO
	PRIVATE LNqtaguarda		&& ACM. QTDE PENDENTE
	PRIVATE LSarea			&& MACADOR DO ALIAS ANTERIOR P/ RETORNAR

	LNqttrans 		= 0
	LNqtaguarda 	= 0
	wp_retorno(1) 	= 0
	wp_retorno(2)	= 0
	LSarea = ALIAS()

	IF TYPE("LSarquivo") $ "UL"  && AREA NAO INFORMADA
		LSarquivo = "pedite"
	ENDIF
	SELECT  &LSarquivo
	SET ORDER TO TAG codsit
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+"B"   && REGISTROS PENDENTES DE PEDIDO
	SET NEAR OFF
	IF BOF() AND EOF()       && ITEMMOV ESTA VAZIO
		SELE &LSarea	
		RETURN(0)
	ENDIF

	DO WHILE !EOF() AND LScod 	  = &LSarquivo .codigo ;
					AND LNemp 	  = &LSarquivo .empresa;
					AND	LDdtbase >= &LSarquivo .data ;
					AND LEFT(&LSarquivo .situacao,1) = "B"
	 	LNqttrans	= LNqttrans 	+ &LSarquivo .qtdetr
	 	LNqtaguarda	= LNqtaguarda 	+ ;
 			(&LSarquivo .qtde - &LSarquivo .qtdetr - &LSarquivo .qtdeatd)
		SKIP
	ENDDO
	SELE &LSarea	
	wp_retorno(1) = LNqttrans
	wp_retorno(2) = LNqtaguarda
RETURN(LNqttrans+LNqtaguarda)

*************************************************




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*          GERAL_B/MS-DOS Supporting Procedures and Functions    
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 3
PROCEDURE readdeac
  IF !WEXIST(WOUTPUT()) OR WP_FLGFECHA
    CLEAR READ
    RETURN .T.
  ENDIF
RETURN .F.

PROCEDURE readact
  IF !isediting  AND !wp_flgfecha
******* desativado * 02/09/99  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE readwhen
  IF wp_flgfecha
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE readvalid
  *--------------------------------------------------------------*
  *   Nao aceitar validacao quando janela for encerrada com:
  *		 <ESC>	LASTKEY() = (27),
  *  	TIMEOUT	READKEY() = (20) ou (278)
  *--------------------------------------------------------------*
  IF LASTKEY() = 27  ;
  	OR READKEY() = 20 OR READKEY() = 276
  						 && OR LASTKEY() = 6 OR LASTKEY() = 15
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE objact
  IF !isediting
  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE wizerrorhandler
#DEFINE C_EDITS			'Favor Finalizar a Edicao.'
#DEFINE C_TOPFILE		'Inicio do Arquivo.'
#DEFINE C_ENDFILE		'Final do Arquivo.'
#DEFINE C_BRTITLE		'Localiza Registro.'
#DEFINE C_NOLOCK		'Acesso negado - Registro em uso. '+ALIAS()
#DEFINE C_ECANCEL		'Edicao Cancelada.'
#DEFINE C_DELREC		'Apagar Registro Selecionado ?'
#DEFINE C_NOFEAT		'Feature not available yet.'
#DEFINE C_NOWIZ			'Wizard application is not available.'
#DEFINE C_MAKEREPO		'Creating report with Report Wizard.'
#DEFINE C_NOREPO		'Could not create report.'
#DEFINE C_DELNOTE 		'Deleting records...'
#DEFINE C_BADEXPR		'Expresao invalida.'
#DEFINE C_LOCWIZ		'Locate WIZARD.APP:'
#DEFINE C_MULTITABLE	'You have multiple related tables. Adding records in not allowed.'
	* This very simple error handler is primarily intended
	* to trap for General field OLE errors which may occur
	* during editing from the MODIFY GENERAL window.
	WAIT WINDOW message()
RETURN


PROCEDURE printrec
	  PRIVATE sOldError,wizfname,saverec,savearea,tmpcurs,tmpstr
	  PRIVATE prnt_btn,p_recs,p_output,pr_out,pr_record
	  STORE 1 TO p_recs,p_output
	  STORE 0 TO prnt_btn
	  STORE RECNO() TO saverec
	  m.sOldError=ON('error')
	  DO pdialog
	  IF m.prnt_btn = 2
	    RETURN
	  ENDIF
	  IF !FILE(ALIAS()+'.FRX')
	  	m.wizfname=SYS(2004)+'WIZARDS\'+'WIZARD.APP'
	  	IF !FILE(m.wizfname)
			ON ERROR *
			m.wizfname=LOCFILE('WIZARD.APP','APP',C_LOCWIZ)
			ON ERROR &sOldError
			IF !'WIZARD.APP'$UPPER(m.wizfname)
      			WAIT WINDOW C_NOWIZ
      			RETURN
			ENDIF
	  	ENDIF
     	WAIT WINDOW C_MAKEREPO NOWAIT
		m.savearea=SELECT()
		m.tmpcurs='_'+LEFT(SYS(3),7)
		CREATE CURSOR (m.tmpcurs) (comment m)
		m.tmpstr = '* LAYOUT = COLUMNAR'+CHR(13)+CHR(10)
		INSERT INTO (m.tmpcurs) VALUES(m.tmpstr)
		SELECT (m.savearea)
	  	DO (m.wizfname) WITH '','WZ_QREPO','NOSCRN/CREATE',ALIAS(),m.tmpcurs
		USE IN (m.tmpcurs)
     	WAIT CLEAR
	  	IF !FILE(ALIAS()+'.FRX')  &&wizard could not create report
     		WAIT WINDOW C_NOREPO
     		RETURN
	  	ENDIF
	  ENDIF
	
  	  m.pr_out=IIF(m.p_output=1,'TO PRINT NOCONSOLE','PREVIEW')
	  m.pr_record=IIF(m.p_recs=1,'NEXT 1','ALL')
  	  REPORT FORM (ALIAS()) &pr_out &pr_record
	  GO m.saverec
RETURN


*******                               *******
****     ROTINAS DE APOIO A IMPRESSAO    ****
*******                               *******


FUNCTION UPstatchq    && para programa SCGC301 (altera status chqpag)
*** STATUS => CHQPAG
	=REGLOCK(.T.)
	REPLACE status WITH "NI"
RETURN (" ")
*******-----

FUNCTION VAI_PARA   && evita erro em go tos para arquivo vazio
	ON ERROR do erro_vai	
	GO WP_RECORD    && se wp_record nao existe , nao para o sistema
	ON ERROR DO UPerrosys
RETURN

PROCEDURE ERRO_VAI && desvio de erro em posicionamento de registro

RETURN





*******


FUNCTION UPniv_clas  	&& retorna o nivel digitado na estrt. classifica
	PARAMETERS LSclass
	PRIVATE LSposicao, LNnivel
	*-------------------------------------------------------------*
	LSposicao = STR(LEN(ALLTRIM(LSclass)),2)
	LNnivel   = ASCAN(vclass,LSposicao)
RETURN(LNnivel)




** COM EFEITO SO NO RELATORIO RELOSI PARA PREENCHER COLUNA LATERAL

FUNCTION ULcol_osi
	PARAMETERS LNind, LSordem
	
	IF LSordem = "A"
		RETURN(" "+VLquantis(LNind,2))
	ENDIF

** OPCOES PARA 2a PARTE "B"

	IF LNind = 6
		RETURN(REPLICAT("=",42))
	ENDIF
	
	IF LNind = 7
		RETURN(PADC(STR(m.orcamento,6)+"/"+STR(m.vias_osi,2)+"-<"+m.ordem+">",43))
	ENDIF

	IF LNind = 8
		RETURN(PADC("Liberacao N.F.",43))
	ENDIF

	IF LNind = 11
		RETURN("Cliente :"+m.nome)
	ENDIF
RETURN(" ")	


********************************************************************


*****>>>>>>>>>>--------------------------





*************************************************************************
*****             		   PREVISAO DE VENDAS                  	   ******
*************************************************************************


*<<<<<<<<<<<<<<<<<<<<<<       2o ESTAGIO           >>>>>>>>>>>>>>>>>>>>>


*********************************************************************
* UPobjprev		: RETORNA O REGISTRO DE PREVISAO (PRVITSTQ)
*				MONTADO PARA FILIAL, CODIGO, CLASSIFICA,
*				DATA DE CONSULTA E DIAS DE RETROACAO EM CINCO
*				FAIXAS
*			   EX:
*				CLASSIFICA :
*				FILIAL     : 01
*				DATA 	   : 01/10/98
*				DIAS RETR  :
*							m.qtd_dias_a 	= 180
*							m.qtd_dias_b	= 90
*							m.qtd_dias_c	= 45
*							m.qtd_dias_d	= 25
*							m.qtd_dias_e	= 15
*
*				LFprocesso	: "VAZIO" => NAO PROCESSAR GIRO
*							: "NORMAL" => PROCESSAR GIRO
*									
**********************************************************************

FUNCTION UPprevstq
PARAMETERS  LSclassifica,LNfilial,LDdtcons,LNda,LNdb,LNdc,LNdd,LNde,;
			LNemdias,LNvariacao,LFprocesso

PRIVATE LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
PRIVATE LVqtdatend,LVdtini,LVgiro,LVd,LVdias
PRIVATE LNpercent			&& PERCENTUAL DE DIAS SEM ESTOQUE
PRIVATE LNgiroreal			&& GIRO  REAL A 12 MESES ATRAS
PRIVATE LNvdreal			&& VENDA REAL A 12 MESES ATRAS
PRIVATE LNprcdesvio			&& PERCENT DE DESVIO DA PREV. NO PASSADO
							&& P/ APLICAR NA NOVA PREV (SAZONALIDADE)
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES

PRIVATE LScodANEXO			&& IDENTIFICA CODIGO ANEXO AO PRODUTO SOLICITADO
PRIVATE LSclaANEXO			&& IDENTIFICA CLASSIFICA ANEXO AO PRODUTO SOLICITADO


DIMENSION LVqtd_dia(6),LVvendas(6),LVentradas(6),LVsemstq(6),LVperm_stq(6)
DIMENSION LVcasada(6)
DIMENSION LVqtdatend(6),LVdtini(6),LVgiro(6),LVd(6),LVdias(6)
DIMENSION LVrvvendas(6),LVrvgiro(6)

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent,LNgiroreal,LNprcdesvio,LNdifcons,LNvdreal


SELE prvitstq
SCATTER MEMVAR BLANK

SELE grupo
SET ORDER TO classifica
SEEK LSclassifica
IF !FOUND()
	RETURN
ENDIF	

m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons

*SELE grupoanx
*SET ORDER TO TAG classifica
*SEEK LSclassifica
*IF FOUND()
*	LScodANEXO		= grupoanx.codanx
*	LSclaANEXO		= grupoanx.clasanx
*ELSE
	LScodANEXO		= ""
	LSclaANEXO		= ""
*ENDIF	

**************************************************************************

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent


FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LNd&Lsc
    LVqtd_dia(La)   = LNd&Lsc && USA O VETOR POIS A OCORR(6) = 0 AJUDA
    						  && NA CHAMADA ULdiasvd
NEXT


LVdtini(6) 	 = LDdtcons

************************************************************
* PROCESSO P/ 5 FAIXAS DE DIAS DE RETROCESSO
************************************************************

FOR LNasc = 5 to 1 step -1
    La = LNasc
	Lb = LNasc + 1
	STORE 0 TO wp_retorno
	********************************************************
	* 	Os parametros de codigo anexo e classificacao anexa
	* sao passado para permitir a verificacao de dias de estoque
	* zerado considerando o codigo principal e o anexo
	*
	********************************************************
    LVvendas(La)  = LVvendas(Lb) + ;
	    ULdiasvd(m.classifica,m.codigo,LNfilial,LVdtini(Lb),;
					     LVqtd_dia(La) - LVqtd_dia(Lb),;
					     LScodANEXO,LSclaANEXO, LFprocesso)

    LVcasada(La)  	= LVcasada(Lb) 	 + wp_retorno(9)
    LVrvvendas(La)  = LVrvvendas(Lb) + wp_retorno(7)
    LVentradas(La) =LVentradas(Lb) + wp_retorno(5)  && Qtde entradas
    LVsemstq(La)   =LVsemstq(Lb)   + wp_retorno(2)  && DIAS SEM ESTQ
    LVperm_stq(La) =LVperm_stq(Lb) + wp_retorno(3)
										   		   && ESQ DE FECH DOS DIAS ACM
    LVqtdatend(La) =LVqtdatend(Lb) + wp_retorno(4) && QTDE ATENDI

	IF !EMPTY(LScodANEXO)  && ACUMULAR MOVIMENTO DO CODIGO ANEXO
			***********************************************************
			*   Neste Caso nao e somado a ocorrencia Lb pois esta soma
			*  ja ocorreu no processo do produto principas cambendo
			*  apenas somar os valores especificos do produto ANEXO no
			*  periodo proposto
			*
			***********************************************************
			********************************************************
			* 	Os parametros de codigo anexo e classificacao anexa
			* sao passado nulos pois o processo ja e o do proprio
			* anexo.
			********************************************************
			STORE 0 TO wp_retorno
	    	LVvendas(La)  = LVvendas(La) + ;
			    ULdiasvd(LSclaANEXO,LScodANEXO,LNfilial,LVdtini(Lb),;
						     LVqtd_dia(La) - LVqtd_dia(Lb),;
						     "","", LFprocesso)

		    LVcasada(La)  	= LVcasada(La) 	 + wp_retorno(9)
		    LVrvvendas(La)  = LVrvvendas(La) + wp_retorno(7)
    		LVentradas(La) 	= LVentradas(La) + wp_retorno(5)  && Qtde entradas
**********  LVsemstq(La)   	= LVsemstq(La)   + wp_retorno(2)  && DIAS SEM ESTQ
    		LVperm_stq(La) 	= LVperm_stq(La) + wp_retorno(3)
												&& ESQ DE FECH DOS DIAS ACM
	    	LVqtdatend(La)  = LVqtdatend(La) + wp_retorno(4) && QTDE ATENDI
	ENDIF

    LVdtini(La)    =wp_retorno(6)  && DATA ONDE INICIOU O ULT PROCE.
									   && PARA QUE O PROCESSO ATUAL NAO
									   && AVANCE NESTE PERIODO
									   && JA QUE OS DADOS SERAO SOMADOS
	*----------------------------------------------------------------*
	* 	O calculo do percentual de dias em que o estoque fica zerado
	* indica conforme o seu indice que :
	*		> 70 % => Indica que o produto pode estar sendo atendido
	*					sob encomenda o que provoca um alto  valor
	*					de giro porem falso. Neste caso o giro e feito
	*					sobre todo o periodo e nao somente sobre os dias
	*					com estoque
	*	   <= 70 % => Produto com venda normal e provavelmente nao venda
	*					nos dias zerados pela falta de estoque. Neste
	*					caso o giro e feito sobre os dias com estoque.
	*----------------------------------------------------------------*
	LNpercent = (LVsemstq(La) * 100) / LVqtd_dia(La)

	IF LNpercent > 70
		LVgiro(La) 	= LVvendas(La)   /   LVqtd_dia(La)
		LVrvgiro(La)= LVrvvendas(La) /   LVqtd_dia(La)
		LVd(La)		= LVqtd_dia(La)
		LVdias(La)	= LVqtd_dia(La)
	ELSE
		LVgiro(La) 	= LVvendas(La) / (LVqtd_dia(La) - LVsemstq(La))
		LVrvgiro(La)= LVrvvendas(La)/(LVqtd_dia(La)-LVsemstq(La))
		LVd(La)		= LVqtd_dia(La) - LVsemstq(La)
		LVdias(La)	= LVqtd_dia(La)
	ENDIF
NEXT
************************************************************
* INCORPORADO O SALDO DE ABERTURA DOS PERIODOS				*
************************************************************
FOR La = 5 to 1 step -1
	DO CASE
		CASE LFprocesso = "VAZIO"
		   	 LVentradas(La) =	0
		CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,LVdtini(LA)- 1)

		OTHERWISE
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
	ENDCASE
NEXT
************************************************************
* INCORPORADO O SALDO NA DATA								*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.saldo 	= 0
	CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo = m.saldo + ;
			 	  ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,m.data)
	OTHERWISE
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
ENDCASE
************************************************************
* INCORPORADO GATILHOS DE SALDO DO PRODUTO	(SO DO PRINCIPAL)*
************************************************************

SELE gatilho
SET ORDER TO TAG gatilho
SEEK STR(m.filial,3)+m.codigo
IF FOUND()
	m.gatilho	= gatilho.gatilho
ELSE
	m.gatilho 	= 0
ENDIF

************************************************************
* INCORPORADO O SALDO DE PEDIDOS							*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.pedidotran	=	0
		m.pedidopfat	=	0
	OTHERWISE
		= UPpedido(m.classifica,m.codigo,LNfilial,m.data)
		m.pedidotran	=	wp_retorno(1)
		m.pedidopfat	=	wp_retorno(2)
		IF !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			= UPpedido(LSclaANEXO,LScodANEXO,LNfilial,m.data)
			m.pedidotran	=	m.pedidotran + wp_retorno(1)
			m.pedidopfat	=	m.pedidopfat + wp_retorno(2)
		ENDIF
ENDCASE
************************************************************
*       DEFINE MEDIA DE PERMANENCIA EM ESTOQUE
************************************************************
LNtmp = LVqtd_dia(1)+LVqtd_dia(2)+LVqtd_dia(3)+ ;
				 LVqtd_dia(4)+LVqtd_dia(5)
m.media_perm = 0
IF 	LNtmp > 0
	m.media_perm = ((LVperm_stq(1)/LVdias(1)) * 2 +;
				   (LVperm_stq(2)/LVdias(2))  * 4 +;
				   (LVperm_stq(3)/LVdias(3))  * 3   +;
				   (LVperm_stq(4)/LVdias(4))  * 1   +;
				   (LVperm_stq(5)/LVdias(5))  * 1   )/11
ENDIF
************************************************************
*      DEFINE A GIRO MEDIO VAREJO
************************************************************
m.giromedio =  ((LVgiro(1) * 1)  +;
				(LVgiro(2) * 1)  +;
				(LVgiro(3) * 3)  +;
				(LVgiro(4) * 2)  +;
				(LVgiro(5) * 1)) /8

m.prvvenda_A  = LNemdias * m.giromedio

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
IF m.giromedio > 0.30  OR  m.gatilho = 0 OR m.prvvenda_A > m.gatilho
				m.sugestao_A = (m.prvvenda_A) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_A =   m.sugestao_A + ;
							   (m.sugestao_A * LNvariacao)/100		
ELSE
				m.prvvenda_A = 0		    && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_A = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDIF

****************************************************************
*      DEFINE A GIRO MEDIO REVENDA
****************************************************************
*
*    Devido a irregularidade das vendas realizadas para revendas
* adota-se a media linear
*
****************************************************************

m.rvgiromedi = (((LVrvgiro(1)) * 2)  +;
			    ((LVrvgiro(2)) * 1)  +;
			    ((LVrvgiro(3)) * 1)  +;
			    ((LVrvgiro(4)) * 1)  +;
			    ((LVrvgiro(5)) * 1)) /6

m.rvgiromedi = ((m.giromedio) + (m.giromedio  + m.rvgiromedi)) / 2

*************** A previsao e uma media entre: ******************
*		A) Previsao sem Considerar Revenda
*		B) Previsao Considerando Revenda
****************************************************************

m.prvvenda_B = (LNemdias * m.rvgiromedi)

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_B = 0
	CASE m.rvgiromedi > 0.30  OR  m.gatilho = 0 OR m.prvvenda_B > m.gatilho
				m.sugestao_B = (m.prvvenda_B) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_B =   m.sugestao_B + ;
							   (m.sugestao_B * LNvariacao)/100		
	OTHERWISE
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
											
				m.sugestao_B = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDCASE


**************** DEFINE PEDIR ******************************
**********************  descartando sazonalidade ***********
*m.prvvenda_C = m.prvvenda_B
*m.prvvenda_C = m.prvvenda_C + (m.prvvenda_C * m.indice_saz) / 100
*
*m.pedir      = (m.prvvenda_B + m.gatilho) ;
*				- (m.saldo + m.pedidotran + m.pedidopfat)
*

m.pedir 	 =  m.sugestao_B

*******************************************************************
*	m.gatilho deve conter o valor de gatilho envolvido na operacao
*****************************************************************

IF m.prvvenda_B  >  0		&& PREVISAO FEITA PELO GIRO DESPRESA O GATILHO
	m.gatilho    =  0
ENDIF
************************************************************

m.sugestao_C = m.sugestao_B

************************************************************
*  COLOCACAO DOS CAMPOS PARA GRAVACAO
************************************************************
m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons
m.dias_stoca = LNemdias

FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LVqtd_dia(La)
   	m.qtdatend_&Lsc = LVqtdatend(La)
	m.entradas_&Lsc = LVentradas(La)
	m.vendas_&Lsc 	= LVvendas(La)
	m.vdcasada_&Lsc = LVcasada(La)
	m.rvvendas_&Lsc = LVrvvendas(La)
	m.semstq_&Lsc 	= LVsemstq(La)
	m.giro_&Lsc		= LVgiro(La)
	m.rvgiro_&Lsc	= LVrvgiro(La)
NEXT

m.preco_tab = 0
m.preco_normal= 0
m.preco_vendor= 0
STORE 0 TO desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
			desc_7,desc_8,desc_9,ipi,avindice,apindice

IF USED("tabforn")		&& TABELA DE PRECOS /FORNECEDOR
						&& EM OBJ_ROL1 NAO PRECISA DO PRECO
						&& O ARQ NEM E ABERTO
	SELE tabforn
	SET ORDER TO TAG tabela
	SEEK STR(m.codforn,5)+m.codigo
	IF FOUND()
		IF !EMPTY(tabforn.grp_desc)
			SELE dsctforn
			SET ORDER TO TAG tabela
			SEEK STR(m.codforn,5)+tabforn.grp_desc
			IF !FOUND()
				SELE tabforn
			ENDIF			
		ENDIF
		SCATTER MEMVAR fields desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
						desc_7,desc_8,desc_9,desc_t,;
						avindice,apindice,aliq_ipi
		m.preco_tab  = tabforn.preco_tab
		*------------------- Calculo do Preco Final ------------------*
		STORE 0 TO m.preco_compra
		LNvendor =  m.avindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_normal= m.preco_compra
		*-------------------------------------------------------------*
		LNvendor =  m.apindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_vendor= m.preco_compra
		*-------------------------------------------------------------*
	ENDIF
ENDIF
RETURN

*<<<<<<<<<<<<<<<<<<<<<<< SUB-ROTINAS DE APOIO >>>>>>>>>>>>>>>>>>>>>>>>>>*
*************************************************************************
*************************************************************************


FUNCTION ULdiasvd	&& VENDAS PARA GIRO-3
	******************************************************************
	* Esta rotina nao deve considerar as qtdes vendidas na data base
	* para manter coerencia :
	*   EX: O operador solicita um dia anterior (GIRO-3)
	*		  A rotina deve somar as vendas do dia anterior e div / 1
	*         e se as qtdes da data base forem consideradas o giro
	*		  vai ser alto e contrariar o raciocinio do operador
	*  RETORNO
	*		A rotina devolvera
	*			wp_retorno(1) = QTDE DE VENDAS
	*			wp_retorno(2) = QTDE DE DIAS SEM ESTOQUE
	*			wp_retorno(3) 	Saldos de Fechamento de dias Acumulados
	*			wp_retorno(4) 	Qtde de Atendimento (Registro de Venda)
	*	   		wp_retorno(5) 	A qtde de entradas subtraindo saida p/ tranf
	*						para nao redundar com a entrada na outra filial
	*	   		wp_retorno(6) 	A data de inicio do processo que sera retor-
	*							nada para evitar que o periodo deja repro-
	*							cessado
	*			wp_retorno(7) = QTDE DE VENDAS A REVENDAS
	*			wp_retorno(8) = QTDE DE ATQNDIMENTOS A REVENDAS
	*			wp_retorno(9) = QTDE DE VENDA CASADA
	******************************************************************

	PARAMETERS LSclass,LScod,LNemp,LDdtconsulta,LNdias,;
			     LScodANEXO,LSclaANEXO, LFprocesso

	PRIVATE LNqtentra, LDdtinicio , LSarea, LNsubtr,I,LNctrdias
	PRIVATE LNqtvenda, LNqtatend, LNqtvdrev, LNqtatdrev, LNqtcasada
	PRIVATE LNqtdias , LDdtzera,LDdtentra
	PRIVATE LDdtsld, LNsldpermanencia
	PRIVATE LNregemprocesso && NUMERO DO REGI. ITEMMOVO EM PROCESSO


	LNqtdias    = 0		&& QTDE DE DIAS SEM ESTOQUE
	LNqtentra   = 0     && QTDE ENTRADA
	LNqtvenda 	= 0		&& QTDE VENDIDA
	LNqtcasada	= 0		&& QTDE VENDA CASADA
	LNqtatend   = 0		&& QTDE DE REGISTRO DE VENDAS
	LNqtvdrev	= 0		&& VENDAS P/ REVENDA
	LNqtatdrev	= 0		&& ATEND P/ REVENDA

	LSarea = ALIAS()
	LNtotal  = 0
	LNuteis	 = 0
	LNdiassem = 0	
	wp_retorno(1) = 0
	wp_retorno(2) = 0
	wp_retorno(3) = 0
	wp_retorno(4) = 0
	wp_retorno(5) = 0
	wp_retorno(6) = {}
	wp_retorno(7) = 0
	wp_retorno(8) = 0
	wp_retorno(9) = 0

	******<<< DEFINE A DATA INICIAL CONSID. APENAS DIAS UTEIS >>>*****
	SELE feriado
	SET ORDER TO TAG dtferiado
	DO WHILE LNuteis < LNdias
		LNtotal = LNtotal + 1
		SEEK STR(0,3)+DTOS(LDdtconsulta - LNtotal)
		IF !FOUND() AND DOW(LDdtconsulta - LNtotal) <> 1
			LNuteis = LNuteis +1
		ENDIF
	ENDDO

	LDdtinicio = LDdtconsulta - LNtotal	&& POSICIONA A DATA SUB. DIAS UTEIS

	wp_retorno(6) = LDdtinicio
	
	IF LFprocesso = "VAZIO"	&& RETORNAR SEM PROCESSAR GIRO
		SELE &LSarea	
		RETURN(LNqtvenda)
	ENDIF



	LDdtfim       = LDdtconsulta - 1

	LF1aleitura = .t.   && PERMITIR TRATAR UM REGISTRO DE PRODUTO NOVO
						&& COM SUA 1a ENTRADA PARA SUBTRAIR OS DIAS
						&& EM QUE O MESMO AINDA NAO ERA DISPONIVEL
						&& OU O MESMO VINHA ZERADO DO INICIO DO MES
						&& E RECEBEU SUA ENTRADA
	********************************************************************

	*<<<<<<<<  ACUMULAS SALDO FINAIS DOS DIAS NO PERIODO >>>>>>*
		
	LDdtsld = LDdtinicio
	LNsldpermanencia = 0
	DO WHILE LDdtsld <= LDdtfim		
		IF DOW(LDdtsld) <> 1		&& VER SE E DIA UTIL
			SET PROCEDURE TO ESTOQUE.SPR
			LNsldpermanencia = LNsldpermanencia + ;
						   ESsaldo(LNemp,LScod,LSclass,LDdtsld)
		ENDIF
		LDdtsld = 	LDdtsld + 1
	ENDDO
	wp_retorno(3) = LNsldpermanencia

	*<<<<<<<<<<<< PARA DETERMINAR SALDO INICIAL DO PERIODO >>>>>>>>>>>>>*
			** saldos de entrada sao englobados na rotina chamadora***

	LNqtentra =	0

	*<<<<<<<<<<<<<<<<<<<<<<<<     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>*
	SELE itemmov
	SET ORDER TO  TAG movimento
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+DTOS(LDdtinicio)
	SET NEAR OFF

	DO WHILE itemmov.data < LDdtconsulta AND ;
			 itemmov.empresa = LNemp AND ;
			 itemmov.codigo  = LScod	&& DESCONSIDERA DATA BASE

		*<<<<<<<<<<<< PARA DETERMINAR DIAS SEM ESTOQUE >>>>>>>>>>>>>*
		IF itemmov.sld_estq < 2 OR ;
		   			(LF1aleitura AND ;
		   			 itemmov.sld_estq - itemmov.qtde < 2 AND ;
		  			 LEFT(itemmov.operacao,1) = "E")

 				IF (LF1aleitura AND itemmov.sld_estq - itemmov.qtde < 2 ;
					AND LEFT(itemmov.operacao,1) = "E")
					LDdtzera =  LDdtinicio	&& DIAS APARTI DO INI.PER
					LDdtentra = itemmov.data
				ELSE				
					LDdtzera =  itemmov.data + 1
					SKIP

					IF !EOF() AND LNemp = itemmov.empresa ;
							  AND LScod = itemmov.codigo
						IF itemmov.data > LDdtfim
							LDdtentra = LDdtfim
						ELSE
							LDdtentra = itemmov.data
						ENDIF
					ELSE
						LDdtentra = LDdtfim
					ENDIF

					SKIP -1
				ENDIF

				DO WHILE LDdtzera <= LDdtentra
					IF DOW(LDdtzera) <> 1		&& VER SE E DIA UTIL
					   **********************************************
					   *   Qdo houver um produto anexado ao que esta
					   * em processo sera verificado o saldo do anexo
					   * e so sera contado como dia de estoque = 0
					   * qdo nao hover estoque em ambos
					   **********************************************
					   LNtmp = 0

					   IF !EMPTY(LScodANEXO)
						  LNregemprocesso = RECNO() && NUMERO DO REGI. ITEMMOVO EM PROCESSO
						  SET PROCEDURE TO ESTOQUE.SPR
						  LNtmp = ;
					  		ESsaldo(LNemp,LScodANEXO,LSclaANEXO,LDdtzera)
						  SELE itemmov
						  SET ORDER TO  TAG movimento
						  GO LNregemprocesso
					   ENDIF
					   IF LNtmp < 2	&& QTDE MINIMA DE ESTOQUE
							LNqtdias = LNqtdias +  1
					   ENDIF
					ENDIF
					LDdtzera = LDdtzera + 1
				ENDDO
		ENDIF

		LF1aleitura = .F.  && Desabilita 1a leitura


		***********************************************************
		*  DESPREZANDO VENDAS P/ CLIENTES => VENDA CASADA
		*          NAO PODEM AFETAR O GIRO
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'S' AND ;
				itemmov.ch_opera = "1" 	  AND ;
				itemmov.negociacao = 2			&& VENDA CASADA

			LNqtcasada = LNqtcasada + itemmov.qtde

			SELE itemmov
			SKIP
			LOOP
		ENDIF

		***********************************************************
		*  EXISTEM TRATAMENTOS DIFERENCIADOS PARA IDL E AS OUTRAS
		***********************************************************
		DO CASE
			CASE itemmov.empresa = 10
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S'
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
			OTHERWISE
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli <>  1
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli = 1
					 IF itemmov.movestq = "S"
						 	LNqtvdrev  = LNqtvdrev    + itemmov.qtde
							LNqtatdrev  = LNqtatdrev  + 1
					 ENDIF
				ENDIF
		ENDCASE

		***********************************************************
		*  ABATENDO DEVOLUCOES para REVENDA OU NAO
		***********************************************************
		IF LEFT(itemmov.operacao,1) = 'E' AND itemmov.ch_opera = "4" AND ;
			    itemmov.movestq = "S"
			SELE notaent
			SET ORDER TO TAG boletim
			SEEK STR(itemmov.empresa,3)+;
				 STR(itemmov.orcamento,6)+;
				 STR(itemmov.codforn,5)

			IF FOUND() AND !empty(notaent.nfdevolve)
				SELE nota
				SET ORDER TO TAG nota
				SEEK STR(itemmov.empresa,3)+STR(notaent.nfdevolve,7)
				IF FOUND()
					IF nota.natu_cli = 1     && REVENDEDOR
					 	LNqtvdrev   = LNqtvdrev   - itemmov.qtde
						LNqtatdrev  = LNqtatdrev  - 1
					    IF LNqtvdrev < 0 OR LNqtatdrev < 0
			 				LNqtvdrev = 0
			 				LNqtatdrev= 0
			 			ENDIF
					ELSE
					 	LNqtvenda  = LNqtvenda  - itemmov.qtde
						LNqtatend  = LNqtatend  - 1
					    IF LNqtvenda < 0 OR LNqtatend < 0
			 				LNqtvenda = 0
			 				LNqtatend = 0
			 			ENDIF
					ENDIF
				ENDIF
				SELE notaent
			ENDIF
			SELE itemmov
		ENDIF
		***********************************************************
		*  PARA DETERMINAR QTDE ENTRADADAS NA FORMACAO DE ESTOQUE
		* MENOS DEVOLUCOES
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'E' AND ;
		   itemmov.ch_opera <> "4"
			 IF itemmov.movestq = "S"
				 	LNqtentra  = LNqtentra  + itemmov.qtde
			 ENDIF
		ENDIF
		DO CASE
			CASE itemmov.empresa = 10
						SS=1
			OTHERWISE		
				***********************************************************
				*  CASO A MERCADORIA SAI POR TRANSFERENCIA OU POR MOV.
				* QUE NAO  SEJA VENDA ELA E DESCONSIDERADA
				* DAS ENTRADAS POIS NAO ESTA DESTINADA AO ESTOQUE DE VENDA
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
					itemmov.ch_opera <> "1"	&& SAIDAS DEVERSAS DA VENDA
					IF itemmov.movestq = "S"
				 		LNqtentra  = LNqtentra  - itemmov.qtde
					ENDIF
					IF LNqtentra < 0
			 			LNqtentra = 0
					ENDIF
				ENDIF
		ENDCASE
		SKIP
	ENDDO	

	IF	LF1aleitura   && Nao Entrou no laco nao Encontrou Reg.
		SKIP -1
		IF  itemmov.empresa <> LNemp OR ;
			itemmov.codigo  <> LScod OR ;
			itemmov.sld_estq= 0				&& NAO TEM REG ANTERIOR
			LNqtdias = LNdias
		ENDIF
	ENDIF			
			

	wp_retorno(1) = LNqtvenda
	wp_retorno(2) = LNqtdias
	wp_retorno(4) = LNqtatend
	wp_retorno(5) = LNqtentra   && Quantidade entrada
	wp_retorno(7) = LNqtvdrev
	wp_retorno(8) = LNqtatdrev
	wp_retorno(9) = LNqtcasada

	SELE &LSarea	
RETURN(LNqtvenda)

FUNCTION ULdfgat
	PARAMETERS LNfilial,LScodigo
	PRIVATE LNgatilho, LSarea
	
	LSarea 		= ALIAS()
	**********************************************************
	LNgatilho 	= 0
	SELE gatilho
	SET ORDER TO TAG gatilho
	SEEK STR(LNfilial,3)+LScodigo
	IF FOUND()
		LNgatilho = gatilho.gatilho
	ENDIF
	**********************************************************
	SELE &LSarea
		
RETURN(LNgatilho)


PROCEDURE UPpedido
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [****]   MODULO INDEPENDENTE				 *
	*------------------------------------------------------------*
	* OBJETIVO....: Devolve a qtde em TRANSIO e PENDENTE de 	 *
	*		pedidos do produto    						 *
	*------------------------------------------------------------*
	* COMENTARIO..: Utilizada para abater na sugestao de compra a*
	*	    quantidade ja pedida e pendente              *
	*------------------------------------------------------------*
	* OBS : As informacoes de qtde pedida ficam inconsistentes   *
	*       quando a simulacao for feita no passado pois os itens *
	*       pedidos constaram como fechados (<> B)				 *
	*       o que fatalmente sera contraditorio com os itens que  *
	*       estavam pendentes na epoca							 *
	*------------------------------------------------------------*
	*  TABELAS....: PEDITE
	*------------------------------------------------------------*
	*  PARAMETROS..:
	*		LSclass,LScod..: Classificacao e Codigo p/ Pesquisa
	*		LNemp..........: Empresa
	*		LDdtbase.......: Data final p/ considerar qtdes
	*	    LSarquivo......: Alias da Tabela. EX. OBJ_ROL1 abre
	*				pedite na CENTRAL e na LOJA e qdo solicita
	*				pesquisa informa em qual alias
	*------------------------------------------------------------*
	*  RETORNO.....:                                             *
	*			wp_retorno(1) = QTDE PEDIDO EM TRANSITO          *
	*			wp_retorno(2) = QTDE PEDIDO AGUARD. FATURAMENTO  *
	*------------------------------------------------------------*
	PARAMETERS LSclass,LScod,LNemp,LDdtbase,LSarquivo
	
	PRIVATE LNqttrans		&& ACM. QTDE EM TRANSITO
	PRIVATE LNqtaguarda		&& ACM. QTDE PENDENTE
	PRIVATE LSarea			&& MACADOR DO ALIAS ANTERIOR P/ RETORNAR

	LNqttrans 		= 0
	LNqtaguarda 	= 0
	wp_retorno(1) 	= 0
	wp_retorno(2)	= 0
	LSarea = ALIAS()

	IF TYPE("LSarquivo") $ "UL"  && AREA NAO INFORMADA
		LSarquivo = "pedite"
	ENDIF
	SELECT  &LSarquivo
	SET ORDER TO TAG codsit
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+"B"   && REGISTROS PENDENTES DE PEDIDO
	SET NEAR OFF
	IF BOF() AND EOF()       && ITEMMOV ESTA VAZIO
		SELE &LSarea	
		RETURN(0)
	ENDIF

	DO WHILE !EOF() AND LScod 	  = &LSarquivo .codigo ;
					AND LNemp 	  = &LSarquivo .empresa;
					AND	LDdtbase >= &LSarquivo .data ;
					AND LEFT(&LSarquivo .situacao,1) = "B"
	 	LNqttrans	= LNqttrans 	+ &LSarquivo .qtdetr
	 	LNqtaguarda	= LNqtaguarda 	+ ;
 			(&LSarquivo .qtde - &LSarquivo .qtdetr - &LSarquivo .qtdeatd)
		SKIP
	ENDDO
	SELE &LSarea	
	wp_retorno(1) = LNqttrans
	wp_retorno(2) = LNqtaguarda
RETURN(LNqttrans+LNqtaguarda)

*************************************************




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*          GERAL_C/MS-DOS Supporting Procedures and Functions    
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

#REGION 4
PROCEDURE readdeac
  IF !WEXIST(WOUTPUT()) OR WP_FLGFECHA
    CLEAR READ
    RETURN .T.
  ENDIF
RETURN .F.

PROCEDURE readact
  IF !isediting  AND !wp_flgfecha
******* desativado * 02/09/99  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE readwhen
  IF wp_flgfecha
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE readvalid
  *--------------------------------------------------------------*
  *   Nao aceitar validacao quando janela for encerrada com:
  *		 <ESC>	LASTKEY() = (27),
  *  	TIMEOUT	READKEY() = (20) ou (278)
  *--------------------------------------------------------------*
  IF LASTKEY() = 27  ;
  	OR READKEY() = 20 OR READKEY() = 276
  						 && OR LASTKEY() = 6 OR LASTKEY() = 15
  	 RETURN .F.
  ENDIF
RETURN .T.

PROCEDURE objact
  IF !isediting
  	SELECT (m.wzalias)
  	SHOW GETS
  ENDIF
RETURN

PROCEDURE wizerrorhandler
#DEFINE C_EDITS			'Favor Finalizar a Edicao.'
#DEFINE C_TOPFILE		'Inicio do Arquivo.'
#DEFINE C_ENDFILE		'Final do Arquivo.'
#DEFINE C_BRTITLE		'Localiza Registro.'
#DEFINE C_NOLOCK		'Acesso negado - Registro em uso. '+ALIAS()
#DEFINE C_ECANCEL		'Edicao Cancelada.'
#DEFINE C_DELREC		'Apagar Registro Selecionado ?'
#DEFINE C_NOFEAT		'Feature not available yet.'
#DEFINE C_NOWIZ			'Wizard application is not available.'
#DEFINE C_MAKEREPO		'Creating report with Report Wizard.'
#DEFINE C_NOREPO		'Could not create report.'
#DEFINE C_DELNOTE 		'Deleting records...'
#DEFINE C_BADEXPR		'Expresao invalida.'
#DEFINE C_LOCWIZ		'Locate WIZARD.APP:'
#DEFINE C_MULTITABLE	'You have multiple related tables. Adding records in not allowed.'
	* This very simple error handler is primarily intended
	* to trap for General field OLE errors which may occur
	* during editing from the MODIFY GENERAL window.
	WAIT WINDOW message()
RETURN


PROCEDURE printrec
	  PRIVATE sOldError,wizfname,saverec,savearea,tmpcurs,tmpstr
	  PRIVATE prnt_btn,p_recs,p_output,pr_out,pr_record
	  STORE 1 TO p_recs,p_output
	  STORE 0 TO prnt_btn
	  STORE RECNO() TO saverec
	  m.sOldError=ON('error')
	  DO pdialog
	  IF m.prnt_btn = 2
	    RETURN
	  ENDIF
	  IF !FILE(ALIAS()+'.FRX')
	  	m.wizfname=SYS(2004)+'WIZARDS\'+'WIZARD.APP'
	  	IF !FILE(m.wizfname)
			ON ERROR *
			m.wizfname=LOCFILE('WIZARD.APP','APP',C_LOCWIZ)
			ON ERROR &sOldError
			IF !'WIZARD.APP'$UPPER(m.wizfname)
      			WAIT WINDOW C_NOWIZ
      			RETURN
			ENDIF
	  	ENDIF
     	WAIT WINDOW C_MAKEREPO NOWAIT
		m.savearea=SELECT()
		m.tmpcurs='_'+LEFT(SYS(3),7)
		CREATE CURSOR (m.tmpcurs) (comment m)
		m.tmpstr = '* LAYOUT = COLUMNAR'+CHR(13)+CHR(10)
		INSERT INTO (m.tmpcurs) VALUES(m.tmpstr)
		SELECT (m.savearea)
	  	DO (m.wizfname) WITH '','WZ_QREPO','NOSCRN/CREATE',ALIAS(),m.tmpcurs
		USE IN (m.tmpcurs)
     	WAIT CLEAR
	  	IF !FILE(ALIAS()+'.FRX')  &&wizard could not create report
     		WAIT WINDOW C_NOREPO
     		RETURN
	  	ENDIF
	  ENDIF
	
  	  m.pr_out=IIF(m.p_output=1,'TO PRINT NOCONSOLE','PREVIEW')
	  m.pr_record=IIF(m.p_recs=1,'NEXT 1','ALL')
  	  REPORT FORM (ALIAS()) &pr_out &pr_record
	  GO m.saverec
RETURN


*******                               *******
****     ROTINAS DE APOIO A IMPRESSAO    ****
*******                               *******


FUNCTION UPstatchq    && para programa SCGC301 (altera status chqpag)
*** STATUS => CHQPAG
	=REGLOCK(.T.)
	REPLACE status WITH "NI"
RETURN (" ")
*******-----

FUNCTION VAI_PARA   && evita erro em go tos para arquivo vazio
	ON ERROR do erro_vai	
	GO WP_RECORD    && se wp_record nao existe , nao para o sistema
	ON ERROR DO UPerrosys
RETURN

PROCEDURE ERRO_VAI && desvio de erro em posicionamento de registro

RETURN





*******


FUNCTION UPniv_clas  	&& retorna o nivel digitado na estrt. classifica
	PARAMETERS LSclass
	PRIVATE LSposicao, LNnivel
	*-------------------------------------------------------------*
	LSposicao = STR(LEN(ALLTRIM(LSclass)),2)
	LNnivel   = ASCAN(vclass,LSposicao)
RETURN(LNnivel)




** COM EFEITO SO NO RELATORIO RELOSI PARA PREENCHER COLUNA LATERAL

FUNCTION ULcol_osi
	PARAMETERS LNind, LSordem
	
	IF LSordem = "A"
		RETURN(" "+VLquantis(LNind,2))
	ENDIF

** OPCOES PARA 2a PARTE "B"

	IF LNind = 6
		RETURN(REPLICAT("=",42))
	ENDIF
	
	IF LNind = 7
		RETURN(PADC(STR(m.orcamento,6)+"/"+STR(m.vias_osi,2)+"-<"+m.ordem+">",43))
	ENDIF

	IF LNind = 8
		RETURN(PADC("Liberacao N.F.",43))
	ENDIF

	IF LNind = 11
		RETURN("Cliente :"+m.nome)
	ENDIF
RETURN(" ")	


********************************************************************


*****>>>>>>>>>>--------------------------





*************************************************************************
*****             		   PREVISAO DE VENDAS                  	   ******
*************************************************************************


*<<<<<<<<<<<<<<<<<<<<<<       2o ESTAGIO           >>>>>>>>>>>>>>>>>>>>>


*********************************************************************
* UPobjprev		: RETORNA O REGISTRO DE PREVISAO (PRVITSTQ)
*				MONTADO PARA FILIAL, CODIGO, CLASSIFICA,
*				DATA DE CONSULTA E DIAS DE RETROACAO EM CINCO
*				FAIXAS
*			   EX:
*				CLASSIFICA :
*				FILIAL     : 01
*				DATA 	   : 01/10/98
*				DIAS RETR  :
*							m.qtd_dias_a 	= 180
*							m.qtd_dias_b	= 90
*							m.qtd_dias_c	= 45
*							m.qtd_dias_d	= 25
*							m.qtd_dias_e	= 15
*
*				LFprocesso	: "VAZIO" => NAO PROCESSAR GIRO
*							: "NORMAL" => PROCESSAR GIRO
*									
**********************************************************************

FUNCTION UPprevstq
PARAMETERS  LSclassifica,LNfilial,LDdtcons,LNda,LNdb,LNdc,LNdd,LNde,;
			LNemdias,LNvariacao,LFprocesso

PRIVATE LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
PRIVATE LVqtdatend,LVdtini,LVgiro,LVd,LVdias
PRIVATE LNpercent			&& PERCENTUAL DE DIAS SEM ESTOQUE
PRIVATE LNgiroreal			&& GIRO  REAL A 12 MESES ATRAS
PRIVATE LNvdreal			&& VENDA REAL A 12 MESES ATRAS
PRIVATE LNprcdesvio			&& PERCENT DE DESVIO DA PREV. NO PASSADO
							&& P/ APLICAR NA NOVA PREV (SAZONALIDADE)
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES
PRIVATE LNdifgiro			&& DIFERENCE DO GIRO REAL E PREVISTO A 12 MESES

PRIVATE LScodANEXO			&& IDENTIFICA CODIGO ANEXO AO PRODUTO SOLICITADO
PRIVATE LSclaANEXO			&& IDENTIFICA CLASSIFICA ANEXO AO PRODUTO SOLICITADO


DIMENSION LVqtd_dia(6),LVvendas(6),LVentradas(6),LVsemstq(6),LVperm_stq(6)
DIMENSION LVcasada(6)
DIMENSION LVqtdatend(6),LVdtini(6),LVgiro(6),LVd(6),LVdias(6)
DIMENSION LVrvvendas(6),LVrvgiro(6)

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent,LNgiroreal,LNprcdesvio,LNdifcons,LNvdreal


SELE prvitstq
SCATTER MEMVAR BLANK

SELE grupo
SET ORDER TO classifica
SEEK LSclassifica
IF !FOUND()
	RETURN
ENDIF	

m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons

*SELE grupoanx
*SET ORDER TO TAG classifica
*SEEK LSclassifica
*IF FOUND()
*	LScodANEXO		= grupoanx.codanx
*	LSclaANEXO		= grupoanx.clasanx
*ELSE
	LScodANEXO		= ""
	LSclaANEXO		= ""
*ENDIF	

**************************************************************************

STORE 0 TO  LVqtd_dia,LVvendas,LVentradas,LVsemstq,LVperm_stq
STORE 0 TO  LVcasada
STORE 0 TO  LVqtdatend,LVdtini,LVgiro,LVd,LVdias
STORE 0 TO  LVrvvendas,LVrvgiro
STORE 0 TO  LNpercent


FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LNd&Lsc
    LVqtd_dia(La)   = LNd&Lsc && USA O VETOR POIS A OCORR(6) = 0 AJUDA
    						  && NA CHAMADA ULdiasvd
NEXT


LVdtini(6) 	 = LDdtcons

************************************************************
* PROCESSO P/ 5 FAIXAS DE DIAS DE RETROCESSO
************************************************************

FOR LNasc = 5 to 1 step -1
    La = LNasc
	Lb = LNasc + 1
	STORE 0 TO wp_retorno
	********************************************************
	* 	Os parametros de codigo anexo e classificacao anexa
	* sao passado para permitir a verificacao de dias de estoque
	* zerado considerando o codigo principal e o anexo
	*
	********************************************************
    LVvendas(La)  = LVvendas(Lb) + ;
	    ULdiasvd(m.classifica,m.codigo,LNfilial,LVdtini(Lb),;
					     LVqtd_dia(La) - LVqtd_dia(Lb),;
					     LScodANEXO,LSclaANEXO, LFprocesso)

    LVcasada(La)  	= LVcasada(Lb) 	 + wp_retorno(9)
    LVrvvendas(La)  = LVrvvendas(Lb) + wp_retorno(7)
    LVentradas(La) =LVentradas(Lb) + wp_retorno(5)  && Qtde entradas
    LVsemstq(La)   =LVsemstq(Lb)   + wp_retorno(2)  && DIAS SEM ESTQ
    LVperm_stq(La) =LVperm_stq(Lb) + wp_retorno(3)
										   		   && ESQ DE FECH DOS DIAS ACM
    LVqtdatend(La) =LVqtdatend(Lb) + wp_retorno(4) && QTDE ATENDI

	IF !EMPTY(LScodANEXO)  && ACUMULAR MOVIMENTO DO CODIGO ANEXO
			***********************************************************
			*   Neste Caso nao e somado a ocorrencia Lb pois esta soma
			*  ja ocorreu no processo do produto principas cambendo
			*  apenas somar os valores especificos do produto ANEXO no
			*  periodo proposto
			*
			***********************************************************
			********************************************************
			* 	Os parametros de codigo anexo e classificacao anexa
			* sao passado nulos pois o processo ja e o do proprio
			* anexo.
			********************************************************
			STORE 0 TO wp_retorno
	    	LVvendas(La)  = LVvendas(La) + ;
			    ULdiasvd(LSclaANEXO,LScodANEXO,LNfilial,LVdtini(Lb),;
						     LVqtd_dia(La) - LVqtd_dia(Lb),;
						     "","", LFprocesso)

		    LVcasada(La)  	= LVcasada(La) 	 + wp_retorno(9)
		    LVrvvendas(La)  = LVrvvendas(La) + wp_retorno(7)
    		LVentradas(La) 	= LVentradas(La) + wp_retorno(5)  && Qtde entradas
**********  LVsemstq(La)   	= LVsemstq(La)   + wp_retorno(2)  && DIAS SEM ESTQ
    		LVperm_stq(La) 	= LVperm_stq(La) + wp_retorno(3)
												&& ESQ DE FECH DOS DIAS ACM
	    	LVqtdatend(La)  = LVqtdatend(La) + wp_retorno(4) && QTDE ATENDI
	ENDIF

    LVdtini(La)    =wp_retorno(6)  && DATA ONDE INICIOU O ULT PROCE.
									   && PARA QUE O PROCESSO ATUAL NAO
									   && AVANCE NESTE PERIODO
									   && JA QUE OS DADOS SERAO SOMADOS
	*----------------------------------------------------------------*
	* 	O calculo do percentual de dias em que o estoque fica zerado
	* indica conforme o seu indice que :
	*		> 70 % => Indica que o produto pode estar sendo atendido
	*					sob encomenda o que provoca um alto  valor
	*					de giro porem falso. Neste caso o giro e feito
	*					sobre todo o periodo e nao somente sobre os dias
	*					com estoque
	*	   <= 70 % => Produto com venda normal e provavelmente nao venda
	*					nos dias zerados pela falta de estoque. Neste
	*					caso o giro e feito sobre os dias com estoque.
	*----------------------------------------------------------------*
	LNpercent = (LVsemstq(La) * 100) / LVqtd_dia(La)

	IF LNpercent > 70
		LVgiro(La) 	= LVvendas(La)   /   LVqtd_dia(La)
		LVrvgiro(La)= LVrvvendas(La) /   LVqtd_dia(La)
		LVd(La)		= LVqtd_dia(La)
		LVdias(La)	= LVqtd_dia(La)
	ELSE
		LVgiro(La) 	= LVvendas(La) / (LVqtd_dia(La) - LVsemstq(La))
		LVrvgiro(La)= LVrvvendas(La)/(LVqtd_dia(La)-LVsemstq(La))
		LVd(La)		= LVqtd_dia(La) - LVsemstq(La)
		LVdias(La)	= LVqtd_dia(La)
	ENDIF
NEXT
************************************************************
* INCORPORADO O SALDO DE ABERTURA DOS PERIODOS				*
************************************************************
FOR La = 5 to 1 step -1
	DO CASE
		CASE LFprocesso = "VAZIO"
		   	 LVentradas(La) =	0
		CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,LVdtini(LA)- 1)

		OTHERWISE
			SET PROCEDURE TO ESTOQUE.SPR
		   	LVentradas(La) =	LVentradas(La) + ;
				ESsaldo(LNfilial,m.codigo,m.classifica,LVdtini(LA)- 1)
	ENDCASE
NEXT
************************************************************
* INCORPORADO O SALDO NA DATA								*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.saldo 	= 0
	CASE !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo = m.saldo + ;
			 	  ESsaldo(LNfilial,LScodANEXO,LSclaANEXO,m.data)
	OTHERWISE
		SET PROCEDURE TO ESTOQUE.SPR
		m.saldo	= ESsaldo(LNfilial,m.codigo,m.classifica,m.data)
ENDCASE
************************************************************
* INCORPORADO GATILHOS DE SALDO DO PRODUTO	(SO DO PRINCIPAL)*
************************************************************

SELE gatilho
SET ORDER TO TAG gatilho
SEEK STR(m.filial,3)+m.codigo
IF FOUND()
	m.gatilho	= gatilho.gatilho
ELSE
	m.gatilho 	= 0
ENDIF

************************************************************
* INCORPORADO O SALDO DE PEDIDOS							*
************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
		m.pedidotran	=	0
		m.pedidopfat	=	0
	OTHERWISE
		= UPpedido(m.classifica,m.codigo,LNfilial,m.data)
		m.pedidotran	=	wp_retorno(1)
		m.pedidopfat	=	wp_retorno(2)
		IF !EMPTY(LScodANEXO)  && ACUMULAR  DO CODIGO ANEXO
			= UPpedido(LSclaANEXO,LScodANEXO,LNfilial,m.data)
			m.pedidotran	=	m.pedidotran + wp_retorno(1)
			m.pedidopfat	=	m.pedidopfat + wp_retorno(2)
		ENDIF
ENDCASE
************************************************************
*       DEFINE MEDIA DE PERMANENCIA EM ESTOQUE
************************************************************
LNtmp = LVqtd_dia(1)+LVqtd_dia(2)+LVqtd_dia(3)+ ;
				 LVqtd_dia(4)+LVqtd_dia(5)
m.media_perm = 0
IF 	LNtmp > 0
	m.media_perm = ((LVperm_stq(1)/LVdias(1)) * 2 +;
				   (LVperm_stq(2)/LVdias(2))  * 4 +;
				   (LVperm_stq(3)/LVdias(3))  * 3   +;
				   (LVperm_stq(4)/LVdias(4))  * 1   +;
				   (LVperm_stq(5)/LVdias(5))  * 1   )/11
ENDIF
************************************************************
*      DEFINE A GIRO MEDIO VAREJO
************************************************************
m.giromedio =  ((LVgiro(1) * 1)  +;
				(LVgiro(2) * 1)  +;
				(LVgiro(3) * 3)  +;
				(LVgiro(4) * 2)  +;
				(LVgiro(5) * 1)) /8

m.prvvenda_A  = LNemdias * m.giromedio

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
IF m.giromedio > 0.30  OR  m.gatilho = 0 OR m.prvvenda_A > m.gatilho
				m.sugestao_A = (m.prvvenda_A) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_A =   m.sugestao_A + ;
							   (m.sugestao_A * LNvariacao)/100		
ELSE
				m.prvvenda_A = 0		    && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_A = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDIF

****************************************************************
*      DEFINE A GIRO MEDIO REVENDA
****************************************************************
*
*    Devido a irregularidade das vendas realizadas para revendas
* adota-se a media linear
*
****************************************************************

m.rvgiromedi = (((LVrvgiro(1)) * 2)  +;
			    ((LVrvgiro(2)) * 1)  +;
			    ((LVrvgiro(3)) * 1)  +;
			    ((LVrvgiro(4)) * 1)  +;
			    ((LVrvgiro(5)) * 1)) /6

m.rvgiromedi = ((m.giromedio) + (m.giromedio  + m.rvgiromedi)) / 2

*************** A previsao e uma media entre: ******************
*		A) Previsao sem Considerar Revenda
*		B) Previsao Considerando Revenda
****************************************************************

m.prvvenda_B = (LNemdias * m.rvgiromedi)

****************************************************************
* CASO O GIRO SEJA <= 0.30 FAZER SUGESTAO PELO GATILHO
* CASO O GIRO SEJA >  0.30 FAZER SUGESTAO PELO GIRO
****************************************************************
* => SUGESTAO (-) ESTA SOBRANDO
* => SUGESTAO (+) ESTA FALTANDO
****************************************************************
DO CASE
	CASE LFprocesso = "VAZIO"
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
				m.sugestao_B = 0
	CASE m.rvgiromedi > 0.30  OR  m.gatilho = 0 OR m.prvvenda_B > m.gatilho
				m.sugestao_B = (m.prvvenda_B) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
				m.sugestao_B =   m.sugestao_B + ;
							   (m.sugestao_B * LNvariacao)/100		
	OTHERWISE
				m.prvvenda_B = 0            && NAO CONSIDERAR A PREVISAO POIS
											&& O GIRO NAO PERMITE
											
				m.sugestao_B = (m.gatilho) - ;
							   (m.saldo + m.pedidotran + m.pedidopfat)
ENDCASE


**************** DEFINE PEDIR ******************************
**********************  descartando sazonalidade ***********
*m.prvvenda_C = m.prvvenda_B
*m.prvvenda_C = m.prvvenda_C + (m.prvvenda_C * m.indice_saz) / 100
*
*m.pedir      = (m.prvvenda_B + m.gatilho) ;
*				- (m.saldo + m.pedidotran + m.pedidopfat)
*

m.pedir 	 =  m.sugestao_B

*******************************************************************
*	m.gatilho deve conter o valor de gatilho envolvido na operacao
*****************************************************************

IF m.prvvenda_B  >  0		&& PREVISAO FEITA PELO GIRO DESPRESA O GATILHO
	m.gatilho    =  0
ENDIF
************************************************************

m.sugestao_C = m.sugestao_B

************************************************************
*  COLOCACAO DOS CAMPOS PARA GRAVACAO
************************************************************
m.filial	 = LNfilial
m.ordem 	 = grupo.ordem
m.codigo	 = grupo.codigo
m.classifica = grupo.classifica
m.codforn    = grupo.codforn
m.data	 	 = LDdtcons
m.dias_stoca = LNemdias

FOR La = 1 to 5
	Lsc = CHR(La+64)
   	m.qtd_dias_&Lsc = LVqtd_dia(La)
   	m.qtdatend_&Lsc = LVqtdatend(La)
	m.entradas_&Lsc = LVentradas(La)
	m.vendas_&Lsc 	= LVvendas(La)
	m.vdcasada_&Lsc = LVcasada(La)
	m.rvvendas_&Lsc = LVrvvendas(La)
	m.semstq_&Lsc 	= LVsemstq(La)
	m.giro_&Lsc		= LVgiro(La)
	m.rvgiro_&Lsc	= LVrvgiro(La)
NEXT

m.preco_tab = 0
m.preco_normal= 0
m.preco_vendor= 0
STORE 0 TO desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
			desc_7,desc_8,desc_9,ipi,avindice,apindice

IF USED("tabforn")		&& TABELA DE PRECOS /FORNECEDOR
						&& EM OBJ_ROL1 NAO PRECISA DO PRECO
						&& O ARQ NEM E ABERTO
	SELE tabforn
	SET ORDER TO TAG tabela
	SEEK STR(m.codforn,5)+m.codigo
	IF FOUND()
		IF !EMPTY(tabforn.grp_desc)
			SELE dsctforn
			SET ORDER TO TAG tabela
			SEEK STR(m.codforn,5)+tabforn.grp_desc
			IF !FOUND()
				SELE tabforn
			ENDIF			
		ENDIF
		SCATTER MEMVAR fields desc_1,desc_2,desc_3,desc_4,desc_5,desc_6,;
						desc_7,desc_8,desc_9,desc_t,;
						avindice,apindice,aliq_ipi
		m.preco_tab  = tabforn.preco_tab
		*------------------- Calculo do Preco Final ------------------*
		STORE 0 TO m.preco_compra
		LNvendor =  m.avindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_normal= m.preco_compra
		*-------------------------------------------------------------*
		LNvendor =  m.apindice
		DO UPcalcusto WITH ;
			 1,m.preco_tab,m.desc_t,m.aliq_ipi,0,0,;
				0,0,LNvendor,0,0,;
			    0,0,0,;
			    0,0,0,;
			    0,0,0,;
			    m.preco_compra,0
		m.preco_vendor= m.preco_compra
		*-------------------------------------------------------------*
	ENDIF
ENDIF
RETURN

*<<<<<<<<<<<<<<<<<<<<<<< SUB-ROTINAS DE APOIO >>>>>>>>>>>>>>>>>>>>>>>>>>*
*************************************************************************
*************************************************************************


FUNCTION ULdiasvd	&& VENDAS PARA GIRO-3
	******************************************************************
	* Esta rotina nao deve considerar as qtdes vendidas na data base
	* para manter coerencia :
	*   EX: O operador solicita um dia anterior (GIRO-3)
	*		  A rotina deve somar as vendas do dia anterior e div / 1
	*         e se as qtdes da data base forem consideradas o giro
	*		  vai ser alto e contrariar o raciocinio do operador
	*  RETORNO
	*		A rotina devolvera
	*			wp_retorno(1) = QTDE DE VENDAS
	*			wp_retorno(2) = QTDE DE DIAS SEM ESTOQUE
	*			wp_retorno(3) 	Saldos de Fechamento de dias Acumulados
	*			wp_retorno(4) 	Qtde de Atendimento (Registro de Venda)
	*	   		wp_retorno(5) 	A qtde de entradas subtraindo saida p/ tranf
	*						para nao redundar com a entrada na outra filial
	*	   		wp_retorno(6) 	A data de inicio do processo que sera retor-
	*							nada para evitar que o periodo deja repro-
	*							cessado
	*			wp_retorno(7) = QTDE DE VENDAS A REVENDAS
	*			wp_retorno(8) = QTDE DE ATQNDIMENTOS A REVENDAS
	*			wp_retorno(9) = QTDE DE VENDA CASADA
	******************************************************************

	PARAMETERS LSclass,LScod,LNemp,LDdtconsulta,LNdias,;
			     LScodANEXO,LSclaANEXO, LFprocesso

	PRIVATE LNqtentra, LDdtinicio , LSarea, LNsubtr,I,LNctrdias
	PRIVATE LNqtvenda, LNqtatend, LNqtvdrev, LNqtatdrev, LNqtcasada
	PRIVATE LNqtdias , LDdtzera,LDdtentra
	PRIVATE LDdtsld, LNsldpermanencia
	PRIVATE LNregemprocesso && NUMERO DO REGI. ITEMMOVO EM PROCESSO


	LNqtdias    = 0		&& QTDE DE DIAS SEM ESTOQUE
	LNqtentra   = 0     && QTDE ENTRADA
	LNqtvenda 	= 0		&& QTDE VENDIDA
	LNqtcasada	= 0		&& QTDE VENDA CASADA
	LNqtatend   = 0		&& QTDE DE REGISTRO DE VENDAS
	LNqtvdrev	= 0		&& VENDAS P/ REVENDA
	LNqtatdrev	= 0		&& ATEND P/ REVENDA

	LSarea = ALIAS()
	LNtotal  = 0
	LNuteis	 = 0
	LNdiassem = 0	
	wp_retorno(1) = 0
	wp_retorno(2) = 0
	wp_retorno(3) = 0
	wp_retorno(4) = 0
	wp_retorno(5) = 0
	wp_retorno(6) = {}
	wp_retorno(7) = 0
	wp_retorno(8) = 0
	wp_retorno(9) = 0

	******<<< DEFINE A DATA INICIAL CONSID. APENAS DIAS UTEIS >>>*****
	SELE feriado
	SET ORDER TO TAG dtferiado
	DO WHILE LNuteis < LNdias
		LNtotal = LNtotal + 1
		SEEK STR(0,3)+DTOS(LDdtconsulta - LNtotal)
		IF !FOUND() AND DOW(LDdtconsulta - LNtotal) <> 1
			LNuteis = LNuteis +1
		ENDIF
	ENDDO

	LDdtinicio = LDdtconsulta - LNtotal	&& POSICIONA A DATA SUB. DIAS UTEIS

	wp_retorno(6) = LDdtinicio
	
	IF LFprocesso = "VAZIO"	&& RETORNAR SEM PROCESSAR GIRO
		SELE &LSarea	
		RETURN(LNqtvenda)
	ENDIF



	LDdtfim       = LDdtconsulta - 1

	LF1aleitura = .t.   && PERMITIR TRATAR UM REGISTRO DE PRODUTO NOVO
						&& COM SUA 1a ENTRADA PARA SUBTRAIR OS DIAS
						&& EM QUE O MESMO AINDA NAO ERA DISPONIVEL
						&& OU O MESMO VINHA ZERADO DO INICIO DO MES
						&& E RECEBEU SUA ENTRADA
	********************************************************************

	*<<<<<<<<  ACUMULAS SALDO FINAIS DOS DIAS NO PERIODO >>>>>>*
		
	LDdtsld = LDdtinicio
	LNsldpermanencia = 0
	DO WHILE LDdtsld <= LDdtfim		
		IF DOW(LDdtsld) <> 1		&& VER SE E DIA UTIL
			SET PROCEDURE TO ESTOQUE.SPR
			LNsldpermanencia = LNsldpermanencia + ;
						   ESsaldo(LNemp,LScod,LSclass,LDdtsld)
		ENDIF
		LDdtsld = 	LDdtsld + 1
	ENDDO
	wp_retorno(3) = LNsldpermanencia

	*<<<<<<<<<<<< PARA DETERMINAR SALDO INICIAL DO PERIODO >>>>>>>>>>>>>*
			** saldos de entrada sao englobados na rotina chamadora***

	LNqtentra =	0

	*<<<<<<<<<<<<<<<<<<<<<<<<     >>>>>>>>>>>>>>>>>>>>>>>>>>>>>*
	SELE itemmov
	SET ORDER TO  TAG movimento
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+DTOS(LDdtinicio)
	SET NEAR OFF

	DO WHILE itemmov.data < LDdtconsulta AND ;
			 itemmov.empresa = LNemp AND ;
			 itemmov.codigo  = LScod	&& DESCONSIDERA DATA BASE

		*<<<<<<<<<<<< PARA DETERMINAR DIAS SEM ESTOQUE >>>>>>>>>>>>>*
		IF itemmov.sld_estq < 2 OR ;
		   			(LF1aleitura AND ;
		   			 itemmov.sld_estq - itemmov.qtde < 2 AND ;
		  			 LEFT(itemmov.operacao,1) = "E")

 				IF (LF1aleitura AND itemmov.sld_estq - itemmov.qtde < 2 ;
					AND LEFT(itemmov.operacao,1) = "E")
					LDdtzera =  LDdtinicio	&& DIAS APARTI DO INI.PER
					LDdtentra = itemmov.data
				ELSE				
					LDdtzera =  itemmov.data + 1
					SKIP

					IF !EOF() AND LNemp = itemmov.empresa ;
							  AND LScod = itemmov.codigo
						IF itemmov.data > LDdtfim
							LDdtentra = LDdtfim
						ELSE
							LDdtentra = itemmov.data
						ENDIF
					ELSE
						LDdtentra = LDdtfim
					ENDIF

					SKIP -1
				ENDIF

				DO WHILE LDdtzera <= LDdtentra
					IF DOW(LDdtzera) <> 1		&& VER SE E DIA UTIL
					   **********************************************
					   *   Qdo houver um produto anexado ao que esta
					   * em processo sera verificado o saldo do anexo
					   * e so sera contado como dia de estoque = 0
					   * qdo nao hover estoque em ambos
					   **********************************************
					   LNtmp = 0

					   IF !EMPTY(LScodANEXO)
						  LNregemprocesso = RECNO() && NUMERO DO REGI. ITEMMOVO EM PROCESSO
						  SET PROCEDURE TO ESTOQUE.SPR
						  LNtmp = ;
					  		ESsaldo(LNemp,LScodANEXO,LSclaANEXO,LDdtzera)
						  SELE itemmov
						  SET ORDER TO  TAG movimento
						  GO LNregemprocesso
					   ENDIF
					   IF LNtmp < 2	&& QTDE MINIMA DE ESTOQUE
							LNqtdias = LNqtdias +  1
					   ENDIF
					ENDIF
					LDdtzera = LDdtzera + 1
				ENDDO
		ENDIF

		LF1aleitura = .F.  && Desabilita 1a leitura


		***********************************************************
		*  DESPREZANDO VENDAS P/ CLIENTES => VENDA CASADA
		*          NAO PODEM AFETAR O GIRO
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'S' AND ;
				itemmov.ch_opera = "1" 	  AND ;
				itemmov.negociacao = 2			&& VENDA CASADA

			LNqtcasada = LNqtcasada + itemmov.qtde

			SELE itemmov
			SKIP
			LOOP
		ENDIF

		***********************************************************
		*  EXISTEM TRATAMENTOS DIFERENCIADOS PARA IDL E AS OUTRAS
		***********************************************************
		DO CASE
			CASE itemmov.empresa = 10
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S'
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
			OTHERWISE
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ NAO REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli <>  1
					IF itemmov.movestq = "S"
						 	LNqtvenda  = LNqtvenda  + itemmov.qtde
							LNqtatend  = LNqtatend  + 1
					 ENDIF
				ENDIF
				***********************************************************
				*  PARA DETERMINAR QTDE VENDA  E ATEND. P/ REVENDAS    *
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
						itemmov.ch_opera = "1" 	  AND ;
						itemmov.natu_cli = 1
					 IF itemmov.movestq = "S"
						 	LNqtvdrev  = LNqtvdrev    + itemmov.qtde
							LNqtatdrev  = LNqtatdrev  + 1
					 ENDIF
				ENDIF
		ENDCASE

		***********************************************************
		*  ABATENDO DEVOLUCOES para REVENDA OU NAO
		***********************************************************
		IF LEFT(itemmov.operacao,1) = 'E' AND itemmov.ch_opera = "4" AND ;
			    itemmov.movestq = "S"
			SELE notaent
			SET ORDER TO TAG boletim
			SEEK STR(itemmov.empresa,3)+;
				 STR(itemmov.orcamento,6)+;
				 STR(itemmov.codforn,5)

			IF FOUND() AND !empty(notaent.nfdevolve)
				SELE nota
				SET ORDER TO TAG nota
				SEEK STR(itemmov.empresa,3)+STR(notaent.nfdevolve,7)
				IF FOUND()
					IF nota.natu_cli = 1     && REVENDEDOR
					 	LNqtvdrev   = LNqtvdrev   - itemmov.qtde
						LNqtatdrev  = LNqtatdrev  - 1
					    IF LNqtvdrev < 0 OR LNqtatdrev < 0
			 				LNqtvdrev = 0
			 				LNqtatdrev= 0
			 			ENDIF
					ELSE
					 	LNqtvenda  = LNqtvenda  - itemmov.qtde
						LNqtatend  = LNqtatend  - 1
					    IF LNqtvenda < 0 OR LNqtatend < 0
			 				LNqtvenda = 0
			 				LNqtatend = 0
			 			ENDIF
					ENDIF
				ENDIF
				SELE notaent
			ENDIF
			SELE itemmov
		ENDIF
		***********************************************************
		*  PARA DETERMINAR QTDE ENTRADADAS NA FORMACAO DE ESTOQUE
		* MENOS DEVOLUCOES
		***********************************************************

		IF LEFT(itemmov.operacao,1) = 'E' AND ;
		   itemmov.ch_opera <> "4"
			 IF itemmov.movestq = "S"
				 	LNqtentra  = LNqtentra  + itemmov.qtde
			 ENDIF
		ENDIF
		DO CASE
			CASE itemmov.empresa = 10
						SS=1
			OTHERWISE		
				***********************************************************
				*  CASO A MERCADORIA SAI POR TRANSFERENCIA OU POR MOV.
				* QUE NAO  SEJA VENDA ELA E DESCONSIDERADA
				* DAS ENTRADAS POIS NAO ESTA DESTINADA AO ESTOQUE DE VENDA
				***********************************************************
				IF LEFT(itemmov.operacao,1) = 'S' AND ;
					itemmov.ch_opera <> "1"	&& SAIDAS DEVERSAS DA VENDA
					IF itemmov.movestq = "S"
				 		LNqtentra  = LNqtentra  - itemmov.qtde
					ENDIF
					IF LNqtentra < 0
			 			LNqtentra = 0
					ENDIF
				ENDIF
		ENDCASE
		SKIP
	ENDDO	

	IF	LF1aleitura   && Nao Entrou no laco nao Encontrou Reg.
		SKIP -1
		IF  itemmov.empresa <> LNemp OR ;
			itemmov.codigo  <> LScod OR ;
			itemmov.sld_estq= 0				&& NAO TEM REG ANTERIOR
			LNqtdias = LNdias
		ENDIF
	ENDIF			
			

	wp_retorno(1) = LNqtvenda
	wp_retorno(2) = LNqtdias
	wp_retorno(4) = LNqtatend
	wp_retorno(5) = LNqtentra   && Quantidade entrada
	wp_retorno(7) = LNqtvdrev
	wp_retorno(8) = LNqtatdrev
	wp_retorno(9) = LNqtcasada

	SELE &LSarea	
RETURN(LNqtvenda)

FUNCTION ULdfgat
	PARAMETERS LNfilial,LScodigo
	PRIVATE LNgatilho, LSarea
	
	LSarea 		= ALIAS()
	**********************************************************
	LNgatilho 	= 0
	SELE gatilho
	SET ORDER TO TAG gatilho
	SEEK STR(LNfilial,3)+LScodigo
	IF FOUND()
		LNgatilho = gatilho.gatilho
	ENDIF
	**********************************************************
	SELE &LSarea
		
RETURN(LNgatilho)


PROCEDURE UPpedido
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [****]   MODULO INDEPENDENTE				 *
	*------------------------------------------------------------*
	* OBJETIVO....: Devolve a qtde em TRANSIO e PENDENTE de 	 *
	*		pedidos do produto    						 *
	*------------------------------------------------------------*
	* COMENTARIO..: Utilizada para abater na sugestao de compra a*
	*	    quantidade ja pedida e pendente              *
	*------------------------------------------------------------*
	* OBS : As informacoes de qtde pedida ficam inconsistentes   *
	*       quando a simulacao for feita no passado pois os itens *
	*       pedidos constaram como fechados (<> B)				 *
	*       o que fatalmente sera contraditorio com os itens que  *
	*       estavam pendentes na epoca							 *
	*------------------------------------------------------------*
	*  TABELAS....: PEDITE
	*------------------------------------------------------------*
	*  PARAMETROS..:
	*		LSclass,LScod..: Classificacao e Codigo p/ Pesquisa
	*		LNemp..........: Empresa
	*		LDdtbase.......: Data final p/ considerar qtdes
	*	    LSarquivo......: Alias da Tabela. EX. OBJ_ROL1 abre
	*				pedite na CENTRAL e na LOJA e qdo solicita
	*				pesquisa informa em qual alias
	*------------------------------------------------------------*
	*  RETORNO.....:                                             *
	*			wp_retorno(1) = QTDE PEDIDO EM TRANSITO          *
	*			wp_retorno(2) = QTDE PEDIDO AGUARD. FATURAMENTO  *
	*------------------------------------------------------------*
	PARAMETERS LSclass,LScod,LNemp,LDdtbase,LSarquivo
	
	PRIVATE LNqttrans		&& ACM. QTDE EM TRANSITO
	PRIVATE LNqtaguarda		&& ACM. QTDE PENDENTE
	PRIVATE LSarea			&& MACADOR DO ALIAS ANTERIOR P/ RETORNAR

	LNqttrans 		= 0
	LNqtaguarda 	= 0
	wp_retorno(1) 	= 0
	wp_retorno(2)	= 0
	LSarea = ALIAS()

	IF TYPE("LSarquivo") $ "UL"  && AREA NAO INFORMADA
		LSarquivo = "pedite"
	ENDIF
	SELECT  &LSarquivo
	SET ORDER TO TAG codsit
	SET NEAR ON
	SEEK STR(LNemp,3)+LScod+"B"   && REGISTROS PENDENTES DE PEDIDO
	SET NEAR OFF
	IF BOF() AND EOF()       && ITEMMOV ESTA VAZIO
		SELE &LSarea	
		RETURN(0)
	ENDIF

	DO WHILE !EOF() AND LScod 	  = &LSarquivo .codigo ;
					AND LNemp 	  = &LSarquivo .empresa;
					AND	LDdtbase >= &LSarquivo .data ;
					AND LEFT(&LSarquivo .situacao,1) = "B"
	 	LNqttrans	= LNqttrans 	+ &LSarquivo .qtdetr
	 	LNqtaguarda	= LNqtaguarda 	+ ;
 			(&LSarquivo .qtde - &LSarquivo .qtdetr - &LSarquivo .qtdeatd)
		SKIP
	ENDDO
	SELE &LSarea	
	wp_retorno(1) = LNqttrans
	wp_retorno(2) = LNqtaguarda
RETURN(LNqttrans+LNqtaguarda)

*************************************************



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3H4           RTgetValueObj VALID                
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:    3     
*        Variable:            RTgetValueObj                      
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      1                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3h4     &&  RTgetValueObj VALID
#REGION 1
return

FUNCTION RTgetValueObj
PARAMETERS PrmField,PrmPBAlias,PrmVT,PrmVD,PrmVF,PrmVC

*----------------------------------------------------------------*
*-->  PrmVT  = Vetor de dados de registro de tabela DBF
*-->  PrmVD  = Vetor de valores derivados
*-->  PrmVF  = Vetor de NOMES(TITULOS) de campos (Acelera pesquisa do campo)
*-->  PrmVC  = Vetor de Configuracoes e Parametros
*----------------------------------------------------------------*

PRIVATE LNidxIn,LNidxMax, Lvalue

	PRIVATE LSalias
	LSalias		= 	ALIAS()

    PrmField = UPPER(PrmField)


    LNidxIni = 1
	LNidxMax = 0

	IF !(TYPE("PrmVC") $ "L/U")
	    PRIVATE DIMENSION PrmVC[1,3] && EVITA ERRO DE CHAMDAS AINDA NAO
	    							 && COMPATIVEIS EM PARAMETROS
	ENDIF


	DO CASE
		CASE !(TYPE("PrmVF") $ "L/U")

			LNidxIni = ASCAN(PrmVF,PrmField)
			IF LNidxIni > 0 	
				LNidxIni = ASUBSCRIPT(PrmVF,ASCAN(PrmVF,PrmField),1)
			ENDIF

		OTHERWISE
	    	IF USED(PrmPBAlias)
 			   SELE &PrmPBAlias
			   LNidxMax = fcount()
				   DO WHILE LNidxIni =< LNidxMax
    		     IF PrmField = UPPER(FIELD(LNidxIni))
	        	    EXIT
	    	     ENDIF
    		     LNidxIni = LNidxIni + 1
			   ENDDO
			   IF LNidxIni > LNidxMax
					LNidxIni = 0
			   ENDIF
			ELSE
				LNidxIni = 0
    		ENDIF
		
	
	ENDCASE


	Lvalue = .T.
	IF LNidxIni > 0
		Lvalue = PrmVT(LNidxIni)
	ELSE
		*--------------   BUSCA NO VETOR DERIVADO -----------------*
		LNidxIni = ASCAN(PrmVD,PrmField)
        IF LNidxIni > 0
			LNidxIni = ASUBSCRIPT(PrmVD,ASCAN(PrmVD,PrmField),1)
			IF PrmVD(LNidxIni,3) = .T.
				Lvalue = PrmVD(LNidxIni,2)
			ELSE
			    Lvalue = .f.
			ENDIF
		ELSE
			*--------------   BUSCA NO VETOR CONFIGURACAO----------*
			LNidxIni = ASCAN(PrmVC,PrmField)
    	    IF LNidxIni > 0
				LNidxIni = ASUBSCRIPT(PrmVC,ASCAN(PrmVC,PrmField),1)
				IF PrmVC(LNidxIni,3) = .T.
					Lvalue = PrmVC(LNidxIni,2)
				ELSE
				    Lvalue = .f.
				ENDIF
			ELSE
			    Lvalue = .f.
			ENDIF
		ENDIF
	ENDIF


	IF !EMPTY(LSalias) AND USED(LSalias)
		SELECT &LSalias
	ENDIF
RETURN(Lvalue)





*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3HE           RTsetValueObj VALID                
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:    4     
*        Variable:            RTsetValueObj                      
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      2                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3he     &&  RTsetValueObj VALID
#REGION 1
return
*---------------------------------------------------------------*


FUNCTION RTsetValueObj
PARAMETERS PrmField, PrmValue, PrmPBAlias, PrmVT, PrmVD, PrmVF,PrmVC





	PRIVATE LNidxIni,LNidxMax
	PRIVATE LFreturn

	PRIVATE LSalias
	LSalias		= 	ALIAS()



    PrmField = UPPER(PrmField)


    LNidxIni = 1
	LNidxMax = 0


	IF !(TYPE("PrmVC") $ "L/U")
	    PRIVATE DIMENSION PrmVC[1,3] && EVITA ERRO DE CHAMDAS AINDA NAO
	    							 && COMPATIVEIS EM PARAMETROS
	ENDIF


	DO CASE
		CASE !(TYPE("PrmVF") $ "L/U")

			LNidxIni = ASCAN(PrmVF,PrmField)
			IF LNidxIni > 0 	
				LNidxIni = ASUBSCRIPT(PrmVF,ASCAN(PrmVF,PrmField),1)
			ENDIF

		OTHERWISE
	    	IF USED(PrmPBAlias)
 			   SELE &PrmPBAlias
			   LNidxMax = fcount()
				   DO WHILE LNidxIni =< LNidxMax
    		     IF PrmField = UPPER(FIELD(LNidxIni))
	        	    EXIT
	    	     ENDIF
    		     LNidxIni = LNidxIni + 1
			   ENDDO
			   IF LNidxIni > LNidxMax
					LNidxIni = 0
			   ENDIF
			ELSE
				LNidxIni = 0
    		ENDIF
	
	ENDCASE


	LFreturn = .T.
	IF LNidxIni > 0
		PrmVT(LNidxIni) = PrmValue
	ELSE
		*--------------   BUSCA NO VETOR DERIVADO -----------------*
		LNidxIni = ASCAN(PrmVD,PrmField)
        IF LNidxIni > 0
			LNidxIni = ASUBSCRIPT(PrmVD,ASCAN(PrmVD,PrmField),1)
			PrmVD(LNidxIni,2) = PrmValue
			PrmVD(LNidxIni,3) = .T.
		ELSE
			*--------------   BUSCA NO VETOR CONFIGURACAO----------*
			LNidxIni = ASCAN(PrmVC,PrmField)
        	IF LNidxIni > 0
				LNidxIni = ASUBSCRIPT(PrmVC,ASCAN(PrmVC,PrmField),1)
				PrmVC(LNidxIni,2) = PrmValue
				PrmVC(LNidxIni,3) = .T.
			ELSE
			    LFreturn = .f.
			ENDIF
		ENDIF
	ENDIF

	*--------------------------------------------------------------*
	IF !EMPTY(LSalias) AND USED(LSalias)
		SELECT &LSalias
	ENDIF
RETURN(LFreturn)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3HL           RTAcesso VALID                     
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:    5     
*        Variable:            RTAcesso                           
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      3                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3hl     &&  RTAcesso VALID
#REGION 1
return
*---------------------------------------------------------------*


FUNCTION RTacesso
PARAMETERS PrmPrograma,PrmDescricao,PrmObjeto
	=W_DEFPROC("ACESSO.SPR")
	=ACdef_aces(PrmPrograma,PrmDescricao,PrmObjeto)
RETURN(.t.)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3HR           GrvLog VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:    6     
*        Variable:            GrvLog                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      4                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3hr     &&  GrvLog VALID
#REGION 1
RETU
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [*****]
	*------------------------------------------------------------*
	* OBJETIVO.....: Gravar em Arq. TMP a data e hora de uma deter.
	* minada ocorrencia
	*------------------------------------------------------------*
	* COMENTARIO...:
	*------------------------------------------------------------*
	* OBS..........:
	*------------------------------------------------------------*
	*  TABELAS.....:
	*------------------------------------------------------------*
	*  PARAMETROS..:	LSarqocorr  = arquivo de log ocorrencia
	* 					LSusuario   = nome do usuario
	*					LScodocorr  = codigo da ocorrencia
	* 					LSdescocorr = descricao da ocorrencia
	*------------------------------------------------------------*
	*  RETORNO....:
	*------------------------------------------------------------*
	* EXEMPLO.....: 	=GrvLog(LSarqocorr,LSusuario,LScodocorr,LSdescocorr)
	*------------------------------------------------------------*

	*------------------------------------------------------------*
	FUNCTION GrvLog
	PARAM LSarqocorr,LSusuario,LScodocorr,LSdescocorr

    PRIVATE LSarqocorr,LSusuario,LStmplib,LScodocorr,LSdescocorr

	PRIVATE LSfile					&& NOME DO ARQ DE LOG
	PRIVATE LNctrl					&& NUMERO DO ARQ. DADO PELO
									&& S.Operacional
	LSfile     = LSarqocorr
	IF FILE('&LSfile')				&& se o arq.log existir
		LNctrl     = FOPEN(LSfile,2)
		IF LNctrl  = -1
			WAIT "Problemas c/ a arbertura do Arq. de Log.!"
	        =FCLOSE(LNctrl)
			RETU
		ENDIF
	ELSE
		LNctrl = FCREATE(LSfile,0)
	ENDI
    IF LEN(ALLT(LSusuario)) < 15
       LSusuario = ALLT(LSusuario) + SPAC(15-LEN(ALLT(LSusuario)))
      ELSE
       LSusuario = SUBS(ALLT(LSusuario),1,15)
    ENDI
    IF LEN(ALLT(LSdescocorr)) < 45
	   LSdescocorr = ALLT(LSdescocorr) + SPAC(35-LEN(ALLT(LSdescocorr)))
	 ELSE
	   LSdescocorr = SUBS(ALLT(LSdescocorr),1,45)
    ENDI
	IF LNctrl  <> -1
		LStmplib = FSEEK(LNctrl,0,2)
		LStmplib = FWRITE(LNctrl,chr(13)+DTOC(DATE())+"-"+TIME()+;
			  "-"+LSusuario+"-"+ALLT(LScodocorr)+"-"+ALLT(LSdescocorr))
	ENDIF
   =FCLOSE(LNctrl)
RETURN(.t.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3HZ           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:    7     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      5                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3hz     &&  padrao VALID
#REGION 1
RETURN

FUNCTION UPerrosys
PARAMETERS PrmMsgErro


	PRIVATE LmsgErro
	
	nErro = Error()
	LNusr_ret = 0


	IF TYPE("PrmMsgErro") $ "U/L"
		PrmMsgErro = ""
	ENDIF
	
	IF EMPTY(PrmMsgErro)
	   LmsgErro = "Erro Imprevisto No : " +STR(nErro,5) +CHR(13)+;
				   MESSAGE()+CHR(13)+CHR(13)+;
				   "   <ENTER>  "
	ELSE
	   LmsgErro = PrmMsgErro
	
	ENDIF

    DO OBJ_ALER.SPR WITH LmsgErro
		

	LSmsg  = "Ativar PASSO ? "
	IF fox_alert(LSmsg)
			wp_msg = 'Manutencao de Sistema...'
			BTMP   =  'usuario.master '
			LNusr_ret = 0
			DO obj_prmt.SPR WITH   wp_msg , Btmp
			IF LNusr_ret <>  0
				SET SYSMENU ON
				PUSH MENU _MSYSMENU
				SET SYSMENU TO _MPROG, _MPR_CANCL,_MPR_RESUM , ;
				               _MWINDOW, _MWI_ZOOM,_MWI_MOVE, _MEDIT, _MED_FIND, ;
						_MED_FINDA, _MWI_DEBUG, _MWI_TRACE, _MWI_CMD
				SET TRBETWEEN ON

				SET SKIP OF POPUP _MPR_CANCL .T.
				SET SKIP OF POPUP _MPR_RESUM .T.

				SET STEP ON
			ELSE
				close all
				quit
			ENDIF
	ELSE
		if nUsr = 1	   && Usuario de Manutencao (SISTEMA)
		   clear all
		   set sysmenu to default
		   =upapaga()
     	   return to master
		else
			close all
			quit
  		endif
	ENDIF
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3I6           LeLog VALID                        
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:    8     
*        Variable:            LeLog                              
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      6                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3i6     &&  LeLog VALID
#REGION 1
RETU
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [*****]
	*------------------------------------------------------------*
	* OBJETIVO.....: LER em Arq. LOG
	*------------------------------------------------------------*
	* COMENTARIO...:
	*------------------------------------------------------------*
	* OBS........ .:
	*------------------------------------------------------------*
	*  TABELAS.....:
	*------------------------------------------------------------*
	*  PARAMETROS..:	LSarqocorr  = nome do arq de log
	*					LSusuario   = nome do usuario
	*					LSpdia      = informe o dia
	*					LSpmes      = informe o mes
	*					LSpano      = informe o ano c/ 4 digitos
	*					LSpocorr    = codigo da ocorrencia
	*------------------------------------------------------------*
	*  RETORNO.....: .T. se encontrar a ocorrencia
	*                .F. se nao encontror a ocorrencia
	*------------------------------------------------------------*
	* EXEMPLO .....: =LeLog(LSarqocorr,LSusuario,LSocorr,LSpdata,LSpocorr)
	*------------------------------------------------------------*
	*------------------------------------------------------------*

	FUNCTION LeLog
	PARAM LSarqocorr,LSusuario,LSpdia,LSpmes,LSpano,LSpcodocorr

	PRIVATE LSfile			&& NOME DO ARQ. LOG
	PRIVATE LNctrl			&& NUMERO DO ARQ. DADO PELO S.Operacional
	PRIVATE LStmpmsg	
	PRIVATE LNnro_orc
	*------------------------------------------------------------*
	LNnro_orc	= 0

	LSfile = LSarqocorr
	LNctrl = FOPEN(LSfile,2)
	IF LNctrl = -1
	   WAIT WIND "Problema da Abertura do Arquivo !"
	   =FCLOSE(LNctrl)
	ENDIF
	LNfimarq = FSEEK(LNctrl,0,2)       && fim do arquivo de log
	LNiniarq = FSEEK(LNctrl,1,0)       && inicio do arquivo de log
	LNposarq = FSEEK(LNctrl,0,1) 	   && posicao atual no do ponteiro
    LFachou  = .f.
*1		
	DO WHILE LNposarq < LNfimarq
		LStmplib   = FGETS(LNctrl)
		LSdata     = CTOD(SUBS(LStmplib,1,10))
		LSdia	   = STR(DAY(LSdata),2)
		LSmes	   = STR(MONTH(LSdata),2)
		LSano      = STR(YEAR(LSdata),4)
		LScodocorr = SUBS(ALLT(LStmplib),37,2)
		IF LSpdia  = "00"
		    IF LSmes=LSpmes AND LSano=LSpano AND LSpcodocorr=LScodocorr
               LFachou = .t.
	           exit
	        ENDI
 		 ELSE
		    IF LSdia=LSpdia AND LSmes=LSpmes ;
		    				AND LSano=LSpano AND LSpcodocorr=LScodocorr
               LFachou = .t.
	           exit
	        ENDI
        ENDI
		LNposarq = FSEEK(LNctrl,0,1)
	ENDD
*1
	=FCLOSE(LNctrl)
RETURN(LFachou)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3JW           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:    9     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      7                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3jw     &&  padrao VALID
#REGION 1
RETURN
***********************************************************************
** UPPROTEGE =>
**		Ativado com CTRL-F8 ou atraves de TIMEOUT em telas chaves do
** 	  	sistema a exemplo de SCGC201, SCGC201A
************************************************************************

PROCEDURE UPprotege		&& PROTECAO DE TELA
	CLEAR TYPEAHEAD
	PRIVATE wl_arqtmp	&& EVITA QUE A ROTINA UPnometmp AFETE
						&& ESTA VARIVAEL EM ALGUM PROGRAMA ATIVO
	
	IF wp_verlibera  && NAO PODE SAIR DO AR COM EXPLOSIVE
										   && TEM QUE FICAR VEIFICANDO	
		HIDE WINDOW ALL
		
		DO WHILE !CHRSAW(10)
			*-----------------------------------------------------*
			=W_DEFPROC("ORCAMENT.SPR")
			IF ORleravisolib() > 0 	&& AVISAR PARA LIBERAR orcamento
				EXIT
			ENDIF
			*-----------------------------------------------------*
	    ENDDO
		SHOW  WINDOW ALL
	ELSE
		TMP = UPnometmp("FGS",2)
		!protege.bat
		***  > &TMP
	ENDIF
	=upapaga()
	CLEAR TYPEAHEAD
RETURN



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3JX           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   10     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      8                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3jx     &&  padrao VALID
#REGION 1
RETURN


FUNCTION UPapaga
	ACTIVATE SCREEN
	LSapg= SCHEME(22)
	SET COLOR TO &LSapg
	@ 0,0,24,79 BOX REPLICATE("",20)
	SET COLOR TO


	PRIVATE LSdir

	IF TYPE("wp_dirdat")<> "C"
		LSdir= SYS(5)
	ELSE
		LSdir= SYS(5)+wp_dirdat
	ENDIF

	IF TYPE("wp_empresa") = "U"
		RETURN
	ENDIF


@ 00,0 SAY "                                                                                " ;
	SIZE 1,80, 0 ;
	COLOR SCHEME 19

	@ 00,0 SAY "Loja:" ;
		SIZE 1,12, 0;
		COLOR SCHEME 19

	@ 00,5 SAY wp_empresa ;
		SIZE 1,3 ;
		PICTURE "999";
		COLOR SCHEME 19
	@ 00,13 SAY wp_dtoper ;
		SIZE 1,10;
		COLOR SCHEME 19

	IF TYPE("wp_dirdat")= "C" AND ("LOJA" $ UPPER(wp_dirdat))
		@ 00,24 SAY LSdir ;
			SIZE 1,25;
			COLOR SCHEME 19
	ELSE
		@ 00,24 SAY LSdir ;
			SIZE 1,25;
			COLOR SCHEME 12
	ENDIF


	@ 00,50 SAY "Usr:" ;
		SIZE 1,4, 0;
		COLOR SCHEME 19
	@ 00,54 SAY nUsr ;
		SIZE 1,4 ;
		PICTURE "9999";
		COLOR SCHEME 19
	@ 00,59 SAY wp_nmusr ;
		SIZE 1,9;
		COLOR SCHEME 19
	

****************************************

@ 24,0 SAY "                                                                                " ;
	SIZE 1,80, 0 ;
	COLOR SCHEME 22
	@ 24,0 SAY "Loja: " ;
		SIZE 1,12, 0

	@ 24,5 SAY wp_empresa ;
			SIZE 1,3 ;
			PICTURE "999"
	@ 24,13 SAY wp_dtoper ;
		SIZE 1,10
	IF TYPE("wp_dirdat")= "C" AND  ("LOJA" $ UPPER(wp_dirdat))
		@ 24,24 SAY LSdir ;
			SIZE 1,25
	ELSE
		@ 24,24 SAY LSdir ;
			SIZE 1,25;
			COLOR SCHEME 12
	ENDIF
	@ 24,50 SAY "Usr:" ;
		SIZE 1,4, 0
	@ 24,54 SAY nUsr ;
		SIZE 1,4 ;
		PICTURE "9999"
	@ 24,59 SAY wp_nmusr ;
		SIZE 1,9
	@ 24,69 SAY TIME()

RETURN("")



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3JY           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   11     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      9                                  
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3jy     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION UPValData	&& VALIDA DATA EM RELACAO AO ANO 2000

PARAMETERS LDdtVer
	PRIVATE LDdtval
	DO CASE
		CASE EMPTY(LDdtVer)
			LDdtVal	=	LDdtVer			
		CASE LDdtVer < {01.01.70}	&& ESTA NO ANO < 1970 => PASSAR P/ 2000
			LDdtVal	=	GOMONTH(LDdtVer,1200)
		OTHERWISE
			LDdtVal	=	LDdtVer			
	ENDCASE
RETURN(LDdtval)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3JZ           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   12     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      10                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3jz     &&  PADRAO VALID
#REGION 1
RETURN

PROCEDURE BTN_VAL

	PARAMETER m.btnname, m.chv_ler, m.chv_compara, m.key_brow, m.FLg_loc, m.FLg_leitor

************************
  ON KEY LABEL CTRL-F8 DO UPprotege   && ATIVAR EM TODOS PROGRAMAS
************************

	IF TYPE("FLg_loc") = "U"    && USADO EM "LOCATE"
		FLg_loc = .T.			&& .T. => Nao permitir escolha do indice
	ENDIF
	IF TYPE("FLg_leitor") = "U"	&& USADO EM "LACATE"
		FLg_leitor = .f.   		&& .F. => Nao atival auxiliar de busca automaticamente
								&& com KEYBOARD "L"
	ENDIF

** <<<<   TESTE DE TEMPO PARA LIBERACAO DE RESERVAS   >>>> **

	IF m.btnname $ 'TOP/PREV/NEXT/END/BUSCA'
		*------------------------------------------------------------*
		=W_DEFPROC("AUTOPROC.SPR")
		=APTempGeral()
		*------------------------------------------------------------*
	endif	

** <<<<   TESTE P/ VERIFICAR EXISTENCI DE ORC P/LIBERAR >>>> **

	
	IF wp_verlibera
			LStmp = wp_dirdat+"CTRLLIBE.TXT"
			wp_numcontrole = FOPEN(LStmp,2)
			IF wp_numcontrole = -1
				wp_numcontrole = FCREATE(LStmp,0)
			ENDIF
			IF wp_numcontrole <> -1
				LStmplib = FSEEK(wp_numcontrole,0,0)
				LStmplib = FGETS(wp_numcontrole,6)
				IF LStmplib <> "999999"
					wp_msg = "Orcamento Aguadando Liberacao ......"+LStmplib
					LStmplib = FSEEK(wp_numcontrole,0,0)
					LStmplib = FWRITE(wp_numcontrole,"999999")
					=FCLOSE(wp_numcontrole)
					=UPbeeps(.T.,wp_msg,2,600)
				ENDIF
			ENDIF
			=FCLOSE(wp_numcontrole)
	ENDIF

******************************************************************
	DO CASE
	   CASE EMPTY(m.chv_ler) AND EMPTY(m.chv_compara)
	        DO CASE
	    		CASE  m.btnname='TOP'
					GO TOP
					WAIT WINDOW C_TOPFILE NOWAIT
				CASE  m.btnname='PREV'
					IF !BOF()
						SKIP -1
				 	ENDIF
				 	IF BOF()
						WAIT WINDOW C_TOPFILE NOWAIT
						GO TOP
					ENDIF
				CASE  m.btnname='NEXT'
					IF !EOF()
						SKIP 1
					ENDIF
					IF EOF()
						WAIT WINDOW C_ENDFILE NOWAIT
						GO BOTTOM
					ENDIF
				CASE  m.btnname='END'
					GO BOTTOM
					WAIT WINDOW C_ENDFILE NOWAIT
				CASE  m.btnname='LOCATE'
				    ON KEY LABEL ESCAPE
					ON KEY LABEL END
					WP_RECORD = RECNO()
					DO loc_dlog WITH  m.FLg_loc,.F.,.F.,.F.,.F.,m.FLg_leitor
					IF EOF()
					   =vai_para()      && posiciona WP_RECORD
			        ENDIF
				CASE  m.btnname='ADD'  AND !isediting &&add record
					SET POINT TO
					SET SEPARATOR  TO
					isediting=.T.
					isadding=.T.
					WP_RECORD = RECNO()
					=edithand('ADD')
					_curobj=1
				    ON KEY LABEL ESCAPE KEYBOARD "{BACKTAB}"
					ON KEY LABEL END DO BTN_VAL1 WITH 'DELETE'
				CASE  m.btnname='COPY'  AND !isediting &&add record
					SET POINT TO
					SET SEPARATOR  TO
					isediting=.T.
					isadding=.T.
					WP_RECORD = RECNO()
					_curobj=1
				    ON KEY LABEL ESCAPE KEYBOARD "{BACKTAB}"
					ON KEY LABEL END DO BTN_VAL1 WITH 'DELETE'
				CASE  m.btnname='EDIT'  AND !isediting  &&edit record
					IF EOF() OR BOF()
						WAIT WINDOW C_ENDFILE NOWAIT
						RETURN
					ENDIF
					WP_RECORD = RECNO()
					IF !REGLOCK()
						WAIT WINDOW C_NOLOCK NOWAIT
					ELSE
						SET POINT TO
						SET SEPARATOR  TO
						isediting=.T.
						_curobj=1
					    ON KEY LABEL ESCAPE KEYBOARD "{BACKTAB}"
						ON KEY LABEL END DO BTN_VAL1 WITH 'DELETE'
					ENDIF	
				CASE m.btnname='EDIT'  AND isediting  &&save record
					IF isadding
						=edithand('SAVE')
					ELSE
						=edithand('REGRAVA')
					ENDIF
  				    UNLOCK
  				
               *--------------------------------------------------
               *  FUNCAO P/ TRATAMENTO INTEGRACAO DE DADOS COM ORION
               *--------------------------------------------------
					IF isadding
						=GRLAlterarOrion('SAVE')
					ELSE
						=GRLAlterarOrion('REGRAVA')
					ENDIF
               *--------------------------------------------------
  				
  				
					_curobj=1
					isediting=.F.
					isadding=.F.
					SET POINT TO ","
					SET SEPARATOR  TO "."
				    ON KEY LABEL ESCAPE
					ON KEY LABEL END
				CASE  m.btnname='BUSCA' and !isreading
									 &&lbusca direta do registro
					WP_RECORD = RECNO()
					isreading=.T.
					_curobj=1
				    ON KEY LABEL ESCAPE KEYBOARD "{BACKTAB}"
				    ON KEY LABEL END DO BTN_VAL1 WITH 'BUSCA'
				CASE  m.btnname='BUSCA' and isreading
									 && FINAL lbusca direta do registro
					CLEAR TYPEAHEAD
					IF FOUND()
						WP_RECORD = RECNO()
					ELSE
					   =vai_para()      && posiciona WP_RECORD
					ENDIF
					isreading=.f.
					_curobj=1
				    ON KEY LABEL ESCAPE
			        ON KEY LABEL END
				   	SCATTER MEMVAR MEMO
				CASE m.btnname='DELETE'  AND isediting 	&&cancel record
					IF isadding
						=edithand('CANCEL')
					ENDIF
					isediting=.F.
					isadding=.F.
					UNLOCK
					WAIT WINDOW C_ECANCEL NOWAIT
					SET POINT TO ","
					SET SEPARATOR  TO "."
				    ON KEY LABEL ESCAPE
					ON KEY LABEL END
					_curobj=1
				CASE m.btnname='DELETE'
					IF EOF() OR BOF()
						WAIT WINDOW C_ENDFILE NOWAIT
					ELSE
						IF !REGLOCK()
							WAIT WINDOW C_NOLOCK NOWAIT
						ELSE
							IF fox_alert(C_DELREC)


                                =GRLAlterarOrion('APAGA')

								=edithand('APAGA')



								IF !EOF() AND DELETED()
									SKIP 1
								ENDIF
								IF EOF()
									WAIT WINDOW C_ENDFILE NOWAIT
									GO BOTTOM
								ENDIF
							ENDIF
							_curobj=1
					    ENDIF
					ENDIF
				CASE m.btnname='PRINT'
					IF TYPE("titulo") = "U"
						m.titulo = " "
				    ENDIF
					DO OBJ_TITU.SPR
					IF EMPTY(wp_rel)
						A= " "
						B= " "
						C= " "
						D= " "
						MA= " "
						MB= " "
						MC= " "
						MD= " "
						DO OBJ_REG.SPR
					    LSrel = "REL000"
					ELSE
					    LSrel = wp_rel
						wp_rel = ""		&& evitar erro pela manute. do vlr
					ENDIF
 			
*******************
*---->   (INICIALIZACAO DO CONTROLE DE STATUS IMPRESSAO)
*******************	
*******************	
					DO RELINIC.PRG          && INICIA VAR P/ TERMOMETRO
					
					LFsegue = .t.
					LNregistro = RECNO()
					LNimpressao = RECCOUNT()
					LNimpressos = 0
					GO LNregistro
					wp_msg = "Impressao de Relatorio Padrao - "+alias()
*******************
*---->   (COMPLETADO PREPARACAO DO CONTROLE DE STATUS IMPRESSAO)
*******************	
**************************>>> REGISTRO DE SAIDAS
					LSorienta = "WHILE LFsegue "
***********
					DO UPimpressao    && COORDENA TRABALHO DE IMPRESSAO
***********
					DO RELFIM.PRG          && FIM VAR P/ TERMOMETRO
*-----------------------------
				    SET PRINTER TO SET('PRINTER',1)
					SET RELATION TO
					SET POINT TO
					SET SEPARATOR  TO
					wp_msg = " "
					RETURN

				CASE m.btnname='EXIT'
					m.bailout=.T.	&&this is needed if used with FoxApp
					CLEAR READ
					RETURN
            ENDCASE
			IF  !(m.btnname $ 'ADD/BUSCA/')
			   	SCATTER MEMVAR MEMO
			ENDIF
			DO refresh WITH .F.

	   OTHERWISE

*EXEMPLO
*=BTN_VAL('TOP',STR(wp_empresa,3),'cotacao.empresa <> wp_empresa')
*=BTN_VAL('PREV',STR(wp_empresa,3),'cotacao.empresa <> wp_empresa')
*=BTN_VAL('NEXT',STR(wp_empresa,3),'cotacao.empresa <> wp_empresa')
*=BTN_VAL('END',STR(wp_empresa+1,3),'cotacao.empresa <> wp_empresa')
*=BTN_VAL('LOCATE',"SEM EFEITO ",'cotacao.empresa = wp_empresa')


	        DO CASE
	    		CASE  m.btnname='TOP'
                    GO TOP
                    SET NEAR ON
                    SEEK &chv_ler
                    SET NEAR OFF
					WAIT WINDOW C_TOPFILE NOWAIT
                    wl_logico = &chv_compara
				CASE  m.btnname='PREV'
					IF !BOF()
						SKIP -1
				 	ENDIF
                    wl_logico = &chv_compara
				 	IF BOF()
				 		GO TOP
						WAIT WINDOW C_TOPFILE NOWAIT
					ELSE
					 	IF !WL_LOGICO
							SKIP
		                    wl_logico = &chv_compara
						ENDIF
					ENDIF
				CASE  m.btnname='NEXT'
					IF !EOF()
						SKIP 1
					ENDIF
                    wl_logico = &chv_compara
				 	IF EOF() OR !WL_LOGICO
	                    wl_logico = &chv_compara
						WAIT WINDOW C_ENDFILE NOWAIT
						SKIP -1
			        ENDIF
				CASE  m.btnname='END'
                    GO TOP
                    SET NEAR ON
                    SEEK &chv_ler
                    SET NEAR OFF
                    SKIP -1
					WAIT WINDOW C_ENDFILE NOWAIT
				CASE  m.btnname='LOCATE'
					WP_RECORD = RECNO()
					DO loc_dlog WITH FLg_loc, m.chv_compara, m.key_brow,.F.,.F., m.FLg_leitor
                    wl_logico = &chv_compara
				 	IF EOF() OR !WL_LOGICO
					   =vai_para()      && posiciona WP_RECORD
			        ENDIF
				CASE m.btnname='DELETE'  AND isediting 	&&cancel record
					IF isadding
						=edithand('CANCEL')
					ENDIF
					isediting=.F.
					isadding=.F.
					UNLOCK
					WAIT WINDOW C_ECANCEL NOWAIT
					SET POINT TO ","
					SET SEPARATOR  TO "."
				    ON KEY LABEL ESCAPE
					ON KEY LABEL END
					_curobj=1
				CASE m.btnname='DELETE'
					IF EOF() OR BOF()
						WAIT WINDOW C_ENDFILE NOWAIT
					ELSE
						IF !REGLOCK()
							WAIT WINDOW C_NOLOCK NOWAIT
						ELSE
							IF fox_alert(C_DELREC)



						        =GRLAlterarOrion('APAGA')
               *--------------------------------------------------
								=edithand('APAGA')



								IF !EOF() AND DELETED()
									SKIP 1
								ENDIF
                    		    wl_logico = &chv_compara
  	  				 			IF EOF() OR !WL_LOGICO
									WAIT WINDOW C_ENDFILE NOWAIT
									SKIP -1
								ENDIF
							ENDIF
						ENDIF
						_curobj=1
					ENDIF
            ENDCASE
			IF  !(m.btnname $ 'ADD/BUSCA/')
			   	SCATTER MEMVAR MEMO
			ENDIF
            wl_logico = (&chv_compara)
			DO refresh WITH !wl_logico  && indis se arq nao esta vazio
	ENDCASE


RETURN(.T.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3K0           UPCripto_1 VALID                   
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   13     
*        Variable:            UPCripto_1                         
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      11                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3k0     &&  UPCripto_1 VALID
#REGION 1
RETURN

*--------------------------------------------------------------------*
* objetivo : criptografa senha                                       *
*--------------------------------------------------------------------*
function Cripto
   parameters crpt
   pw = crpt
   x = 1
   restore from gencompy additive
   do while x <= 8
      ctrs = str(x,1)
      pw&ctrs = &comp_a
      x = x + 1
   enddo
   p_crip = pw1+pw2+pw3+pw4+pw5+pw6+pw7+pw8
return ( p_crip )


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3K1           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   14     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      12                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3k1     &&  padrao VALID
#REGION 1
RETURN

PROCEDURE REFRESH
  PARAMETERS m.arq_vazio
*****>>>>>>>>>>>  abilita os acessos permitidos
	LNindice = 0
	LSaces = "   "
	IF !lMaster
		LNindice = ASCAN(vAcessos,WPprgativo)
		IF LNindice > 0
				LNindice = ASUBSCRIPT(VACESSOS,LNindice,1)
				LSaces = vAcessos(LNindice,2)
		ENDIF
	ENDIF
******	
  SHOW GETS ENABLE

  DO CASE

  CASE m.isreadonly AND RECCOUNT()=0
	SHOW GETS DISABLE
	SHOW GET exit_btn ENABLE
  CASE m.isreadonly
	SHOW GET add_btn DISABLE
	SHOW GET del_btn DISABLE
	SHOW GET edit_btn DISABLE

  CASE (RECCOUNT()=0 OR EOF() OR m.arq_vazio) AND !m.isediting
	SHOW GET busca_btn DISABLE
	SHOW GET top_btn DISABLE
	SHOW GET prev_btn DISABLE
	SHOW GET loc_btn DISABLE
	SHOW GET next_btn DISABLE
	SHOW GET end_btn DISABLE
	SHOW GET prnt_btn DISABLE
	SHOW GET edit_btn DISABLE
	SHOW GET del_btn  DISABLE
	SHOW GET add_btn ENABLE
	SHOW GET cop_btn DISABLE
	SHOW GET exit_btn ENABLE
	SHOW GET imp_btn DISABLE
	SCATTER MEMVAR MEMO BLANK
  CASE m.isediting
	SHOW GET busca_btn DISABLE
	SHOW GET top_btn DISABLE
	SHOW GET prev_btn DISABLE
	SHOW GET loc_btn DISABLE
	SHOW GET next_btn DISABLE
	SHOW GET end_btn DISABLE
	SHOW GET add_btn DISABLE
	SHOW GET cop_btn DISABLE
	SHOW GET prnt_btn DISABLE
	SHOW GET exit_btn DISABLE
	SHOW GET imp_btn DISABLE
	SHOW GET edit_btn,1 PROMPT "\<Grava"
	SHOW GET del_btn,1 PROMPT "\<Cancela"
    IF wp_ref_local
       DO local_refresh WITH m.arq_vazio
    ENDIF
	RETURN
  CASE m.isreading
    SHOW GET busca_btn DISABLE
	SHOW GET top_btn   DISABLE
	SHOW GET prev_btn  DISABLE
	SHOW GET loc_btn   DISABLE
	SHOW GET next_btn  DISABLE
	SHOW GET end_btn   DISABLE
	SHOW GET add_btn   DISABLE
	SHOW GET cop_btn DISABLE
	SHOW GET prnt_btn  DISABLE
	SHOW GET exit_btn  DISABLE
	SHOW GET edit_btn  DISABLE
	SHOW GET del_btn   DISABLE
	SHOW GET imp_btn 	DISABLE
	SCATTER MEMVAR MEMO BLANK
    IF wp_ref_local
       DO local_refresh WITH m.arq_vazio
    ENDIF
	RETURN
  OTHERWISE
	SHOW GET edit_btn,1 PROMPT "\<Edita"
	SHOW GET del_btn,1 PROMPT "\<Deleta"
	SHOW GETS ENABLE
	IF "B" $ LSaces			&& opcoes de busca
	    SHOW GET busca_btn DISABLE
	ENDIF
	IF "I" $ LSaces 		&& opcaoes de navegacao
	    SHOW GET busca_btn DISABLE
		SHOW GET top_btn   DISABLE
		SHOW GET prev_btn  DISABLE
		SHOW GET next_btn  DISABLE
		SHOW GET end_btn   DISABLE
	ENDIF
	IF "Z" $ LSaces			&& opcoes de paginacao
		SHOW GET loc_btn   DISABLE
	ENDIF
	IF "L" $ LSaces			&& opcoes de inclusao
		SHOW GET add_btn   DISABLE
		SHOW GET cop_btn DISABLE
	ENDIF
	IF "E" $ LSaces			&& opcoes de alteracao (Edicao)
		SHOW GET edit_btn  DISABLE
	ENDIF
	IF "D" $ LSaces			&& opcoes P/ exclusao
		SHOW GET del_btn   DISABLE
	ENDIF
	IF "M" $ LSaces			&& opcoes P/ exclusao
		SHOW GET imp_btn   DISABLE
	ENDIF
	IF "C" $ LSaces			&& opcoes P/ copia
		SHOW GET cop_btn   DISABLE
	ENDIF
  ENDCASE
  IF m.is2table
  	SHOW GET add_btn DISABLE
  ENDIF
  ON KEY LABEL ESCAPE
  IF wp_ref_local
       DO local_refresh WITH m.arq_vazio
  ENDIF

  ****    O TIMEOUT NAO ERA REATIVADO SEM UM MOVIMENTO ENTRE
  **** OS CAMPOS. FORAM COLOCADOS SETA P/ DIREITA E ESQUERDA
  **** BURLANDO O BUG

  KEYBOARD CHR(4)
  KEYBOARD CHR(19)

RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3K2           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   15     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      13                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3k2     &&  padrao VALID
#REGION 1
RETURN
PROCEDURE foxalert2		&& versao com <Sim> <Nao> <Cancela> mai nova
    PARAMETER  wzalrtmess, LFopcao
	PUSH KEY CLEAR		&& desabilita teclas de atalho def. anteriormente
	ON KEY LABEL F1		DO HLP2000.SPR WITH  POPUP(),PROMPT(),PROGRAM(),;
							WONTOP(),VARREAD()
    PRIVATE alrtbtn
    m.alrtbtn=2
	DEFINE WINDOW obj_aler ;
		FROM INT((SROW()-10)/2),INT((SCOL()-50)/2) ;
		TO INT((SROW()-10)/2)+9,INT((SCOL()-50)/2)+49 ;
		FOOTER "[OBJ_ALER]" ;
		FLOAT ;
		NOCLOSE ;
		SHADOW ;
		NOMINIMIZE ;
		DOUBLE ;
		COLOR SCHEME 5

	MOVE WINDOW obj_aler CENTER
	ACTIVATE WINDOW obj_aler NOSHOW

	@ 1,2 SAY wzalrtmess;
		SIZE 4,44 ;
		PICTURE "@I";
        FONT "MS Sans Serif", 10 STYLE "B"
	@ 6,11 GET m.alrtbtn ;
	  PICTURE "@*HT \?\!\<Cancela;\?\!\<Nao;\?\!\<Sim" ;
	  SIZE 1.769,8.667,1.333 ;
	  FONT "MS Sans Serif", 8 STYLE "B"

	ACTIVATE WINDOW obj_aler
	SHOW WINDOW OBJ_ALER TOP
	READ CYCLE MODAL WITH obj_aler
	RELEASE WINDOW obj_aler
    POP KEY
	DO CASE
		CASE m.alrtbtn = 2
			RETURN("N")			&& Nao
		CASE m.alrtbtn = 3
			RETURN("S")			&& Sim
		CASE m.alrtbtn = 1
			RETURN("C")			&& Cancela
	ENDCASE
RETURN(" ")



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3K3           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   16     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      14                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3k3     &&  PADRAO VALID
#REGION 1
RETURN

* objetivo : compara senha criptografada com senha informada         *
*--------------------------------------------------------------------*
function Senha
 if Cripto(cSenha) = senha
     return (.t.)
  endif
  cSenha = space(8)
  show get cSenha
return (.f.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3K7           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   17     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      15                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3k7     &&  padrao VALID
#REGION 1
RETURN
PROCEDURE fox_alert
    PARAMETER  wzalrtmess, LFopcao
	PUSH KEY CLEAR		&& desabilita teclas de atalho def. anteriormente
	ON KEY LABEL F1		DO HLP2000.SPR WITH  POPUP(),PROMPT(),PROGRAM(),;
							WONTOP(),VARREAD()


    PRIVATE alrtbtn
    m.alrtbtn=1

	DEFINE WINDOW obj_aler ;
		FROM INT((SROW()-10)/2),INT((SCOL()-50)/2) ;
		TO INT((SROW()-10)/2)+9,INT((SCOL()-50)/2)+49 ;
		FOOTER "[OBJ_ALER]" ;
		FLOAT ;
		NOCLOSE ;
		SHADOW ;
		NOMINIMIZE ;
		DOUBLE ;
		COLOR SCHEME 5

	MOVE WINDOW obj_aler CENTER
	ACTIVATE WINDOW obj_aler NOSHOW

	@ 1,2 SAY wzalrtmess;
		SIZE 4,44 ;
		PICTURE "@I";
        FONT "MS Sans Serif", 10 STYLE "B"

	IF LFopcao
		@ 6,18 GET m.alrtbtn ;
		  PICTURE "@*HT \<Ok" ;
		  SIZE 1.769,8.667,1.333 ;
		  FONT "MS Sans Serif", 8 STYLE "B"
	ELSE	
		@ 6,18 GET m.alrtbtn ;
		  PICTURE "@*HT \<Nao;\?\!\<Sim" ;
		  SIZE 1.769,8.667,1.333 ;
		  FONT "MS Sans Serif", 8 STYLE "B"
	ENDIF

	ACTIVATE WINDOW obj_aler
	SHOW WINDOW OBJ_ALER TOP
	READ CYCLE MODAL WITH obj_aler
	RELEASE WINDOW obj_aler
    POP KEY
RETURN m.alrtbtn=2



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3KF           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   18     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      16                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3kf     &&  padrao VALID
#REGION 1
RETURN

PROCEDURE pdialog
	DEFINE WINDOW _qjn12zbvh ;
		AT  0.000, 0.000  ;
		SIZE 13.231,54.800 ;
		TITLE "Microsoft FoxPro" ;
		FONT "MS Sans Serif", 8 ;
		FLOAT NOCLOSE MINIMIZE SYSTEM
	MOVE WINDOW _qjn12zbvh CENTER
	ACTIVATE WINDOW _qjn12zbvh NOSHOW
	@ 2.846,33.600 SAY "Output:"  ;
		FONT "MS Sans Serif", 8 ;
		STYLE "BT"
	@ 2.846,4.800 SAY "Print:"  ;
		FONT "MS Sans Serif", 8 ;
		STYLE "BT"
	@ 4.692,7.200 GET m.p_recs ;
		PICTURE "@*RVN \<Current Record;\<All Records" ;
		SIZE 1.308,18.500,0.308 ;
		DEFAULT 1 ;
		FONT "MS Sans Serif", 8 ;
		STYLE "BT"
	@ 4.692,36.000 GET m.p_output ;
		PICTURE "@*RVN \<Printer;Pre\<view" ;
		SIZE 1.308,12.000,0.308 ;
		DEFAULT 1 ;
		FONT "MS Sans Serif", 8 ;
		STYLE "BT"
	@ 10.154,16.600 GET m.prnt_btn ;
		PICTURE "@*HT P\<rint;Ca\<ncel" ;
		SIZE 1.769,8.667,0.667 ;
		DEFAULT 1 ;
		FONT "MS Sans Serif", 8 ;
		STYLE "B"
	ACTIVATE WINDOW _qjn12zbvh
	READ CYCLE MODAL
	RELEASE WINDOW _qjn12zbvh
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3KL           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   19     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      17                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3kl     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION UPtermo   && AVANCO DO TERMOMETRO


	*------------------------------------------*
	* codigo retirado de  RELLINHA.PRG
	*------------------------------------------*

    IF !LNregistro = RECNO()   	
    	LNimpressos = LNimpressos + 1
		LNregistro = RECNO()
	ENDIF    	
	IF LNimpressos = 1
		LNpercentual = 0
	ELSE
		LNpercentual = (LNimpressos / LNimpressao)
	ENDIF
	LSEToldcons = SET("CONSOLE")
	SET CONSOLE ON
	IF CHRSAW()
		CLEAR TYPEAHEAD
		IF fox_alert("Deseja Abandonar  Processo ??? ")
			LFsegue = .f.
		ENDIF
	ENDIF
	ACTIVATE WINDOW prinstat NOSHOW

	@ 1,5 SAY wp_msg
	@ 0,1 TO 0,55 ;
		COLOR SCHEME 23
	@ 7,1 TO 7,55 ;
		COLOR SCHEME 24
	@ 1,56 TO 7,56 ;
		COLOR SCHEME 24
	@ 7,56 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 24
	@ 0,56 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 24
	@ 2,3 TO 2,53 ;
		COLOR SCHEME 23
	@ 4,3 TO 4,53 ;
		COLOR SCHEME 24
	@ 4,54 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 24
	@ 3,54 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 24
	@ 2,54 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 24
	@ 5,3 SAY "" ;
		SIZE 1,51, 0
	@ 6,2 SAY " 0   10   20   30   40   50   60   70   80   90   100" ;
		SIZE 1,53, 0
	@ 1,0 TO 6,0 ;
		COLOR SCHEME 23
	@ 0,0 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 23
	@ 7,0 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 23
	@ 3,2 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 23
	@ 2,2 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 23
	@ 4,2 SAY "" ;
		SIZE 1,1, 0 ;
		COLOR SCHEME 23
	****************
	ACTIVATE WINDOW prinstat
	LNpreenche = (INT(LNpercentual*50))+1
	@ 03,03 SAY REPLICATE("",LNpreenche) COLOR SCHEME 21
	ACTIVATE SCREEN
	SET CONSOLE &LSEToldcons


RETURN(" ")		


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3KT           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   20     
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      18                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3kt     &&  padrao VALID
#REGION 1
RETURN

***********************************************************************
** UPinterrompe =>
**	 	UPinterrompe para interromper processo que sao de controle da
** 		linguagem e que nao usam o controle de STATUS RELINI,RELLINHA E
** 		RELFIM
**		EXEMPLO COPY TO \TMP\TESTE WHILE !UPinterrompe(LFinterrompe)
**		de validacao.
************************************************************************

FUNCTION UPinterrompe
	PARAMETER LFinterrompe
	IF !LFinterrompe 		&& PROCESSO JA VEM DE INTERRUPCAO ANTERIOR
		IF CHRSAW()
			CLEAR TYPEAHEAD
			IF fox_alert("Deseja Abandonar  Processo ??? ")
				LFinterrompe = .T.
			ENDIF
		ENDIF
	ENDIF
RETURN(LFinterromp)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3L0           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   21     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      19                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3l0     &&  PADRAO VALID
#REGION 1
RETURN
***********************************************************************
** UPDESCANSO =>
**	 	UPdescanso e utilizado nos valides dos gets em telas de aguade,
** 		exemplo OBJ_SENH, pra permitir a utilizacao de timeout no read
** 		e ativar o protetor de tela. UPdescanso nao influencia a condicao
**		de validacao.
************************************************************************

FUNCTION UPdescanso
	IF READKEY() = 20
			DO UPprotege				
	ENDIF
RETURN(.T.)




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3L7           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   22     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      20                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3l7     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION UPbeeps && emite menssagems com ou sem beep repetivos de alerta

PARAMETERS Lfdispara,Lsmsg,Lntempo,Lninicio
	PUSH KEY CLEAR		&& desabilita teclas de atalho def. anteriormente
    ON KEY LABEL ESCAPE KEYBOARD "{BACKTAB}"
	SET ESCAPE OFF
	CLEAR TYPEAHEAD
	IF TYPE("Lntempo") <> "N"
		Lntempo = 4
	ENDIF	

	IF TYPE("Lninicio") <> "N"
		Lninicio = 0
	ENDIF	

	DEFINE WINDOW menssagem FROM 1, 11 TO 3, 20
	ACTIVATE WINDOW  menssagem NOSHOW
	WAIT WINDOW Lsmsg NOWAIT
	set bell to 1000,1
	?chr(7)

	Ltmp = 0
	DO WHILE Ltmp = 0
		if Lfdispara
*
			set bell to LNinicio+1000,1
			?chr(7)
*
			set bell to LNinicio+200,1
			?chr(7)
*
			set bell to LNinicio+950,1
			?chr(7)
*
			set bell to LNinicio+200,1
			?chr(7)
*
			set bell to LNinicio+1000,1
			?chr(7)
*
			set bell to LNinicio+1000,1
			?chr(7)
*
			set bell to LNinicio+200,1
			?chr(7)
*
			set bell to LNinicio+950,1
			?chr(7)
*
			set bell to LNinicio+200,1
			?chr(7)
*
			set bell to LNinicio+1000,1
			?chr(7)
			
			if LNinicio > 0
				set bell to LNinicio+1000,5
				?chr(7)
			ENDIF
			Ltmp = INKEY(Lntempo)
		ELSE
			Ltmp = INKEY(0)
			EXIT
		endif
*
	ENDDO
	RELEASE WINDOW menssagem
    POP KEY
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3MY           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   23     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      21                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3my     &&  PADRAO VALID
#REGION 1
RETURN

PROCEDURE UPmarcador
		WAIT WINDOW LSmarcador NOWAIT
		IF LSmarcador = "  "
			LSmarcador	= "  "	
		ELSE
			IF LSmarcador = "  "
				LSmarcador	= "  "	
			ELSE
				LSmarcador = "  "
			ENDIF
		ENDIF
RETURN



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3MZ           UPlimpStrg VALID                   
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   24     
*        Variable:            UPlimpStrg                         
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      22                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3mz     &&  UPlimpStrg VALID
#REGION 1
RETURN

	*------------------------------------------------------------*
	* CLASSIFICACAO:  [*****]
	*------------------------------------------------------------*
	* OBJETIVO....: Livrar uma String de Caracteres de Marcara
	*				ex : - , .  , / etc
	*------------------------------------------------------------*
	* COMENTARIO..:
	*------------------------------------------------------------*
	* OBS........ :
	*------------------------------------------------------------*
	*  TABELAS....:
	*------------------------------------------------------------*
	*  PARAMETROS..:
	*		LSstrg.........: String para proceso
	*
	*------------------------------------------------------------*
	*  RETORNO.....:
	*------------------------------------------------------------*
	*  EXEMPLO.....: Rotina de validacao de INSCRICAO UPInscricao
	*------------------------------------------------------------*

FUNCTION UPlimpStrg
PARAMETERS LSstrg
	LSstrg	= CHRTRAN(LSstrg,".","")
	LSstrg	= CHRTRAN(LSstrg,",","")
	LSstrg	= CHRTRAN(LSstrg,"-","")
	LSstrg	= CHRTRAN(LSstrg,"/","")
	LSstrg	= CHRTRAN(LSstrg,"(","")
	LSstrg	= CHRTRAN(LSstrg,")","")
	LSstrg	= CHRTRAN(LSstrg," ","")
RETURN



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3N0           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   25     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      23                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3n0     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION UPtempopas   && Retorna diferenca em minutos entre horas e datas
	PARAMETERS LDdtini, LDdtfim, LShini, LShfim

	LNdias = LDdtfim -  LDdtini
	LNmdias = 0
	IF LNdias > 1
		LNmdias = (LNdias - 1) * 24 * 60  && minutos dos dias inteiros
	ENDIF
	DO CASE
		CASE LNdias = 0
			LNhi = VAL(SUBS(LShini,1,2)) * 60 && HORA INIC EM MINUTOS
			LNhf = VAL(SUBS(LShfim,1,2)) * 60 && HORA FINAL EM MINUTOS
			LNmi = VAL(SUBS(LShini,4,2)) && MINU INIC
			LNmf = VAL(SUBS(LShfim,4,2)) && MINU FINAL
			LNtempo =  (LNhf + LNmf) - (LNhi + LNmi)
		OTHERWISE
			LNhi = (24 - VAL(SUBS(LShini,1,2))) * 60 && HORA INIC EM MINUTOS
			LNhf = VAL(SUBS(LShfim,1,2)) * 60 && HORA FINAL EM MINUTOS
			LNmi = (60 - VAL(SUBS(LShini,4,2))) && MINU INIC
			LNmf = VAL(SUBS(LShfim,4,2)) && MINU FINAL
			LNtempo = (LNhi + LNmi)  + (LNhf + LNmf) + LNmdias
	ENDCASE
RETURN(LNtempo)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3N1           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   26     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      24                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3n1     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION UPtempmais  && A Data e Hora somados em tantos minutos
	PARAMETERS LDdt, LSh, LNm_mais

	private LNh, LNm, LNmsom, LNhsom, LNdsom, LNmfim, LNhfim, LNdtfim
	
	LNh  = INT(VAL(LEFT(LSh,2)))
	LNm  = INT(VAL(SUBS(LSh,4,2)))

*** processa soma de minutos ****

	LNmsom = LNm + LNm_mais
	LNhsom = 0
	IF LNmsom >= 60
		LNhsom = INT(LNmsom/60)			&& quantas horas a mais
	ENDIF
	LNmfim = LNmsom - (LNhsom * 60)   && os minutos da fultura hora

*** processa soma de horas ****

	LNhsom = LNh + LNhsom  			&& soma horas
	LNdsom = 0
	IF LNhsom >= 24
		LNdsom = INT(LNhsom/24)			&& quantas dias  a mais
	ENDIF
	LNhfim = LNhsom - (LNdsom * 24)   && a hora final
				
*** processa soma de dias  ****
	LNdtfim =  LDdt + LNdsom  			&& data final

*** RESULTADO EM VARIAVEIS GLOBAIS
	W_FULTDT = LNdtfim
	W_FULTH  = STR(LNhfim,2)+":"+STR(LNmfim,2)
	W_FULTH  = chrtran(W_FULTH," ","0")
RETURN(.T.)





*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3N2           UPPreImpressao VALID               
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   27     
*        Variable:            UPPreImpressao                     
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      25                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3n2     &&  UPPreImpressao VALID
#REGION 1
RETURN

*******************
*---->   (INICIALIZACAO DO CONTROLE DE STATUS IMPRESSAO)
*******************	
PROCEDURE UPPreImpressao
PARAMETERS PrmRel, PrmDireciona, PrmAgrega, PrmFimagrega
	
	DO RELINIC.PRG          && INICIA VAR P/ TERMOMETRO
	LFsegue     = .t.
	LNregistro  = RECNO()
	LNimpressao = 0
    LNimpressao = RECCOUNT()
	LNimpressos = 0
	GO LNregistro
	
	*******************
	*---->   (COMPLETADO PREPARACAO DO CONTROLE DE STATUS IMPRESSAO)
	*******************	
	LF_fim     = .f.
    LSrel 	   = PrmRel      && relatorio padrao
    LSorienta  = " FOR LFsegue "

	DO UPimpressao WITH PrmDireciona, PrmAgrega, PrmFimagrega
	
	LFcontinua = LFsegue
	************
	DO RELFIM.PRG          && FIM VAR P/ TERMOMETRO

RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3N3           UPimpressao VALID                  
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   28     
*        Variable:            UPimpressao                        
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      26                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3n3     &&  UPimpressao VALID
#REGION 1
RETURN

PROCEDURE UPimpressao    && COORDENA TRABALHO DE IMPRESSAO CONF. PARAMETROS
	PARAMETERS LFdireciona,LFagrega,LFfimagrega,LStipoimp

**********************************************************************
*	Os parametros passados sao trabalhados tendo em vista que rotinas
* montadas antes deste implemento nao passao parametros, o que implica
* em seus valores terem (.f.) como defaut.
**********************************************************************
*   Para tornar os flags mais coerentes estes valores sao invertidos
* antes do processamento de suas implicacoes. Motivo didatico.
**********************************************************************
	LFdireciona = !LFdireciona
************************   APOS A INVERSAO ***************************	
*	LFdireciona  => .T. Ativa PRTSETUP para direcionar impressao DEF(.T.)
*	LFagrega 	 => .T. Agrega o ??.REL em ??.AGR				 DEF(.F.)
*	LFfimagrega  => .T. Qdo. Estiver agregando => encerra        DEF(.F.)
**********************************************************************
*-----------------------------------------------------------*
* 	LStipoimp		: "REPORT" 	=> RELATORIOS
*					  "LABEL"	=> ETIQUETAS
*-----------------------------------------------------------*	
	if TYPE("LStipoimp") <> "C"
		LStipoimp = "REPORT"
	ENDIF		

	IF !EMPTY(ALLTRIM(wp_arqname))    && MONTA NOME DO ARQ. AGREGACAO
		LSarqagrega = SUBS(wp_arqname,1,AT(".",wp_arqname))+"AGR"
	ENDIF
	IF LFdireciona
		DO PRTSETUP.SPR
		IF LASTKEY() = 27
			RETURN
		ENDIF	
		IF !EMPTY(ALLTRIM(wp_arqname))  && LIMPAR ARQ. *.AGR
			LSarqagrega = SUBS(wp_arqname,1,AT(".",wp_arqname))+"AGR"
		    IF FILE(LSarqagrega)
				DELETE FILE &LSarqagrega
			ENDIF
		ENDIF
	ELSE
	   SET PRINTER TO
	   DO CASE
		   CASE wp_destimp = 'REDE'
    		  IF !EMPTY(wp_impressora)
				RUN CAPTURE /SERVER=&wp_servimp ;
		    	    /QUEUE=&wp_nomeimp /FORM=&wp_formimp ;
		        	/COPIES=&wp_copimp /NO FORMFEED /NO BANNER > &LPtmp

				RUN PSC PS=&wp_servspool P=&wp_servnum MOUNT FORM ;
					 &wp_formimp > &LPtmp
				RUN PSC PS= &wp_servspool  P=&wp_servnum STAT > &LPtmp
	     	 ENDIF
		   OTHERWISE
    		  SET PRINTER TO &pdest
	   ENDCASE
	ENDIF
**********************************************************************
	PUSH KEY CLEAR
	ON KEY LABEL F1		DO HLP2000.SPR WITH  POPUP(),PROMPT(),PROGRAM(),;
							WONTOP(),VARREAD()
	ON KEY LABEL F12    DO OBJ_CALC.SPR



	CLEAR TYPEAHEAD

	CLEAR TYPEAHEAD



	IF wp_drivstup  =  0       && 1=DRIV. IMP ATIVO // 0=DRIV. IMP. INATIVO
	    IF LSrel <> "REL000"
		    LSrel = LSrel       && +"E" (rel adaptado p/ imp tp emilia)
		ENDIF
	ENDIF
	SET POINT TO ","
	SET SEPARATOR  TO "."
	HIDE WINDOW ALL
***>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  EM VIDEO >>>>
	LFimp = .T.     && IMPRIMIR
	LNateimpres = LNimpressao
    LNregantes  = LNregistro




	IF !EMPTY(ALLTRIM(wp_arqname))
		LStmp  = CURDIR()  		&&  DIRETORIO PADRAO
		DO WHILE .T.

		   LSatmp = wp_arqname
		   cTMP =  FOPEN("&wp_arqname",1)
*
**  desativado em  26/05/2015 - arquivos de impressao vasios
*
*		   IF cTMP < 0
*				=UParqvisao()
*		   ENDIF
*

		   =FCLOSE(cTMP)



		   LFresulta = .t. 		&& defaut nao fechamento da secao
		   IF LSrel = "REL000"
		      Ltmp = tag()
			  DO psqcdx.spr
			  SET DEVICE TO FILE &wp_arqname
			  DO REL000.PRG
			  SET DEVICE TO SCREEN	
    		  set order to  tag &Ltmp
		   ELSE
			  _PLinino = wp_pgini
			  _PEpage  = wp_pgfim
			  SET CONSOLE OFF
			  ON ERROR DO UPerrosys
			  PRINTJOB
  					&LStipoimp FORM &LSrel &LSorienta ;
  							REST NOCONSOLE TO FILE &wp_arqname
			  ENDPRINTJOB
			  ON ERROR DO UPerrosys
			  SET CONSOLE ON
	   ENDIF
		   IF  LSatmp = wp_arqname
			   EXIT	
		   ENDIF
		ENDDO
		GO TOP
		IF !(EOF() AND BOF())
			GO LNregantes
		ENDIF
		DO RELFIM.PRG          && FIM VAR P/ TERMOMETRO
		DO RELINIC.PRG          && INICIA VAR P/ TERMOMETRO
		LNimpressos = 0
		LNimpressao = LNateimpres
		*****************************************
		SET SYSMENU ON
		PUSH MENU _MSYSMENU
		SET SYSMENU TO _MWINDOW, _MWI_ZOOM,_MWI_MOVE, _MEDIT, _MED_FIND, ;
						_MED_FINDA
		HIDE MENU _MSYSMENU
		ON KEY LABEL F10    KEYBOARD "{CTRL-F10}"

		******************************************
		IF LFagrega 	&& .T. Agrega o ??.REL em ??.AGR  DEF(.F.)
		    IF !FILE(LSarqagrega)
				RUN TYPE &wp_arqname >  &LSarqagrega
			ELSE
				RUN TYPE &wp_arqname >>  &LSarqagrega
			ENDIF
			IF LFfimagrega 	&& .T. encerra agregacao

				KEYBOARD "{CTRL-F10}"
				MODIF COMM &LSarqagrega NOEDIT

				IF fox_alert("Enviar relatorio para impressora ?")
					DEFINE WINDOW WLoutput FROM 0,1 TO 2,2
					ACTIVATE WINDOW wlOUTPUT NOSHOW
					SET HEADINGS OFF
					ON ERROR
					TYPE &LSarqagrega TO PRINTER
					ON ERROR DO UPerrosys
					RELEASE WINDOW wloutput
				ENDIF		
			ENDIF
		ELSE

			KEYBOARD "{CTRL-F10}"
			MODIF COMM &wp_arqname   NOEDIT

			SET DEFA TO &LStmp		&& VOLTA AO DIRETORIO PADRAO
			IF fox_alert("Enviar relatorio para impressora ?")
				DEFINE WINDOW WLoutput FROM 0,1 TO 2,2
				ACTIVATE WINDOW wlOUTPUT NOSHOW
				SET HEADINGS OFF
				ON ERROR
				TYPE &wp_arqname TO PRINTER
				ON ERROR DO UPerrosys
				RELEASE WINDOW wloutput
			ENDIF		
		ENDIF
		POP MENU _MSYSMENU
		SET SYSMENU OFF
		HIDE MENU _MSYSMENU
		*****************************************
***>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  EM PAPEL >>>>
	ELSE
***>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  EM PAPEL >>>>
	   IF LSrel = "REL000"
	      Ltmp = tag()
		  DO psqcdx.spr
	   	  SET DEVICE TO PRINTER
		  DO REL000.PRG
		  SET DEVICE TO SCREEN	
   		  set order to  tag &Ltmp
	   ELSE
		  _PLinino = wp_pgini
		  _PEpage  = wp_pgfim
		  SET CONSOLE OFF
		  ON ERROR DO UPerrosys

		  PRINTJOB
			&LStipoimp FORM &LSrel &LSorienta REST NOCONSOLE   TO PRINTER
		  ENDPRINTJOB
		  ON ERROR DO UPerrosys
		  SET CONSOLE ON
	   ENDIF	
	ENDIF
    SET PRINTER TO \TMP\qualquer
    SET PRINTER TO SET('PRINTER',1)
	IF !EMPTY(ALLTRIM(wp_libimp))
		RUN &wp_libimp > \TMP\SAIDA.TXT
		ACTIVATE SCREEN
		=UPapaga()
	ENDIF
    SET PRINTER TO
    SET PRINTER TO

	SET RELATION TO
	SET POINT TO
	SET SEPARATOR  TO
	CLEAR TYPEAHEAD

	POP KEY 			&& reabilita teclas de atalho def. anteriormente
*	SHOW WINDOW ALL

RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3N4           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   29     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      27                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3n4     &&  PADRAO VALID
#REGION 1
RETURN

*----------------------------------------------------------------*
* objetivo : retorna valor por extenso de um valor numerico      *
*----------------------------------------------------------------*
function Extenso
   parameter nValor
   cDesc_1    = "Hum"
   cDescE_1   = "Um"
   cDesc_2    = "Dois"
   cDesc_3    = "Tres"
   cDesc_4    = "Quatro"
   cDesc_5    = "Cinco"
   cDesc_6    = "Seis"
   cDesc_7    = "Sete"
   cDesc_8    = "Oito"
   cDesc_9    = "Nove"
   cDesc_10   = "Dez"
   cDesc_11   = "Onze"
   cDesc_12   = "Doze"
   cDesc_13   = "Treze"
   cDesc_14   = "Quatorze"
   cDesc_15   = "Quinze"
   cDesc_16   = "Dezesseis"
   cDesc_17   = "Dezesete"
   cDesc_18   = "Dezoito"
   cDesc_19   = "Dezenove"
   cDesc_20   = "Vinte"
   cDesc_30   = "Trinta"
   cDesc_40   = "Quarenta"
   cDesc_50   = "Cinquenta"
   cDesc_60   = "Sessenta"
   cDesc_70   = "Setenta"
   cDesc_80   = "Oitenta"
   cDesc_90   = "Noventa"
   cDesc_100  = "Cem"
   cDescE_100 = "Cento"
   cDesc_200  = "Duzentos"
   cDesc_300  = "Trezentos"
   cDesc_400  = "Quatrocentos"
   cDesc_500  = "Quinhentos"
   cDesc_600  = "Seiscentos"
   cDesc_700  = "Setecentos"
   cDesc_800  = "Oitocentos"
   cDesc_900  = "Novecentos"

   cValor = str(nValor,14,2)
   lAnd = iif(left(right(cValor,2),1)="0".and.right(cValor,1)#"0",.f.,.t.)
   nCont = 15 - len(ltrim(cValor))
   cExtenso = ""

   do while nCont < 12
      if nCont = 3 and len(cExtenso) > 0
         if cExtenso= "Hum "
            cExtenso= cExtenso + "Bilhao"
         else
            cExtenso= cExtenso + "Bilhoes"
         endif
         if substr(cValor,3,3) # "000"
            cExtenso = cExtenso + ","
         endif
         cExtenso = cExtenso + " "
      endif
      if nCont = 6 and len(cExtenso) > 0
         if right(cExtenso,4) = "Hum "
            cExtenso = cExtenso + "Milhao"
         else
            cExtenso = cExtenso + "Milhoes"
         endif
         if substr(cValor,6,3) # "000"
            cExtenso = cExtenso + ","
         endif
         cExtenso = cExtenso + " "
      endif
      if nCont = 9 and len(cExtenso) > 0
         if substr(cValor,6,3) # "000"
            cExtenso = cExtenso + "Mil"
         endif
         if substr(cValor,9,3) # "000"
            cExtenso = cExtenso + ","
         endif
         cExtenso = cExtenso + " "
      endif
      nC1 = substr(cValor,nCont,1)
      if (nCont = 3 or nCont = 6 or nCont = 9) and ! nC1 $ " 0"
         nC2 = substr(cValor,nCont+1,1)
         nC3 = substr(cValor,nCont+2,1)
         p = nC1 + "00"
         if nC1 = "1" and nC2 + nC3 # "00"
            cExtenso = cExtenso + cDescE_&p + " "
         else
            cExtenso = cExtenso + cDesc_&p + " "
         endif
         if nC2 + nC3 # "00" and lAnd
            cExtenso = cExtenso + "e "
         endif
      endif
      if (nCont = 1 or nCont = 4 or nCont = 7 or nCont = 10) and ! nC1 $ " 0"
         nC2 = substr(cValor,nCont+1,1)
         p = nC1 + "0"
         if nC1 = "1" and nC2 # "0"
            p = nC1 + nC2
         endif
         cExtenso = cExtenso + cDesc_&p + " "
         if nC1 = "1" and nC2 # "0"
            nCont = nCont + 2
            loop
         endif
         if nC2 # "0" and lAnd
            cExtenso = cExtenso + "e "
         endif
      endif
      if (nCont = 2 or nCont = 5 or nCont = 8 or nCont = 11) and !nC1 $ " 0"
         p = nC1
         if nC1 = "1" and len(cExtenso) > 0
            cExtenso = cExtenso + cDescE_&p + " "
         else
            cExtenso = cExtenso + cDesc_&p + " "
         endif
      endif
      nCont = nCont + 1
   enddo

   if right(cExtenso,8) = "Milhoes "
      cExtenso = cExtenso + " de "
   endif
   if nValor >= 1
      cExtenso= cExtenso + iif(nValor<2,"Real ","Reais ")
   endif
   if right(cValor,2) # "00" and lAnd and nValor > 1
      cExtenso = cExtenso + "e "
   endif
   nC1 = substr(cValor,13,1)
   nCont = 0
   if nC1 # "0"
      nC2 = substr(cValor,14,1)
      p = nC1 + "0"
      if nC1 = "1" and nC2 # "0"
         p = nC1 + nC2
         nCont = nCont + 1
      endif
      cExtenso = cExtenso + cDesc_&p + " "
   endif
   nC1 = substr(cValor,14,1)
   if nC1 # "0" and nCont = 0
      p = nC1
      cExtenso = cExtenso + iif(nValor>1,"e ","") + iif(p="1","Um",cDesc_&p) + " "
   endif
   if right(cValor,2) # "00"
      cExtenso = cExtenso + iif(nC1="1","Centavo","Centavos")
   endif
return ( alltrim(cExtenso) )

*----------------------------------------------------------------*
* objetivo : separa silabas de valor por extenso                 *
*----------------------------------------------------------------*
function Separa
   set exact off
   dimension vNomes[ 50 ]
   store "" to vNomes

   vNomes[01] = "Hum"
   vNomes[02] = "Um"
   vNomes[03] = "Dois"
   vNomes[04] = "Tres"
   vNomes[05] = "Quatro"
   vNomes[06] = "Cinco"
   vNomes[07] = "Seis"
   vNomes[08] = "Sete"
   vNomes[09] = "Oito"
   vNomes[10] = "Nove"
   vNomes[11] = "Dez"
   vNomes[12] = "Onze"
   vNomes[13] = "Doze"
   vNomes[14] = "Treze"
   vNomes[15] = "Quatorze"
   vNomes[16] = "Quinze"
   vNomes[17] = "Dezesseis"
   vNomes[18] = "Dezesete"
   vNomes[19] = "Dezoito"
   vNomes[20] = "Dezenove"
   vNomes[21] = "Vinte"
   vNomes[22] = "Trinta"
   vNomes[23] = "Quarenta"
   vNomes[24] = "Cinquenta"
   vNomes[25] = "Sessenta"
   vNomes[26] = "Setenta"
   vNomes[27] = "Oitenta"
   vNomes[28] = "Noventa"
   vNomes[29] = "Cem"
   vNomes[30] = "Cento"
   vNomes[31] = "Duzentos"
   vNomes[32] = "Trezentos"
   vNomes[33] = "Quatrocentos"
   vNomes[34] = "Quinhentos"
   vNomes[35] = "Seiscentos"
   vNomes[36] = "Setecentos"
   vNomes[37] = "Oitocentos"
   vNomes[38] = "Novecentos"
   vNomes[39] = "Mil"
   vNomes[40] = "e"
   vNomes[41] = "Reais"
   vNomes[42] = "Centavos"
   vNomes[43] = "Centavo"
   vNomes[44] = "Mil,"

   if len(cE1) < 54
      return
   endif

   if left(cE2,1) = space(1)
      cE2 = alltrim(cE2)
      return
   endif

   if right(cE1,1) = space(1)
      for i = 54 to 1 step -1
          if substr(cE1,i,1) = space(1)
             cE1 = stuff(alltrim(cE1),i,0," ")
             exit
          endif
      endfor
      cE2 = alltrim(cE2)
      return
   endif

*  retirar pedaco direito da 1a.linha do extenso

   nTam = 1
   i = 54
   do while substr(cE1,i,1) # space(1)
      nTam = nTam + 1
      i = i - 1
   enddo
   cP1 = right(cE1,nTam)

*  retirar pedaco esquerdo da 2a.linha do extenso

   if space(1) $ cE2
      nTam = 0
      i = 1
      do while substr(cE2,i,1) # space(1)
         nTam = nTam + 1
         i = i + 1
      enddo
      cP2 = left(cE2,nTam)
   else
      cP2 = ""
   endif

   cTotal = ALLTRIM(cP1 + cP2)
   nAchou = Ascan(vNomes,cTotal)
   if empty(nAchou)  && nao houve separacao
      cE2 = alltrim(cE2)
      return
   endif

   cE2 = cP1 + cE2

*  inserir espacos em branco na 1a.linha do extenso

   nTam = len(cP1) + 1
   cE1 = left(cE1,55-nTam)
   dimension vPos[30]
   store 0 to vPos, j
   i = len(cE1)

   do while nTam > 0 and i # 0
      if substr(cE1,i,1) = space(1)
         j = j + 1
         vPos[j] = i
         nTam = nTam - 1
      endif
      i = i - 1
   enddo

   for i = 1 to j
       cE1 = stuff(cE1,vPos[i],0," ")
   endfor

   if j < len(cP1)

      nTam = len(cP1) - j
      store 0 to vPos, j
      i = len(cE1)
      do while nTam > 0 and i # 0
         if substr(cE1,i,1) = space(1)
            j = j + 1
            vPos[j] = i
            nTam = nTam - 1
         endif
         i = i - 2
      enddo
      for i = 1 to j
          cE1 = stuff(cE1,vPos[i],0," ")
      endfor

   endif

   cE2 = alltrim(cE2)
return(" ")


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3N5           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   30     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      28                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3n5     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION UPcalcdig
	PARAMETER UPSnumero
		IF TYPE("UPSnumero") = "N"     && transforma numero em string
			UPSnumero = ALLTRIM(STR(UPSnumero))
		ELSE
			UPSnumero = ALLTRIM(UPSnumero)
		ENDIF

		UPSmolde 	= "9876543298765432"   && molde p/ 16 digitos
		UPSnumero   = RIGHT(REPL("0",16)+UPSnumero,16) && num. p/ trabalho
 		I = 0
		UPNsoma = 0
		FOR I = 1 TO 16
			UPNposicao = VAL(SUBS(UPSmolde,I,1))
			UPNdigito  = VAL(SUBS(UPSnumero,I,1))
			UPNsoma = UPNsoma + (UPNposicao * UPNdigito)
		ENDFOR
		UPN_ftr1 = INT(UPNsoma / 11)
		UPN_ftr2 = UPNsoma - (UPN_ftr1 * 11)
		IF UPN_ftr2 < 2
			 UPN_ftr2 = 0
		ELSE
			 UPN_ftr2 = 11 - UPN_ftr2
		ENDIF
		UPSdgsecur = ALLTRIM(STR(UPN_ftr2))
RETURN(UPSdgsecur)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3N6           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   31     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      29                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3n6     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION ULdias_ut
	PARAMETERS LDdtini,LDdtfim
	PRIVATE LNqtdias,LDini
	
	LDini = LDdtini
	SELE feriado
	SET ORDER TO TAG dtferiado

	LNqtdias = 0
	DO WHILE LDini <= LDdtfim

		SEEK STR(0,3)+DTOS(LDini)
		IF !FOUND() AND DOW(LDini) <> 1
			LNqtdias = LNqtdias +1
		ENDIF
		LDini = LDini + 1
	ENDDO
RETURN(LNqtdias)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3NB           UPdtSaltaUteis VALID               
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   32     
*        Variable:            UPdtSaltaUteis                     
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      30                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3nb     &&  UPdtSaltaUteis VALID
#REGION 1
RETURN

FUNCTION UPdtSaltaUteis
	PARAMETER LDdtref,LNnroDias
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [*****]   MODULO INDEPENDENTE				 *
	*------------------------------------------------------------*
	* OBJETIVO....: Retornar a Data Formada Pela data de Referencia
	*			(+) ou (-) XX dias Uteis
	*------------------------------------------------------------*
	*------------------------------------------------------------*
	* PARAMETROS..:
	*		LDdtref........: Data Referencia
	*		LNnroDias......: Numero de Dias Uteis
	*						Se (-???) => Voltar  ??? dias Uteis
	*						Se (+???) => Avancar ??? dias Uteis
	*------------------------------------------------------------*
	=W_DEFPROC("rotinas.spr")
	*------------------------------------------------------------*
	PRIVATE LDEncontrada
	PRIVATE LNuteis 	&& Qtde de Dias Uteis Ja Encontrados	
	PRIVATE LNtotal     && Total de Dias Independente de Ser Util
	LNuteis = 0		
	LNtotal = 0

	DO WHILE LNuteis < ABS(LNnroDias)
		LNtotal = LNtotal + 1
		
		IF LNnroDias < 0
			IF DOW(LDdtref - LNtotal) <> 1
				LNuteis = LNuteis +1
			ENDIF
		ELSE
			IF DOW(LDdtref + LNtotal) <> 1
				LNuteis = LNuteis +1
			ENDIF
		ENDIF
	ENDDO
	IF LNnroDias < 0
		LDEncontrada = LDdtref - LNtotal
	ELSE
		LDEncontrada = LDdtref + LNtotal
	ENDIF
RETURN(LDEncontrada)

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3NI           fecha VALID                        
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   36     
*        Variable:            fecha                              
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      31                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3ni     &&  fecha VALID
#REGION 1
RETURN

procedure fecha
	IF !fox_alert(" << S A I R   D O   S I S T E M A  ? >> ")
		RETURN
	ENDIF
	release menus all

   	lmenu = .t.
   	keyboard chr(27)
   	KEYBOAR "{S}"

   	CLEAR READ
return




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3NO           ULfechamn VALID                    
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   38     
*        Variable:            ULfechamn                          
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      32                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3no     &&  ULfechamn VALID
#REGION 1
RETURN

PROCEDURE ULfechamn
	RETURN
	=UP_fecha("acessos")
	=UP_fecha("usuario")
	=UP_fecha("indice")
	=UP_fecha("formato")
	=UP_fecha("cadmenu")
	=UP_fecha("parametr")
RETURN




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3NU           VAI VALID                          
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   39     
*        Variable:            VAI                                
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      33                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3nu     &&  VAI VALID
#REGION 1
RETURN


FUNCTION VAI
 PARAMETERS wl_arquivo, wl_chamada
	wp_popup = POPUP()
	wp_barra = STR(BAR(),2)
	IF TYPE("wl_chamada") $ "UL"
		wl_chamada = 1
	ENDIF


	*****    VALORES PARA wl_chamada ***************
	*			1 => DO
	*			2 => !		EXECUCAO EXTERNA

	*------------------------------------------------------------------*
	*   Quando a Chamada For a "UPmudausr" no Deve Reposicionar  o
	* POPUP Pois o Menu Ser Redefinido e Provocaria erro no PUSH
	*------------------------------------------------------------------*



	IF !(UPPER(wl_arquivo) $ "UPMUDAUSR/OBJ_ATVA/UPAREAWORK") AND ;
	   !(UPPER(wl_arquivo) $ "UPOUTRAS/UPCENTRAL/UPLOJA") AND ;
	   !(UPPER(wl_arquivo) $ "UPEMPRESA/UPTRASNFDB/SCGC008.SPR")

		PUSH POPUP &WP_POPUP
	ENDIF


	SET SYSMENU OFF
	PUSH KEY CLEAR

	ON KEY LABEL F1		DO HLP2000.SPR WITH  POPUP(),PROMPT(),PROGRAM(),;
							WONTOP(),VARREAD()
	DO CASE
		CASE LASTKEY() = 10 AND lMaster 	&& CTRL-ENTER *-----------
			IF "." $ wl_arquivo
				m.programa 	= LEFT(wl_arquivo,AT(".",wl_arquivo)-1)
			ELSE
				m.programa 	= wl_arquivo
			ENDIF	
			*----------------------------------------------------------*
			=W_DEFPROC("ACESSO.SPR")
			DO ACdef_aces WITH (m.programa),BARPROMPT(INT(VAL(wp_barra)))
			*----------------------------------------------------------*

		CASE LASTKEY() = 32 AND lMaster 	&& SPACE BAR *-----------
			m.mnmenu 	= LEFT(MENU()+"     ",10)
			m.mnpad		= LEFT(PAD()+"     ",10)
			m.mnpopup	= LEFT(POPUP()+"     ",10)
			m.mnbar		= BAR()
			m.mnprompt  = PROMPT()
			m.programa 	= wl_arquivo
			*----------------------------------------------------------*
			=W_DEFPROC("ACESSO.SPR")
			DO ACreg_Barra WITH ;
						 (m.programa),(m.mnmenu),;
						 (m.mnpad),(m.mnpopup),(m.mnbar)
			*----------------------------------------------------------*

		OTHERWISE
			IF "." $ wl_arquivo
				WPprgativo 	= LEFT(wl_arquivo,AT(".",wl_arquivo)-1)
			ELSE
				WPprgativo 	= wl_arquivo
			ENDIF	
			IF wl_chamada = 1
				DO &wl_arquivo
			ELSE
				IF WPprgativo $ "CALCPR/PV"
					LStmp  = sys(5)+sys(2003) && UNIDADE E DIR. CORRENTES
					SET DEFA TO \TAB\
					! &wl_arquivo /N
					SET DEFA TO &LStmp
				ELSE
					! &wl_arquivo /N
				ENDIF
			ENDIF
			WPprgativo  = ""
	ENDCASE
	POP KEY
*	=UPapaga()

*	IF UPPER(wl_arquivo) <> "UPMUDAUSR"

	IF !(UPPER(wl_arquivo) $ "UPMUDAUSR/OBJ_ATVA/UPAREAWORK") AND ;
	   !(UPPER(wl_arquivo) $ "UPOUTRAS/UPCENTRAL/UPLOJA") AND ;
	   !(UPPER(wl_arquivo) $ "UPEMPRESA/UPTRASNFDB/SCGC008.SPR")

		ON ERROR *
		POP POPUP &WP_POPUP
		ON ERROR DO UPerrosys

	ELSE
		=W_DEFPROC("acesso.spr")
		=ACredmenu(wp_acesso)			  && MANDA REDEFINIR
	ENDIF

RETURN




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3O0           UPCarregaMnu VALID                 
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   40     
*        Variable:            UPCarregaMnu                       
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      34                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3o0     &&  UPCarregaMnu VALID
#REGION 1
RETURN


PROCEDURE  UPCarregaMnu

	DO UPambientaliza

	do s0000000.mpr    && PRENDE O SISTEMA EM EXECUCAO


RETURN

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3O5           UPCriatermo VALID                  
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   43     
*        Variable:            UPCriatermo                        
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      35                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3o5     &&  UPCriatermo VALID
#REGION 1
RETURN

FUNCTION UPCriatermo   && AVANCO DO TERMOMETRO

	*------------------------------------------------------------*
	*---->   (INICIALIZACAO DO CONTROLE DE STATUS IMPRESSAO)
	*------------------------------------------------------------*
	* codigo que pertencia a RELINIC.PRG INICIA VAR P/ TERMOMETRO
	*------------------------------------------------------------*

	IF TYPE("LNregistro") = "U"
		PUBLIC LNregistro   	 && posicao do arquivo antes de processos
	ENDIF

	RELEASE LNimpressao,LNimpressos,LNpercentual,LFsegue


	PUBLIC LNimpressao   	 && registro para impressao
	PUBLIC LNimpressos  	 && registros impressos
	PUBLIC LNpercentual 	 && percentual completado
    PUBLIC LFsegue      && continuidade da impressao

	wp_msg = "Processando ............."
	LFsegue = .t.
	LNregistro = RECNO()
   	IF NOT WEXIST("PRINSTAT")
   		ACTIVATE SCREEN
		DEFINE WINDOW prinstat ;
			FROM 2, 2 ;
			TO 9,58 ;
			FLOAT ;
			NOCLOSE ;
			NOMINIMIZE ;
			NONE ;
			TITLE "STATUS" COLOR SCHEME 1
   	ENDIF


RETURN(" ")



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3OC           UPIniciatermo VALID                
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   44     
*        Variable:            UPIniciatermo                      
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      36                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3oc     &&  UPIniciatermo VALID
#REGION 1
RETURN

FUNCTION UPIniciatermo   && AVANCO DO TERMOMETRO

	LFsegue  	= .T.
	LNregistro 	= RECNO()
    COUNT TO LNimpressao
	LNimpressos = 0
	GO LNregistro
RETURN(" ")		


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q1           UPEncerratermo VALID               
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   45     
*        Variable:            UPEncerratermo                     
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      37                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q1     &&  UPEncerratermo VALID
#REGION 1
RETURN

FUNCTION UPEncerratermo

    RELEASE WINDOW prinstat
	RELEASE LNimpressao, LNregistro, LNimpressos, LNpercentual
RETURN(" ")		


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q2           UPLimpaString VALID                
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   47     
*        Variable:            UPLimpaString                      
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      38                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3q2     &&  UPLimpaString VALID
#REGION 1
return
*---------------------------------------------------------------*

FUNCTION UPLimpaString
PARAMETERS PrmString
	*-------------------------------------------------------*
	PRIVATE LSstatus
	LSstatus = ""
	*-------------------------------------------------------*

	PRMString = chrtran(PRMString,"","C")       && 01
	PRMString = chrtran(PRMString,"","c")       && 02
	PRMString = chrtran(PRMString,"&","e")       && 03
	PRMString = chrtran(PRMString,"","-")       && 04
	PRMString = chrtran(PRMString,"","-")       && 05
	PRMString = chrtran(PRMString,"",'')        && 06
	PRMString = chrtran(PRMString,"",'')        && 07
	PRMString = chrtran(PRMString,"",'E')       && 08
	PRMString = chrtran(PRMString,"",'e')       && 09
	PRMString = chrtran(PRMString,"",'A')       && 10
	PRMString = chrtran(PRMString,"",'a')       && 11
	PRMString = chrtran(PRMString,"",'')        && 12
	PRMString = chrtran(PRMString,chr(0),'')     && 13
	PRMString = chrtran(PRMString,'"','')        && 14
	PRMString = chrtran(PRMString,'','A')        && 14


RETURN(PrmString)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q3           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   48     
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      39                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q3     &&  PADRAO VALID
#REGION 1
RETURN

FUNCTION UPFrmtaTempo   && Retorna diferenca em minutos entre horas e datas
	PARAMETERS PrmMinutos

	Lhora    = INT(PrmMinutos / 60)


    Lminutos = PrmMinutos - (Lhora * 60)


    LStempo  = str(Lhora,2) + ":" + str(Lminutos,2)

	LStempo  = CHRTRAN(LStempo," ","0")

RETURN(LStempo)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q4           GRLAlterarOrion VALID              
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL,     Record Number:   49     
*        Variable:            GRLAlterarOrion                    
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      40                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q4     &&  GRLAlterarOrion VALID
#REGION 1
RETURN

FUNCTION GRLAlterarOrion
PARAMETER PrmMotivo


	   * "APAGA"
	   * "SAVE"
	   * "REGRAVA"

    PRIVATE LSEmite_Fncr

	PRIVATE LSalias,LNrecAtual
	LSalias = ALIAS()



    LNrecAtual = recno()


    *--------------------------------------------------
    *  FUNCAO P/ TRATAMENTO INTEGRACAO DE DADOS COM ORION
    *--------------------------------------------------
    IF "DUPLICAT" $ DBF()


  	   =W_DEFPROC("EMPRESA.SPR")
	   LSEmite_Fncr = EMGetFieldValue(wp_empresa,"EMITE_FNCR")


       IF LSEmite_Fncr <> "S"   && USAR NOVA ROTINA XML
          RETURN(.T.)
       ENDIF









      *-- <<< Traduzir para >>>-------------------*
      *  	LSLinhaXML  = "CANCELAR"
      * 	LSLinhaXML  = "IMPRIMIR"
      *  	LSLinhaXML  = "REGISTRAR"
      *-------------------------------------------*

 	  =W_DEFPROC("DUPLICAT.SPR")
      DO CASE
        CASE PrmMotivo = "APAGA"

            =CRDuplNroExpDuplicata(empresa,duplicata,"CANCELAR")


        CASE PrmMotivo = "SAVE"

            =CRDuplNroExpDuplicata(empresa,duplicata,"REGISTRAR")

        CASE PrmMotivo = "REGRAVA"

            =CRDuplNroExpDuplicata(empresa,duplicata,"REGISTRAR")

      ENDCASE

    ENDIF

	IF !EMPTY(LSalias) AND USED(LSalias)
		SELECT &LSalias
	ENDIF

    GO LNrecAtual


RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q5           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:    3   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      41                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q5     &&  PADRAO VALID
#REGION 2
RETURN
FUNCTION UParqvisao         && atribui nome a arquivo de impressao
	IF TYPE("wl_arqtmp") = "C"
		wl_arqant = wl_arqtmp
	ENDIF
	wl_arqtmp = ""
	LNtmp     = 65		&& TABELA ASCII A = 65
	IF !UPabretmp("prt",2)
     	wp_arqname = wp_dirtmp+STRTRAN(str(nUsr,4)," ","0")+".REL"
	ELSE
     	wp_arqname = wp_dirtmp+wl_arqtmp+".REL"
	ENDIF
	IF TYPE("wl_arqant") = "C"
		wl_arqtmp = wl_arqant
	ENDIF
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q6           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:    4   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      42                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q6     &&  PADRAO VALID
#REGION 2
RETURN
FUNCTION  UPnometmp
  parameters cPrefix, cTparq
*  PRIVATE wl_arqtmp
  								* cTparq => 1 OU .F. = DBF
  								* cTparq => 2        = TXT OU OUTROS
  wl_arqtmp = " "
  IF !UPabretmp(cPrefix, cTparq)
	 RETURN("\TMP\SAIDA.TXT")
  ENDIF	
RETURN(wp_dirtmp+wl_arqtmp)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q7           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:    5   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      43                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q7     &&  PADRAO VALID
#REGION 2
RETURN

FUNCTION  UPabretmp		&& DEVE SER SUBSTITUIDA POR UPopentmp

  parameters cPrefix, cTparq
  								* cTparq => 1 OU .F. = DBF
  								* cTparq => 2        = TXT OU OUTROS
	PRIVATE ULdirtmp

	PRIVATE LSnomefile				&& PARA RETORNAR O NOME INDICADO

	PRIVATE LnmDbf



    IF TYPE("WP_ultNrotmp") <> "N"
    	PUBLIC WP_ultNrotmp   && NRO DO ULTIMO TMP GERADO
    	WP_ultNrotmp = 1
	ENDIF    	


    IF TYPE("WP_ultNmtmp") <> "C"
    	PUBLIC WP_ultNmtmp   && NOME DO ULTIMO TMP GERADO
    	WP_ultNmtmp = ""
	ENDIF    	


*------------------------------------------------
	IF EMPTY(wp_dirtmp)
		wp_dirtmp = SYS(5)+"\TMP\"
	ENDIF

    IF type("cTparq") $ "LU"   && LOGICO OU INEXISTENTE
		 cTparq = 1
    ENDIF	
    LFresulta = .f.

    LSnomefile  = ""


	*------------------------------------------*
	* MANUTENCAO TEMPORARIOS
	********************************************

     =UPDeltmp()

	*------------------------------------------*




	FOR LNtmp = 65 TO 90 STEP 1




		=UPNovoTmpNome(nUsr,wp_dirtmp,wl_arqtmp,LNtmp)


		
		DO CASE
			CASE cTparq = 1			&& ARQUIVO DBF
			
				*-------------------------------------------*

			    LSnomefile = wp_dirtmp + wl_arqtmp+".DBF"

				*-------------------------------------------*

***				WAIT WINDOW "Tmp ==> "+LSnomefile nowait

			
				IF !FILE(LSnomefile)
				    IF WP_ultNmtmp <> LSnomefile
				    	WP_ultNmtmp = LSnomefile
					    LFresulta = .t. && defaut nao fechamento da secao
						EXIT
					ENDIF
				ENDIF



				KEYBOARD "{ENTER}"


				CLEAR TYPEAHEAD
			CASE cTparq = 2			&& OUTROS ARQUIVOS OU TXT

				*-------------------------------------------*
			    LSnomefile = wp_dirtmp + wl_arqtmp+".REL"


				*-------------------------------------------*

				IF !FILE(LSnomefile)
				   LFresulta = .t. 		&& defaut nao fechamento da secao
				   EXIT
				ENDIF
				cTMP =  FOPEN("&wp_dirtmp"+"&wl_arqtmp"+".REL",1)
				IF cTMP > 0
				   =FCLOSE(cTMP)
				   LFresulta = .t. 		&& defaut nao fechamento da secao
				   EXIT
				ENDIF
 		ENDCASE
 		IF  LNtmp >= 89
 			LNtmp = 65
 		ENDIF

	ENDFOR
    KEYBOARD CHR(4)	
RETURN(LFresulta)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q8           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:    6   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      44                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q8     &&  PADRAO VALID
#REGION 2
RETURN

FUNCTION  UPopentmp
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [*****]   MODULO INDEPENDENTE				 *
	*------------------------------------------------------------*
	* OBJETIVO....: Retornar um nome para arquivo temporario
	*------------------------------------------------------------*
	* COMENTARIO..: Este modulo verifica se um nome pode ser uti-
	*		lizado e retorna por referencia o caminho e o alias
	*------------------------------------------------------------*
	* OBS........ : Exemp  sct1100
	*------------------------------------------------------------*
	* TABELAS....:
	*------------------------------------------------------------*
	* PARAMETROS..:
	*		LNdirtmp.......: Diretorio previsto p/ arq. temporario
	*		LSarquivo......: "" Usado no retorno
	*		LSalias........: Traz Parte fixa do nome (determinada
	*						no ponto de chamada
	*		LNtp_arq.......: Tipo de arq. que se deseja
	*		                 1 =>  ARQ. DBF
	*		                 2 =>  ARQ. TXT
	*------------------------------------------------------------*
	* RETORNO.....: Por Referencia em :
	*		LSarquivo......: Retorna o Nome do Arq. com Todo Caminho
	*		LSalias........: Retorna o Alias a ser usado p/ arq. tmp
	*------------------------------------------------------------*
	PARAMETERS LSdirtmp,LSarquivo,LSalias,LNtp_arq
	*------------------------------------------------
	PRIVATE LSnomearq				&& PARA RETORNAR O NOME INDICADO
	PRIVATE LSnomefile				&& PARA RETORNAR O NOME INDICADO


	PRIVATE LnmDbf
	
    IF TYPE("WP_ultNrotmp") <> "N"
    	PUBLIC WP_ultNrotmp   && NRO DO ULTIMO TMP GERADO
    	WP_ultNrotmp = 1
	ENDIF    	


    IF TYPE("WP_ultNmtmp") <> "C"
    	PUBLIC WP_ultNmtmp   && NOME DO ULTIMO TMP GERADO
    	WP_ultNmtmp = ""
	ENDIF    	
	

	IF EMPTY(LSdirtmp)
		LSdirtmp = SYS(5)+"\TMP\"	&& ASSUME UM VALOR DEFALT
	ENDIF
    IF type("LNtp_arq") $ "LU"   	&& LOGICO OU INEXISTENTE
		 LNtp_arq = 1
    ENDIF	
    LSnomearq = ""
    LSnomefile = ""

	*------------------------------------------*
	* MANUTENCAO TEMPORARIOS
	********************************************

     =UPDeltmp()

	*------------------------------------------*




	FOR LNtmp = 65 TO 90 STEP 1



		=UPNovoTmpNome(nUsr,wp_dirtmp,LSnomearq,LNtmp)
		LSdirtmp = wp_dirtmp



	
		DO CASE
			CASE LNtp_arq = 1			&& ARQUIVO DBF
				*-------------------------------------------*
				LSnomefile = LSdirtmp + LSnomearq+".DBF"
				
				IF USED(LSnomefile)
				    SELE &LSnomefile
					USE
				ENDIF

				
				*-------------------------------------------*

**				WAIT WINDOW "Tmp ==> "+LSnomefile nowait


				IF !FILE(LSnomefile)
				    IF WP_ultNmtmp <> LSnomefile
				    	WP_ultNmtmp = LSnomefile
					    LFresulta = .t. && defaut nao fechamento da secao
						EXIT
					ENDIF
				ENDIF
				

				
				KEYBOARD "{ENTER}"

				CLEAR TYPEAHEAD
			CASE LNtp_arq = 2			&& OUTROS ARQUIVOS OU TXT
				*-------------------------------------------*
				LSnomefile = LSdirtmp + LSnomearq+".REL"


			
			
				IF !FILE(LSdirtmp +LSnomearq+".REL")
				   EXIT
				ENDIF
				cTMP =  FOPEN("&LSdirtmp"+"&LSnomearq"+".REL",1)
				IF cTMP > 0
				   =FCLOSE(cTMP)
				   EXIT
				ENDIF
 		ENDCASE
	    LSnomearq = "" 					&& NOME INDICADO NAO ACEITO
   		IF  LNtmp >= 89
 			LNtmp = 65
 		ENDIF

	
	ENDFOR
	LSarquivo	=	LSdirtmp+LSnomearq	&& RETORNA O NOME COM O CAMINHO
	LSalias		=	LSnomearq
    KEYBOARD CHR(4)	

RETURN(LSarquivo)

*RETURN(LSnomearq)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Q9           NetArq VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:    7   
*        Variable:            NetArq                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      45                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3q9     &&  NetArq VALID
#REGION 2
RETURN

FUNCTION  NetArq
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [**]   MODULO DEPENDENTE DE VAR. GLOBAIS
	*						E EFEITO COLATERAL EM NETERR  		 *
	*------------------------------------------------------------*
	* OBJETIVO....: Intercambio entre rotinas novas apartire de
	*				30.08.99
	*------------------------------------------------------------*
	* COMENTARIO..: A aberturas por esta rotina devolvem valores
	*		numericos para as situacaoes de abertura para que a
	*		rotina chamadora trabalhe o retorno
	*------------------------------------------------------------*
	* OBS........ : Os valores de retorno permitem a rotina
	*			chamadora verificar se todos arquivos foram
	*			abertos somando-se os retornos se > 10.000 =>
	*			falha de arq
	*------------------------------------------------------------*
	* TABELAS....:
	*------------------------------------------------------------*
	* PARAMETROS..:
	*		LSarq..........: Nome do Arquivo a ser aberto ( Pode
	*						 conter a indicacao do diretorio
	*		LFmodo.........: Modo de Abertura do Arquivo
	*						 .T. => exclusivo ; .F. => compartilhado
	*------------------------------------------------------------*
	* RETORNO.....:	1		 =	Arquivo ja esta aberto
	*				2		 =	Arquivo aberto com sucesso
	*				>=100000 =	Falha na Abertura do  Arquivo
	*------------------------------------------------------------*
  	PARAMETERS  LSarq, LFmodo
	PRIVATE LFret
	IF	AT("\","&LSarq..dbf") = 0	&& nao houve solicitacao especifica
		IF USED(LSarq)
			IF 	LFmodo <> .F.	&& FOI SOLICITADO EXCLUSIVIDADE
	            cMsgm = ;
    	   		[Arquivo &cArq..dbf esta' aberto em outra area de trabalho]
			    wait cMsgm + [ <Enter>] window
		 		RETURN(100001)	&& PEDIDA EXCLUSIVIDADE DEVE FECHAR ANTES
			ELSE
				SELE &LSarq     && IMPEDE MULTIPLAS ABERTURAS
				RETURN(1)
			ENDIF
		ENDIF
	ENDIF
	LFret = NetUse(LSarq,LFmodo)
	

	IF LFret
		RETURN(2)
	ENDIF
RETURN(100001)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3QA           NetArqAgain VALID                  
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:    8   
*        Variable:            NetArqAgain                        
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      46                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3qa     &&  NetArqAgain VALID
#REGION 2
RETURN

FUNCTION  NetArqAgain
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [**]   MODULO DEPENDENTE DE VAR. GLOBAIS
	*						E EFEITO COLATERAL EM NETERR  		 *
	*------------------------------------------------------------*
	* OBJETIVO....: Intercambio entre rotinas novas apartire de
	*				30.08.99
	*------------------------------------------------------------*
	* COMENTARIO..: A aberturas por esta rotina devolvem valores
	*		numericos para as situacaoes de abertura para que a
	*		rotina chamadora trabalhe o retorno
	*------------------------------------------------------------*
	* OBS........ : Os valores de retorno permitem a rotina
	*			chamadora verificar se todos arquivos foram
	*			abertos somando-se os retornos se > 10.000 =>
	*			falha de arq
	*------------------------------------------------------------*
	* TABELAS....:
	*------------------------------------------------------------*
	* PARAMETROS..:
	*		LSarq..........: Nome do Arquivo a ser aberto ( Pode
	*						 conter a indicacao do diretorio
	*		LFmodo.........: Modo de Abertura do Arquivo
	*						 .T. => exclusivo ; .F. => compartilhado
	*------------------------------------------------------------*
	* RETORNO.....:	1		 =	Arquivo ja esta aberto
	*				2		 =	Arquivo aberto com sucesso
	*				>=100000 =	Falha na Abertura do  Arquivo
	*------------------------------------------------------------*
  	PARAMETERS  LSarq, LFmodo
	PRIVATE LFret
	IF	AT("\","&LSarq..dbf") = 0	&& nao houve solicitacao especifica
		IF USED(LSarq)
			IF 	LFmodo <> .F.	&& NAO FOI SOLICITADO EXCLUSIVIDADE
	            cMsgm = ;
    	   		[Arquivo &cArq..dbf esta' aberto em outra area de trabalho]
			    wait cMsgm + [ <Enter>] window
		 		RETURN(100001)	&& PEDIDA EXCLUSIVIDADE DEVE FECHAR ANTES
			ENDIF
		ELSE
			**** SELE &LSarq     && IMPEDE MULTIPLAS ABERTURAS
			**** RETURN(1)
		ENDIF
	ENDIF
	LFret = NetUse(LSarq,LFmodo)


	IF LFret
		RETURN(2)
	ENDIF
RETURN(100001)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3QE           NetUse VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:    9   
*        Variable:            NetUse                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      47                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3qe     &&  NetUse VALID
#REGION 2
RETURN

FUNCTION  NetUse
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [**]   MODULO DEPENDENTE DE VAR. GLOBAIS
	*						E EFEITO COLATERAL EM NETERR  		 *
	*------------------------------------------------------------*
	* OBJETIVO....: Abrir arquivos
	*------------------------------------------------------------*
	* COMENTARIO..: Abre Arq. verificando se os mesmos ja estao
	*		abertos e verificando erros de abertura tratados em
	*		neterr
	*------------------------------------------------------------*
	* OBS........ :
	*------------------------------------------------------------*
	* TABELAS....:
	*------------------------------------------------------------*
	* PARAMETROS..:
	*		LSarq..........: Nome do Arquivo a ser aberto ( Pode
	*						 conter a indicacao do diretorio
	*		LFmodo.........: Modo de Abertura do Arquivo
	*						 .T. => exclusivo ; .F. => compartilhado
	*------------------------------------------------------------*
	* RETORNO.....:	.T.		=> Arquivo aberto com sucesso
	*------------------------------------------------------------*
  	PARAMETERS  LSarq, LFmodo

	ON KEY LABEL F12    DO OBJ_CALC.SPR
	ON KEY LABEL CTRL-F8 DO UPprotege   && ATIVAR EM TODOS PROGRAMAS
	STORE .T. TO LFopen					&& INDICAR SUCESSO DA ABERTURA
										&& SET EM NETERR
	*---------------------------------------------------------------*
	LSarq  = UPPER(LSarq)				&& Padroniza nome de arquivo em maiuscala
    LSuni_dir	= "" 					&& Indica caminho definido apos verificacao
	LSnome_def  = "" 					&& Caminho e nome final


    LSuni_dir = UPobterPath((LSarq), (LFmodo))

    IF LSuni_dir = ""
  	 	RETURN(.F.)
  	ENDIF

	* LIMPAR ESTENSOES DE NO ME EM LS ARQ
    LSarq     = SUBS(LSarq,rat("\",LSarq)+1)
    LSarq     = STRTRAN(UPPER(LSarq),".DBF","")


	*-----< TESTE SE O ARQUIVO ESTA EM PROCESSO DE RECUPERACAO >-----*
  	*****************************************************************
  	* ATENCAO : Usar tres letras do diretorio do arquivo na extencao
  	*			  do arquivo de status impede que dois arquivos de nomes
  	*			  iguais em diretorios diferentes sejam confudidos na
  	*			  retomada da recuperacao o que poderia jogar os dados
  	*           de um encima do outro.
  	*****************************************************************

  	LNi_ext = AT("\",LSuni_dir,2) + 1
	IF LEN(LSuni_dir) < LNi_ext            && QUANDO O DIR. TIVER A FORMA
										   &&  "\TMP\" , por exemplo,
										   && ocorrera erro se tentar
										   && pegar caracteres
										   && SUBS(LSuni_dir,LNi_ext,3)
	  	LNi_ext = AT("\",LSuni_dir,1) + 1  && entao muda para nivel
	  	                                   && diretorio anterior
    ENDIF	

  	LSn_ext = "." + SUBS(LSuni_dir,LNi_ext,3)
  	LSfilestatus   = "\TMP\"+LSarq+LSn_ext
  	IF FILE(LSfilestatus)	&& ARQUIVO ESTA EM PRCESSO DE RECUPERACAO
  	  	=UPrecupera(CHRTRAN(LSuni_dir," ",""),LSarq)
		wait window "Erro arq em recuperacao: " +LSfilestatus + " <ENTER>"
  	 	RETURN(.F.)
  	ENDIF


	*----------------------------------------------------------------*
  	nErro = 0			&& retornar o codigo de erro
  	on error do NetErr
  	select 0
  	LSnome_def  = LSuni_dir + LSarq
  	if LFmodo
     	use &LSnome_def exclusive
  	else
    	use &LSnome_def AGAIN shared
  	endif
  	if nErro = 3 AND !LFmodo
  		*-------------------------------------------------------------*
  		* 	Se nao foi solicitado exclusividade a retina nao considera
  		* erro e seleciona a area do arquivo
  		*-------------------------------------------------------------*
		LNnetpos = RAT("\",LSarq)+1
	 	LSnetalia = SUBS(LSarq,LNnetpos)
	 	SELE &LSnetalia
	 	ON ERROR DO UPerrosys
	 	return(.t.)
 	endif
  	if nErro = 15
  		=UPrecupera(LSuni_dir,LSarq)
        IF !("\TMP\" $ LSnome_def)
			wait window "Erro abertura: " +LSnome_def + " <ENTER>"
		ENDIF
  	 	RETURN(.F.)
  	ENDIF
  	IF !LFopen
        IF !("\TMP\" $ LSnome_def)
			wait window "Erro abertura: " +LSnome_def + " <ENTER>"
		ENDIF
  		RETURN(.F.)
  	ENDIF
	set index to &LSnome_def
  	IF !LFopen
        IF !("\TMP\" $ LSnome_def)
			wait window "Erro abertura: " +LSnome_def + " <ENTER>"
		ENDIF
  		RETURN(.F.)
  	ENDIF
	ON ERROR DO UPerrosys
  	LSestru = "\SCGC\RECUPERA\"+SUBS(LSarq,RAT("\",LSarq,1)+1)+".dbf"
  	IF !FILE(LSestru)		
		IF !("\TMP\" $ UPPER(LSnome_def))
	  		COPY STRU TO &LSestru with CDX
	 	ENDIF
  	ENDIF
  	if tag(1) <> ""
    	VLnetctag = tag(1)
     	set order to  tag &VLnetctag
  	endif
  	go top
return(.t.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3QL           UPPath VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   10   
*        Variable:            UPPath                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      48                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3ql     &&  UPPath VALID
#REGION 2
RETURN

FUNCTION  UPobterPath
  	PARAMETERS  LSarq, LFmodo
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [****]   MODULO DEPENDENTE DE VAR. GLOBAIS
	*						E EFEITO COLATERAL EM NETERR  		 *
	*------------------------------------------------------------*
	* OBJETIVO....: Abrir arquivos
	*------------------------------------------------------------*
	* COMENTARIO..: Abre Arq. verificando se os mesmos ja estao
	*		abertos e verificando erros de abertura tratados em
	*		neterr
	*------------------------------------------------------------*
	* OBS........ :
	*------------------------------------------------------------*
	* TABELAS....:
	*------------------------------------------------------------*
	* PARAMETROS..:
	*		LSarq..........: Nome do Arquivo a ser aberto ( Pode
	*						 conter a indicacao do diretorio
	*		LFmodo.........: Modo de Abertura do Arquivo
	*						 .T. => exclusivo ; .F. => compartilhado
	*------------------------------------------------------------*
	* RETORNO.....:	.T.		=> Arquivo aberto com sucesso
	*------------------------------------------------------------*

	ON KEY LABEL F12    DO OBJ_CALC.SPR
	ON KEY LABEL CTRL-F8 DO UPprotege   && ATIVAR EM TODOS PROGRAMAS
	STORE .T. TO LFopen					&& INDICAR SUCESSO DA ABERTURA
										&& SET EM NETERR
	*---------------------------------------------------------------*
	LSarq  = UPPER(LSarq)				&& Padroniza nome de arquivo em maiuscala
    LSuni_dir	= "" 					&& Indica caminho definido apos verificacao
	LSnome_def  = "" 					&& Caminho e nome final
	*---------------------------------------------------------------*
	*  Procedimento para determinad o endereco pra abrir arquivo
	*---------------------------------------------------------------*
	*  PESQUISA : ENTRES DIRETORIOS WP_DIRDAT, WP_DITTMP, WP_DIRACEL
	*  			  ONDE O ARQUIVO FOR ENCONTRADO SERA ASSUMIDO. COMES-
	*			  SANDO PELAS UNIDADES ALTERNATIVAS
	*---------------------------------------------------------------*
	IF	AT("\",LSarq) = 0	&& nao houve solicitacao especifica
		DO CASE
				CASE   TYPE("wp_dirtmp")= "C" AND !EMPTY(wp_dirtmp) ;
		 				AND FILE(wp_dirtmp + "&LSarq..dbf")
							LSuni_dir	= CHRTRAN(wp_dirtmp," ","")
							        &&=> assume dir de TEMPORARIO
				OTHERWISE     && ALTERNA ENTRE COMUM E DADOS ESPECIFICOS
			 			LNarq = Ascan(vArqpad,"&LSarq") && VERIFICA PREVISAO NO DIR. COMUM
						IF LNarq > 0						
				 			LNarq = ASUBSCRIPT(varqpad,LNARQ,1)
							LSuni_dir	= CHRTRAN((vArqpad(LNarq,2))," ","")
											  && abrir em diretorio comum
			 			ELSE
							IF TYPE("wp_dirdat") <> "C" OR EMPTY(wp_dirdat)
								wp_dirdat = ""
							ENDIF							
	
			     			LSuni_dir	= CHRTRAN((wp_dirdat)," ","")
			     						  && Assume de dados
			 			ENDIF
	  	ENDCASE
	ELSE
        LSuni_dir  = SUBS(LSarq,1,rat("\",LSarq))
        LSarq     = SUBS(LSarq,rat("\",LSarq)+1)
        LSarq     = STRTRAN(UPPER(LSarq),".DBF","")
	ENDIF
	*---------------------------------------------------------------*
    LSuni_dir	= UPPER(LSuni_dir)
	LSnome_def  = UPPER(LSnome_def)

	IF !FILE(chrtran(LSuni_dir," ","") + LSarq + ".dbf")
   		LSuni_dir  = wp_dirdat			&& qtdo nao acha assume dir dados
     	if ! file(chrtran(LSuni_dir," ","") + LSarq + ".dbf")
	     	wait window [Arq. &LSuni_dir &LSarq..dbf nao Encontrado <enter>]
	     	return ("")
	 	endif
  	ENDIF
return(LSuni_dir)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3QS           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   11   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      49                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3qs     &&  PADRAO VALID
#REGION 2
RETURN

FUNCTION UP_fecha
  	PARAMETERS LSArq, LNabertura
    PRIVATE LnmDbf
    PRIVATE LFRESULT


	*------------------------------------------------------------*
	* COMENTARIO..: A aberturas por esta rotina devolvem valores
	*		numericos para as situacaoes de abertura para que a
	*		rotina chamadora trabalhe o retorno
	*------------------------------------------------------------*
  	IF TYPE("LNabertura") $ "UL"
		LNabertura = 2
  	ENDIF	
	LFRESULT = .F.

  	IF USED(LSarq) AND LNabertura > 1

    	SELE &LSarq
        LnmDbf = UPPER(DBF())
        IF "\TMP\" $ LnmDbf
        	USE
*        	DELETE FILE &LnmDbf
*        	LnmDbf = STRTRAN(LnmDbf,".DBF",".CDX")
*        	DELETE FILE &LnmDbf

    		LFRESULT = .T.
    		
		ELSE
	    	USE
    		LFRESULT = .T.
    	ENDIF
  	ENDIF
  	
RETURN(LFRESULT)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3QX           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   12   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      50                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3qx     &&  PADRAO VALID
#REGION 2
RETURN

*----------------------------------------------------------------*
* objetivo : verifica mensagem de erro para funcao NetUse()      *
*----------------------------------------------------------------*
PROCEDURE  NetErr
   nErro = Error()
   IF nErro = 3  AND !LFmodo
		return
 		* nao se carac. erro pois nao solicitou exclusividade	
		*    cMsgm = "Arquivo "+LSarq+".dbf  esta em Uso"
   ENDIF
   do case
      case nErro = 3
		   cMsgm = "Arquivo "+LSarq+".dbf  esta em Uso"
      case nErro = 6
           cMsgm = "Muitos Arquivos Abertos"
      case nErro = 15
           cMsgm = LSarq+".dbf  Nao e um Arquivo DBF"
      case nErro = 19
           cMsgm = "Arquivo de Indice  "+LSarq+".cdx Imperfeito"
      case nErro = 23
           cMsgm = "Expressao do Indice muito longa"
      case nErro = 24
           cMsgm = "Alias sendo utilizado por outro arquivo"
      case nErro = 26
           cMsgm = "Arquivo "+LSarq+".dbf  nao Ordenado"
      case nErro = 43
           cMsgm = "Memoria Insuficiente"
      case nErro = 91
           cMsgm = "Arquivo "+LSarq+".dbf  nao Carregado"
      case nErro = 108
           cMsgm = "Arquivo "+LSarq+".dbf  esta em uso por outro usuario"
      case nErro = 114
           cMsgm = "Recrie o Indice "+LSarq+".CDX"
      case nErro = 1012
           cMsgm = "Erro de Memoria do SO"
      case nErro = 1101
           cMsgm = "Nao consigo abrir arquivo "+LSarq+".dbf "
      case nErro = 1111
           cMsgm = "Descritor de arquivo invalido p/"+LSarq+".dbf "
      case nErro = 1117
           cMsgm = "Chave p/"+LSarq+".dbf  com comprimento errado"
      case nErro = 1124
           cMsgm = "Chave muito longa p/"+LSarq+".dbf "
      case nErro = 1462
           cMsgm = "Erro de consistencia interna no arquivo "+LSarq+".dbf "
      case nErro = 1683
           cMsgm = "Marca (Tag) de indice nao encontrada em  "+LSarq+".cdx"
      case nErro = 1684
           cMsgm = ;
      		"Marca (Tag) de indice deve ser especificada p/ "+LSarq+".cdx"
      case nErro = 1705
           cMsgm = "Acesso ao arquivo "+LSarq+".dbf  negado"
      case nErro = 1708
           cMsgm = ;
           "Arquivo "+LSarq+".dbf  esta aberto em outra area de trabalho"
      case nErro = 1718
           cMsgm = "Arquivo "+LSarq+".dbf  aberto somente para leitura"
      case nErro = 1721
           set step on
           cMsgm = "Todas areas de trabalho em uso"
      OtherWise
		   cMsgm = "Erro indefinido "+LSarq +" - "+ STR(nErro,4)
   EndCase
   store .f. to LFOpen
   wait cMsgm + " <Enter> " window
return



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3R3           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   13   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      51                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3r3     &&  PADRAO VALID
#REGION 2
RETURN
*******************************************************************
* RECUPERACAO DE ARQUIVOS
*                      EX: =UPrecupera("\fpd26\prog\","cliente")
*
* DIRETORIOS FIXOS
*					 \SCGC\RECUPERA\  (ESTRUTURAS VAZIAS)		
*					 \TMP\			  (DIRETORIO TEMPORARIO)
*******************************************************************
FUNCTION UPrecupera
PARAMETERS LSpat,LSdbf



   IF 1 = 1
      RETURN
   ENDIF

   *************************************************************
   * EM 16/10/2014 DESATIVEI A RECURACAO DE ARQ POR PROBLEMAS COM
   * NOTAITE QUE NAO IDENTIFICAMOS AS CAUSAS.
   * ACHAMOS MELHOR NAO FAZER A RECUPERACAO AUTOMATICA POR TALVEZ
   * ESTAR SENDO A FONTE DOS PROBLEMAS  (SERGIO/NELSON)
   *************************************************************



   PRIVATE LNheader,LNrecsize,lErro
   PRIVATE LSfiledanificado, LNdanif,LNtamdanif
   PRIVATE LSfilerecuperado, LNrecup
   PRIVATE LSfilestatus  , LSstatus, LNstatus
   PRIVATE LSfileestru
   PRIVATE LNlido,LNler,LNreg,LSchar
   PRIVATE LSorigfie,LSdestfie


   LSdbf = ALLTRIM(LSdbf)
   LSpat = ALLTRIM(LSpat)

   DO OBJ_ALER.SPR WITH ;
		   "Nao foi Possivel Abrir o Arquivo "+LSpat+LSdbf+CHR(13)+;
		   "Tecle <ENTER> e Responda a Confimacao do Proceso de Recuperacao."+;
		   CHR(13)+CHR(13)+ "   <ENTER>  "

   IF !fox_alert('Confirma Recuperar '+LSdbf+' ?')
      return
   endif

   lErro=.f.
   on error store .t. to lErro
   select 0
   use \SCGC\RECUPERA\&LSdbf
   LSfileestru = "\SCGC\RECUPERA\"+LSdbf+".dbf"
   on error
   if lErro
      DO OBJ_ALER.SPR WITH ;
		   "Nao Existe Estrutura de Parametro da Recuperacao em "+CHR(13)+;
		   " \SCGC\RECUPERA\"+LSdbf+CHR(13)+;
		   " Solicite Colocacao da Estrutura para Prosseguir."+;
		   CHR(13)+CHR(13)+ "   <ENTER>  "
      return
   endif
   LNheader	= HEADER()
   LNrecsize= RECSIZE()
   USE

   LSfiledanificado=LSpat+LSdbf+'.DBF'
   LNdanif    =fopen(LSfiledanificado,0)
   LNtamdanif =fseek(LNdanif,0,2)

   if LNdanif<0 or LNtamdanif<=0
      =fclose(LNdanif)
      wait 'ERRO abertura arquivo <Enter>' window
      return
   endif


*-----< TESTE SE O ARQUIVO ESTA EM PROCESSO DE RECUPERACAO >-----*
  *****************************************************************
  * ATENCAO : Usar tres letras do diretorio do arquivo na extencao
  *			  do arquivo de status impede que dois arquivos de nomes
  *			  iguais em diretorios diferentes sejam confudidos na
  *			  retomada da recuperacao o que poderia jogar os dados
  *           de um encima do outro.
  *****************************************************************
	
   LNi_ext = AT("\",LSpat,2) + 1
   LSn_ext = "." + SUBS(LSpat,LNi_ext,3)

   LSrecuperado   = "\TMP\"+LSdbf+'.REC'   && ARQUIVO TXT DE RECUPERACAO
   LSfilestatus   = "\TMP\"+LSdbf+LSn_ext  && ARQUIVO TXT DE STATUS

   IF !FILE(LSfilestatus)
		LNstatus = fcreate(LSfilestatus)	
		LSstatus = "1"					&& GERANDO ARQ TEXTO
   ELSE
	    LNstatus = fopen(LSfilestatus,0)
		LSstatus = FGETS(LNstatus,1)
   ENDIF
   IF 	EMPTY(LSstatus)
		LSstatus = "0"					&& GERANDO ARQ TEXTO
   ENDIF

   *****************************************************************
   * VALORES P/ LSstatus
   *                    1-   "GERANDO TEXTO"
   *					2-   "APAGANDO ARQ. DANIFICADO"
   *					3-	 "COPIANDO ESTRUTURA NOVA "
   *					4-	 "TRANSFERINDO ARQ. TEXTO " (APPEND)
   *					5-	 "APAGANDO ARQ. TEXTO     "
   *****************************************************************
   LNrecup 			=fcreate(LSrecuperado)

   if LNrecup<0
      =fclose(LNrecup)
      =fclose(LNstatus)
      wait 'ERRO cria눯o arquivo tempor쟲io <Enter>' window
      return
   endif

   *************************************************************
   * STATUS = 1  = > GERANDO ARQ. TEXTO
   *************************************************************
	IF LSstatus $ "01"				&& CONCLUIDO OUU GERANDO TEXTO
   		=FSEEK(LNstatus,0,0)
		=FWRITE(LNstatus,"1")		&& GERANDO ARQ TEXTO
		LSstatus = "1"
	    *************************************************************
   		* DESCARTANDO CABECALHO DE DADOS
        *************************************************************
 	    =fseek(LNdanif,0,0) && move ponteiro p/bof

   		LNlido = 0
   		LNler  = 1
		
		LSchar = ""
   		do while !feof(LNdanif)

			LNlido = LEN(LSchar)

     		wait 'Eliminando Cabe놹lho...'+str(LNlido)+' <Esc> Pausa' window nowait
      		if inkey()=27
         		wait '<Enter> Continua  <Esc> Pausa' window nowait
         		if inkey(0)=27
            		exit
         		endif
      		endif
			**********************************************************************
			* 	  Dois teste sao usados para encerrar o descarte do cabecalho
			*
			* 	1-	Testa se foi lida uma qtde de caracteres = ao tamanho infor_
			*		mado no cabecalho.
			*	2-	Alguns arquivos possuem registro do tipo MEMO o que retorna
			*		um tamanho de cabecalho maior que o CABECALHO DE DADOS REAL
			*		neste caso a leitura e interrompida pela sequencia de controle
			*		do registro
			*
			* 	A sequencia de testes verifica se foi encontrada uma sequecia de
			* de tres caracteres que se encerra com o controlador de registro
			* excluido (32=" "  ou 42="*"). Quando a sequencia e localizada o arq.
			* e posicionado antes do caracter de controle de exclusao para proceder
			* a recomposicao
			**********************************************************************

      		LSchar1 = FREAD(LNdanif,1)
			IF ASC(LSchar1) = 13
	      		LSchar  = LSchar + LSchar1
				IF LEN(LSchar) >= LNheader	
					EXIT
				ENDIF
	      		LSchar1 = FREAD(LNdanif,1)
				IF ASC(LSchar1) = 10
		      		LSchar  = LSchar + LSchar1
					IF LEN(LSchar) >= LNheader	
						EXIT
					ENDIF
		      		LSchar1 = FREAD(LNdanif,1)
					IF ASC(LSchar1) = 32 OR ASC(LSchar1) = 42
						EXIT										
					ELSE
			      		LSchar  = LSchar + LSchar1
					ENDIF
				ELSE
		      		LSchar  = LSchar + LSchar1
				ENDIF
			ELSE
	      		LSchar  = LSchar + LSchar1
			ENDIF
			IF LEN(LSchar) >= LNheader	
				EXIT
			ENDIF
   		enddo
 	    =fseek(LNdanif,0,0) && move ponteiro p/bof
 	    =fseek(LNdanif,LEN(LSchar),0) && move pont. p/ inicio do registro
   		if lastkey()=27
      		=fclose(LNdanif)
      		=fclose(LNrecup)
      		=fclose(LNstatus)
      		wait 'Processamento Interrompido <Enter>' window
      		return
   		endif
   		*************************************************************
   		* DESCARTANDO CABECALHO DE DADOS
   		*************************************************************
   		LNReg=0
   		LNlido = 0
   		LNler  = 254
   		do while !feof(LNdanif)
      		wait 'Reconstruindo Registros...'+str(LNreg)+' <Esc> Pausa' window nowait
      		if inkey()=27
         		wait '<Enter> Continua  <Esc> Pausa' window nowait
         		if inkey(0)=27
            		exit
         		endif
      		endif

	  		IF LNrecsize < LNlido + LNler
	  	 		LNler =  LNrecsize - LNlido
	  		ENDIF
      		LSchar = FGETS(LNdanif,LNler)

	  		IF LNlido = 0 AND !EMPTY(LSchar)
		 		IF LEFT(LSchar,1) = "*"		&& DELETADO
					LSchar = ""
				ELSE
			  		LSchar = SUBS(LSchar,2,LNler)
		 		ENDIF
	  		ENDIF

      		LNlido = LNlido + 254
      		if LNlido >= LNrecsize
         		=fputs(LNrecup,LSchar,LNler)
	     		LNlido = 0
	  	 		LNler  = 254
        		LNReg=LNReg+1
	  		ELSE
		 		IF !EMPTY(LSchar)
            		=fwrite(LNrecup,LSchar,LNler)
		 		ENDIF
	  		ENDIF	
   		enddo
   		if lastkey()=27
      		wait 'Processamento interrompido pelo usu쟲io <Enter>' window
   		    =fclose(LNdanif)
   		    =fclose(LNrecup)
            =fclose(LNstatus)
      		return
   		endif
   ENDIF
   =fclose(LNdanif)
   =fclose(LNrecup)
   *************************************************************
   * STATUS = 2  = > APAGANDO ARQ. DANIFICADO
   *************************************************************
	
   IF LSstatus $ "012"			
   		=FSEEK(LNstatus,0,0)
		=FWRITE(LNstatus,"2")	
		LSstatus = "2"
	    wait 'Eliminando arquivo com defeito...' window nowait
		***************************************
	    lErro=.f.
   		on error store .t. to lErro
		LSorigfile  = LSpat+LSdbf+".dbf"
		IF FILE(LSorigfile)
	   		delete file &LSorigfile
		ENDIF
		IF lErro
	   		on error
			LSstatus = "2"
	        DO OBJ_ALER.SPR WITH ;
		   		"O usuario logado no Sistema Operacional Nao Possui "+;
		   		"Acesso Para Alterar o Arq."+LSfiledanificado
		   	=fclose(LNstatus)
      		return
		ENDIF
		***************************************
	    lErro=.f.
   		on error store .t. to lErro
		LSorigfile  = LSpat+LSdbf+".fpt"
		IF FILE(LSorigfile)
	   		delete file &LSorigfile
		ENDIF
		IF lErro
	   		on error
			LSstatus = "2"
	        DO OBJ_ALER.SPR WITH ;
		   		"O usuario logado no Sistema Operacional Nao Possui "+;
		   		"Acesso Para Alterar o Arq."+LSfiledanificado
		   	=fclose(LNstatus)
      		return
		ENDIF
		***************************************
	    lErro=.f.
   		on error store .t. to lErro
		LSorigfile  = LSpat+LSdbf+".cdx"
		IF FILE(LSorigfile)
	   		delete file &LSorigfile
		ENDIF
		IF lErro
	   		on error
			LSstatus = "2"
	        DO OBJ_ALER.SPR WITH ;
		   		"O usuario logado no Sistema Operacional Nao Possui "+;
		   		"Acesso Para Alterar o Arq."+LSfiledanificado
		   	=fclose(LNstatus)
      		return
		ENDIF
		***************************************
	    on error
   ENDIF
   *************************************************************
   * STATUS = 3  = > COPIANDO NOVA ESTRUTURA
   *************************************************************
   IF LSstatus $ "23"			
   		=FSEEK(LNstatus,0,0)
		=FWRITE(LNstatus,"3")	
		LSstatus = "3"
	    wait 'Copiando novo arquivo para local de trabalho...' window nowait
	    lErro=.f.
   		on error store .t. to lErro
   		copy file &LSfileestru to &LSfiledanificado
		IF lErro
			LSstatus = "2"
	        DO OBJ_ALER.SPR WITH ;
		   		"O usuario logado no Sistema Operacional Nao Possui "+;
		   		"Acesso Para Alterar o Arq."+LSfiledanificado
		   	=fclose(LNstatus)
      		return
		ENDIF
		***************************************
	    lErro=.f.
   		on error store .t. to lErro
		LSorigfile  = "\SCGC\RECUPERA\"+LSdbf+".dbf"
		LSdestfile  = LSpat+LSdbf+".dbf"
   		copy file &LSorigfile to &LSdestfile
		***************************************
		IF lErro
	   		on error
			LSstatus = "2"
	        DO OBJ_ALER.SPR WITH ;
		   		"O usuario logado no Sistema Operacional Nao Possui "+;
		   		"Acesso Para Alterar o Arq."+LSfiledanificado
		   	=fclose(LNstatus)
      		return
		ENDIF
		***************************************
	    lErro=.f.
   		on error store .t. to lErro
		LSorigfile  = "\SCGC\RECUPERA\"+LSdbf+".fpt"
		LSdestfile  = LSpat+LSdbf+".fpt"
		IF FILE(LSorigfile)
	   		copy file &LSorigfile to &LSdestfile
		ENDIF
		IF lErro
	   		on error
			LSstatus = "2"
	        DO OBJ_ALER.SPR WITH ;
		   		"O usuario logado no Sistema Operacional Nao Possui "+;
		   		"Acesso Para Alterar o Arq."+LSfiledanificado
		   	=fclose(LNstatus)
      		return
		ENDIF
		***************************************
	    lErro=.f.
   		on error store .t. to lErro
		LSorigfile  = "\SCGC\RECUPERA\"+LSdbf+".cdx"
		LSdestfile  = LSpat+LSdbf+".cdx"
		IF FILE(LSorigfile)
	   		copy file &LSorigfile to &LSdestfile
		ENDIF
		IF lErro
	   		on error
			LSstatus = "2"
	        DO OBJ_ALER.SPR WITH ;
		   		"O usuario logado no Sistema Operacional Nao Possui "+;
		   		"Acesso Para Alterar o Arq."+LSfiledanificado
		   	=fclose(LNstatus)
      		return
		ENDIF
		***************************************
	    on error
   ENDIF
   *************************************************************
   * STATUS = 4  = > COPIANDO NOVA ESTRUTURA
   *************************************************************
   IF LSstatus $ "34"			
   		=FSEEK(LNstatus,0,0)
		=FWRITE(LNstatus,"4")	
		LSstatus = "4"
   		wait 'Transferindo dados para novo arquivo...' window nowait
   		select 0
   		use &LSfiledanificado
		SET TALK ON
   		IF type("deletado") = "L"
	   		append from &LSrecuperado FOR deletado <> .t. type sdf
		ELSE
	   		append from &LSrecuperado type sdf
   		ENDIF
		SET TALK OFF
   		use
   ENDIF
   *************************************************************
   * STATUS = 5  = > CONCLUIDO
   *************************************************************
   IF LSstatus $ "4"			
   		=FSEEK(LNstatus,0,0)
		=FWRITE(LNstatus,"5")	
   		****  delete file &LSrecuperado
	    wait 'Arquivo '+LSfiledanificado+' recuperado com sucesso <Enter>' window
   ENDIF
   =fclose(LNstatus)
    lErro=.f.
	on error store .t. to lErro
	delete file &LSfilestatus
	on error
return


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3RF           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   14   
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      52                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3rf     &&  padrao VALID
#REGION 2
RETURN

FUNC UPtratachv	&& critica as operacoes  de BUSCA // EDICAO // LANCAMENTO;
		em campos de chave
  wp_msg = ''
  DO CASE
	CASE isreading
		IF LASTKEY() = 27 OR LASTKEY() = 15
 			CLEAR TYPEAHEAD
			 ON KEY LABEL ESCAPE	KEYBOARD "{END}"
		  	 KEYBOARD "{ESCAPE}"
			 RETURN(.T.)
		ENDIF
		CLEAR TYPEAHEAD
		IF found()
 			CLEAR TYPEAHEAD
			 ON KEY LABEL ESCAPE	KEYBOARD "{END}"
		  	 KEYBOARD "{ESCAPE}"
			 RETURN(.T.)
		ENDIF
		wp_msg = 'Registro nao Localizado........'
		RETURN(.F.)
	CASE isadding
		IF found()
	  	 	 wp_msg = 'Regisrto ja Cadastrado.........'
			 RETURN(.F.)
		ENDIF
		RETURN(.T.)
	CASE isediting
		IF !FOUND()
		     IF rebloq()
				 RETURN(.T.)
			 ELSE
		  	 	 wp_msg = 'Nao foi possivel rebloquear registro.  '+;
		  	 	  		'Cancele a Edicao.'
				 RETURN(.F.)
			 ENDIF
		ENDIF
		IF FOUND() AND RECNO() = wp_record
		     IF rebloq()
				 RETURN(.T.)
			 ELSE
		  	 	 wp_msg = 'Nao foi possivel rebloquear registro.  '+;
		  	 	  		'Cancele a Edicao.'
				 RETURN(.F.)
			 ENDIF
		ENDIF
		IF FOUND() AND RECNO() <> wp_record
		     =rebloq()
	 		 wp_msg = 'Registreo ja Cadastrado..'
			 RETURN(.F.)
		ENDIF
	     =rebloq()
		wp_msg = 'LEITURA INDEFIDA. VER SUPORTE..........'
		RETURN(.F.)     && INDEFINIDO
ENDCASE
RETURN(.F.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3RM           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   15   
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      53                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3rm     &&  padrao VALID
#REGION 2
RETURN

FUNCTION REBLOQ
    GO wp_record
	IF RLOCK()
       RETURN .t.
    ELSE
	   WAIT WINDOW C_NOLOCK
*       KEYBOARD "{ESCAPE}"
       KEYBOARD "{DEL}"
	ENDIF
RETURN .F.



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3RU           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   16   
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      54                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3ru     &&  padrao VALID
#REGION 2
RETURN

FUNCTION reglock
    PARAMETERS LFloop
	PRIVATE LFclearms	&& indica a intensao de apagar menssagem
	PRIVATE LNctrproces
	LFclearms = .f.		
    DO CASE
		CASE LFloop     && .T. SAIR SO QUANDO BLOQUEAR
			CLEAR TYPEAHEAD
			SET REPROCESS TO 3
			DO WHILE .T.
	 			IF RLOCK()
					EXIT
				ELSE
					LFclearms = .t.	&& indica a intensao de apagar menssagem
					WAIT WINDOW C_NOLOCK NOWAIT
				ENDIF
    		ENDDO
*			SET REPROCESS TO AUTOMATIC
		OTHERWISE      && SAIR QUANDO BLOQ. OU TECLAR ALGO
			CLEAR TYPEAHEAD
			SET REPROCESS TO 1
			LNctrproces = 1
			DO WHILE !CHRSAW()
				IF RLOCK()
					EXIT
 				ELSE
					IF LNctrproces > 3		&& COMECAR
						LFclearms = .t.	&& indica a intensao de apagar menssagem
 						WAIT WINDOW C_NOLOCK+" Tecle <ESC> " NOWAIT
					ENDIF
				ENDIF
				LNctrproces = LNctrproces + 1
			ENDDO
*			SET REPROCESS TO AUTOMATIC
	ENDCASE

	CLEAR TYPEAHEAD
	IF LFclearms
		KEYBOARD CHR(4)
		=INKEY(0)
		CLEAR TYPEAHEAD
	ENDIF

RETURN(LOCK())



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3S0           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   17   
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      55                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3s0     &&  padrao VALID
#REGION 2
RETURN

FUNCTION ADIREG
    PARAMETERS LFloop
		ON ERROR
		SET REPROCESS TO 3
        APPEND BLANK
		ON ERROR DO UPerrosys
        =REGLOCK(.T.)
RETURN(.T.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3S7           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   18   
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      56                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3s7     &&  padrao VALID
#REGION 2
RETURN

PROCEDURE edithand
	PARAMETER m.paction
	=W_DEFPROC("rotinas.spr")

	PRIVATE LSalias
	LSalias = ALIAS()
	

	*****  permitem o controle da alteracao de registros **
	m.dtregis = DATE()			
	m.hregis  = TIME()
	m.usrregis= nUsr
	m.deletado= .f.
	********************************************************
	DO CASE
		CASE m.paction = 'ADD'
			SCATTER MEMVAR MEMO BLANK
			wm_nomindicado = space(60)
		CASE m.paction = 'SAVE'
			IF "CLIENTES.DBF" $ UPPER(DBF())
				=W_DEFPROC("clientes.spr")
				=CLGrvControleCredito(	m.cliente, ;
										0,;
										m.credito,;
										m.usrregis)
				SELE &LSalias
			ENDIF
    	     =ADIREG()
			GATHER MEMVAR MEMO

	 	CASE m.paction = 'CANCEL'
			=vai_para()      && posiciona WP_RECORD
		CASE m.paction = 'REGRAVA'


			DO CASE

				CASE  "CLIENTES.DBF" $ UPPER(DBF())

					=W_DEFPROC("clientes.spr")
					=CLGrvControleCredito(	m.cliente, ;
						&LSalias .credito,	m.credito,;
										m.usrregis)
					SELE &LSalias

				CASE  "CLIENC.DBF" $ UPPER(DBF())
					=GRLogClienc()
					SELE &LSalias
				CASE ALIAS() = "SPEDITE"
					LFLD = SET("FIELDS")
					SET FIELDS OFF
					IF 	PEDITE.QTDE < PEDITE.QTDETR+PEDITE.QTDEATD
					    DO OBJ_ALER.SPR WITH ;
			   		" Esta havendo um Tratamento errado p/ QTDE EM PEDIDO"
						wp_msg = 'Manutencao de Sistema...'
						BTMP   =  'usuario.master '
						LNusr_ret = 0
						DO WHILE LNusr_ret = 0
							DO obj_prmt.SPR WITH   wp_msg , Btmp
							IF LNusr_ret <>  0
								LSmsg  = "Ativar PASSO ? "
								IF fox_alert(LSmsg)
									SET STEP ON
								ENDIF
								EXIT
							ENDIF
						ENDDO
					ENDIF
					SET FIELDS  &LFLD

				CASE "ORCATMP.DBF" $ UPPER(DBF())  AND ;
					TYPE("ORCATMP.CODIGO") <> "U"  AND ;
					TYPE("ORCATMP.CLASSIFICA") <> "U" AND ;
					(m.codigo <> orcatmp.codigo AND ;
					 m.classifica = orcatmp.classifica)
	
				    DO OBJ_ALER.SPR WITH ;
			   		"Os dados do Orcamento Estao inconsistentes...";
			   		 +chr(13)+"   em ROTINA DE REGRAVACAO "

					wp_msg = 'Manutencao de Sistema...'
					BTMP   =  'usuario.master '
					LNusr_ret = 0
					DO WHILE LNusr_ret = 0
						DO obj_prmt.SPR WITH   wp_msg , Btmp
						IF LNusr_ret <>  0
							LSmsg  = "Ativar PASSO ? "
							IF fox_alert(LSmsg)
								SET STEP ON
							ENDIF
							EXIT
						ENDIF
					ENDDO
					m.codigo = orcatmp.codigo && forca a correcao
			ENDCASE
    	    =REGLOCK(.T.)			&& P/ CONFIRMAR O BLOQUEIO PREVIO
									&& ESTAVAM ACONTECENDO ATTEMP TO LOCK
			GATHER MEMVAR MEMO
		CASE m.paction = 'APAGA'

			*-----------------------------------------------------------*
			*  Foi Detectada a Exclusao de Orcamentos (OPERAO PROIBIDA)
			* no sistema por violar o controle de OSI. A trava a seguir
			* foi montada para detectar a falha que esta provocando a
			* exclusao
			*-----------------------------------------------------------*
			
			IF ALIAS() = "ORCAMENT"
				DO OBJ_ALER.SPR WITH ;
					"***********    NAO IGNORE    **********"+CHR(13)+;
			        " ALERTE O SUPORTE !!!!!!!!"+CHR(13)+;
		    	    " ALERTE O SUPORTE !!!!!!!!"+CHR(13)+;
	        		" ALERTE O SUPORTE !!!!!!!!"

				wp_msg = 'Manutencao de Sistema...'
				BTMP   =  'usuario.master '
				LNusr_ret = 0
				DO WHILE LNusr_ret = 0
					DO obj_prmt.SPR WITH   wp_msg , Btmp
					IF LNusr_ret <>  0
						LSmsg  = "Ativar PASSO ? "
						IF fox_alert(LSmsg)
							SET STEP ON
						ENDIF
						EXIT
					ENDIF
				ENDDO
			ENDIF
			*-------------------------------------------------*

			m.deletado= .t.
	        =REGLOCK(.T.)			&& P/ CONFIRMAR O BLOQUEIO PREVIO
									&& ESTAVAM ACONTECENDO ATTEMP TO LOCK
			GATHER MEMVAR MEMO
			DELETE
		OTHERWISE
		   DO OBJ_ALER.SPR WITH ;
			   "Operacao nao identificada em EDITHAND. " + m.paction
	ENDCASE
	m.deletado= .f.
RETURN
*******************************



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3SF           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   19   
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      57                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3sf     &&  padrao VALID
#REGION 2
RETURN

PROCEDURE ESCOLHE_INDICE

IF NOT WEXIST("_r2k0x6sp0")
	DEFINE WINDOW _r2k0x6sp0 ;
		AT 0.000, 0.000 ;
		SIZE 17.615,69.200 ;
		TITLE "INDICES" ;
		FONT "MS Sans Serif", 8 ;
		FLOAT ;
		CLOSE ;
		MINIMIZE ;
		SYSTEM ;
		COLOR RGB(,,,0,128,128)
ENDIF

declare wv_indice(1)
w_indices = 0
wp_indices = ''
W_INDICES = 1
wp_indices = 1
do while tag(w_indices) <> ""
     DECLARE wv_indice(w_indices)
     wv_indice(w_indices) = tag(w_indices)
     w_indices = w_indices + 1
enddo


*       *********************************************************
*       *
*       *              PSQCDX/Windows Screen Layout
*       *
*       *********************************************************
*

#REGION 1
IF WVISIBLE("_r2k0x6sp0")
	ACTIVATE WINDOW _r2k0x6sp0 SAME
ELSE
	ACTIVATE WINDOW _r2k0x6sp0 NOSHOW
ENDIF
@ 6.462,12.800 GET wp_indices ;
	PICTURE "@^" ;
	FROM wv_indice ;
	SIZE 1.538,36.167 ;
	DEFAULT 1 ;
	FONT "MS Sans Serif", 8 ;
	STYLE "B"
@ 1.615,1.800 SAY "LISTAGEM EM ZOOM" + CHR(13) + ;
		"Escolha a ordem que deseja visualizar." ;
	SIZE 2.000,36.333, 0.000 ;
	PICTURE "@I" ;
	FONT "MS Sans Serif", 12 ;
	STYLE "BIT" ;
	COLOR RGB(,,,255,0,255)

IF NOT WVISIBLE("_r2k0x6sp0")
	ACTIVATE WINDOW _r2k0x6sp0
ENDIF

READ CYCLE MODAL
RELEASE WINDOW _r2k0x6sp0
SET ORDER TO TAG "&wv_indice(wp_indices)"

return



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3SM           padrao VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   20   
*        Variable:            padrao                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      58                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3sm     &&  padrao VALID
#REGION 2
return
FUNCTION UPtransacao
	parameter LSoperacao, LSarquivo

	IF	!wp_seguranca   && NAO EXIGE PROCESSO TRANSACAOPP
		RETURN (.T.)
	ENDIF
	IF  LSoperacao = "ATIVAR"   && ativa biblioteca transacional
		IF !FILE("Q:\FPD26\NETWARE.PLB")
			RETURN .F.
		ENDIF
		SET LIBRARY TO Q:\FPD26\NETWARE.PLB
		RETURN .T.			
	ENDIF
	IF  TTSAVAIL() <> 1
		RETURN (.F.)
	ENDIF
******
	IF !(TYPE("LSarquivo") $ "UL")
		LSarquivo = wp_dirdat+LSarquivo
	ENDIF
	DO CASE
		CASE LSoperacao = "DESATIVAR"   && desativa biblioteca transacional
			RELEASE  LIBRARY  Q:\FPD26\NETWARE.PLB
			RETURN .T.			
		CASE LSoperacao = "ARMAR"   && prepara arquivos p/ proc. transacao
			IF !FILE('&LSarquivo')
				RETURN .T.
			ENDIF
			RETURN (IIF(TTSATTRIB('&LSarquivo') OR ;
						TTSATTRIB('&LSarquivo',.T.)=0,.T.,.F.))
		CASE LSoperacao = "INICIAR" && inicia transacao
			RETURN (IIF(BEGINTRAN()=0,.T.,.F.))
		CASE LSoperacao = "TERMINAR" && fecha transacao
			RETURN (IIF(COMMIT()=0,.T.,.F.))
		CASE LSoperacao = "ABORTAR" && cancela transacao
			RETURN (IIF(RLLBACK()=0,.T.,.F.))
		CASE LSoperacao = "DESARMAR" && retira arquivos do proc. transacao
			IF !FILE('&LSarquivo')
				RETURN .T.
			ENDIF
			RETURN (IIF(TTSATTRIB('&LSarquivo',.f.)=0,.T.,.F.))
	ENDCASE
RETURN(.F.)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3SS           GRLogClienc VALID                  
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   21   
*        Variable:            GRLogClienc                        
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      59                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3ss     &&  GRLogClienc VALID
#REGION 2
RETURN

****** Registra alteracoes do cliente vinculado ao orcamento

FUNCTION GRLogClienc
	PRIVATE LSfuncao
	PRIVATE LSalias
    PRIVATE ARQ_LogOrca,ALS_LogOrca

	LSalias = ALIAS()
	STORE 0 TO ARQ_LogOrca
	*--------------------------------------------------------
	IF TYPE("GRLogOrcaALIAS") = "U" OR !USED(GRLogOrcaALIAS)
		PUBLIC GRLogOrcaALIAS
	    ARQ_LogOrca     = NetArqAgain("LOG_ORCA")
	    GRLogOrcaALIAS  = Alias()
	ENDIF
    ALS_LogOrca     = GRLogOrcaALIAS

	LSfuncao = CHRTRAN(STR(wp_acesso,2)," ","0")
	IF LSfuncao $ "33/34/35"
		if UPPER(m.nome) <> UPPER( &LSalias .nome )
			SELE &ALS_LogOrca
			m.ocorrencia = "Alt.Nome:"+ALLTRIM( &LSalias .nome )+" ==> ";
			                          +ALLTRIM(m.nome )
			=edithand('SAVE')
		ENDIF
	ENDIF

	IF !EMPTY(LSalias) AND USED(LSalias)
		SELECT &LSalias
	ENDIF

RETURN(.T.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UH           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   22   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      60                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3uh     &&  PADRAO VALID
#REGION 2
RETURN
**************************************************************************
*  UPtransfdb  : Rotina para atualizacao automatica de dados (DBF)    *
*				  colocados no diretorio (LSdiretorio\AUTOMATC\)         *
*				    Esta Rotina e chamada no MENU (SCGC.MPR)			 *
*																		 *
*				   E necessario que os arquivos da FILIAL e DATA passdas *
*				 estejam no diretorio.									 *											
*
*
*	LNfilial 	: Codigo da Filial em Operacao no Sistema
*	LDdata	 	: Data que se Solicita a Importacao
*	LSdiretorio : Diretorio Base (ex: \SCGC\LOJA\ ou \SCGC\CENTRAL)
*	LFsobrepor  : 1 Permanecer o mais recente
*				: 2 Sobrepor indepedente de data
**************************************************************************

PROCEDURE UPtrasnfdb
PARAMETERS  wp_empresa,wp_dtoper,wp_dirdat, LFsobrepor

							&& AVALIACAO DA DISPONIBILIDADE DO DIRETORIO E
							&& DOS DADOS

	PRIVATE LSdirant 		&& DIRETORIO CORRENTE = CURDIR()
	PRIVATE LSdrivetmp		&& DIRET. ONDE  SE ENCONTRAM OS ARQ. P/ IMPORTACAO
	PRIVATE LFerrodrive 	&& FLAG DE ERRO USADO NA REDEFINICAO DE ON ERROR
	PRIVATE LSfilial  		&& STRINGO C/ NRO DA FILIAL P/ COMPOR NOME DO ARQ
	PRIVATE LVTdbf			&& VETOR P/ OBTER OS ARQUIVOS *.DBF DO DIR LSdrivetmp

	PRIVATE LNfilial,LDdata,LSdiretorio
	
	LNfilial	= wp_empresa
	LDdata		= wp_dtoper
	LSdiretorio = wp_dirdat


	LSdrivetmp = ALLTRIM(LSdiretorio)
	IF RIGHT(LSdrivetmp,1) <> "\"
    	LSdrivetmp = ALLTRIM(LSdrivetmp)+"\"
	ENDIF

	LSdrivetmp	= LSdrivetmp +"AUTOMATC\"

	LSdirant = sys(5)+curdir()
	LFerrodrive = .f.
	ON ERROR LFerrodrive = .t.
	SET DEFA TO &LSdrivetmp
	IF LFerrodrive
		WAIT WINDOW "Solicite a Criacao de Diretorio:" +LSdrivetmp+"  <ENTER>"
	ENDIF	
	SET DEFA TO &LSdirant
	ON ERROR DO UPerrosys
	IF LFerrodrive
		return(.f.)
	ENDIF	
	*--------------------------------------------------------------------*
	*
	*		 O nome do Arquivo e composto por  MMDDFLID.DBF  onde :
	*
	*   MM=Mes       DD=Dia      FL=Filial      ID=Identificados do Arq
	*
	*--------------------------------------------------------------------*

	LSfilial = CHRTRAN(STR(LNfilial,2)," ","0")

	*--------------------------------------------------------------------*
	*=ADIR(LVTdbf, LSdrivetmp + "????"+LSfilial+"??.dbf") && independe data
	*--------------------------------------------------------------------*
	
	LStmp = CHRTRAN(STR(MONTH(LDdata),2)," ","0") + ;
			CHRTRAN(STR(DAY(LDdata),2)," ","0")
	=ADIR(LVTdbf, LSdrivetmp + LStmp + LSfilial +"??.dbf")  && depende data


	IF TYPE("LVTdbf(1,1)") <> "U"

		DO obj_atlz.prg WITH ;
					LNfilial,;
					LSdrivetmp,;
					LVTdbf,;
					.F.,;
					LFsobrepor,;
					LDdata,"A"  && PROCESSAR IMPORTACAO
	ENDIF
	ON ERROR DO UPerrosys
RETURN(.f.)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UI           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   23   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      61                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3ui     &&  PADRAO VALID
#REGION 2
RETURN
PROCEDURE loc_dlog
   PARAMETERS wl_indice, wl_for1, wl_key, wl_frmato, LSrotaux,;
	    LFatvleitor, LS_aliasref
	*********************************************************************			
	* wl_indice   => .t. => Nao selecionar indice (assumir corrente)
	*				 .f. => Selecionar indice em PSQCDX.SPR
	* wl_for	  => Condicao de listagem no browse
	*
	* wl_frmato	  => Permite escolha do formato armazenado no arq FORMATO.DBF
	*
	* LFatvleitor => Indica se o programa de busca (LEITOR) deve ser ativado
	*				na abertura do browse
	*
	* LS_aliasref => Em casos de arquivos temporarios com estrutura igual
	*				a de um arquivo previsto na formatacao (FORMATO.DBF)
	*               este parametro informa de qual arquivo sera pego a
	* 				formatacao para o browse		
	*				Exemplo OBJ_FINA (tab no valide de cliente)
	*********************************************************************			

	IF TYPE("LS_aliasref") $ "UL" OR EMPTY(LS_aliasref)
		LNfim_path  =  RAT("\",DBF())+1
		LSarq_ref   = SUBS(DBF(),LNfim_path)
		LS_aliasref = STRTRAN(LSarq_ref,".DBF" ,"")
	ENDIF
	LSleitor = "L"+RTRIM(LEFT(LS_aliasref,7))+".SPR"
				
	*********************************************************************			
	PUSH KEY CLEAR
	ON KEY LABEL F1		DO HLP2000.SPR WITH  POPUP(),PROMPT(),PROGRAM(),;
							WONTOP(),VARREAD()


	SET SYSMENU ON
	PUSH MENU _MSYSMENU
	SET SYSMENU TO _MWINDOW, _MWI_ZOOM,_MWI_MOVE, _MEDIT, _MED_FIND, ;
						_MED_FINDA

	ON KEY LABEL F10    KEYBOARD "{CTRL-F10}"
	HIDE MENU _MSYSMENU


	DEFINE WINDOW wzlocate ;
		FROM 1, 1 ;
		TO 12,79 ;
		TITLE "REGISTROS" ;
		FLOAT ;
        GROW;
		CLOSE ;
		SHADOW ;
		MINIMIZE ;
        ZOOM;
		SYSTEM ;
		COLOR SCHEME 10




    wl_for = wl_for1
	PRIVATE gfields,i

    VLlocctag = tag()
    IF !wl_indice
    	DO psqcdx.spr
		IF LASTKEY()  =  27
		    ON KEY LABEL ENTER
    		SET FORMAT TO
    		set order to  tag &VLlocctag
			RELEASE WINDOW wzlocate
			POP KEY 			&& reabilita teclas de atalho def. anteriormente
			POP MENU _MSYSMENU
			SET SYSMENU OFF
			RETURN
		ENDIF
    ENDIF

    ON KEY LABEL ENTER KEYBOARD CHR(23)
    IF !EMPTY(wl_for)
       wl_for = " FOR "+wl_for
	   IF !EOF()
		   SKIP
	   ENDIF
	   SKIP -1	
    ELSE
       wl_for = " "
    ENDIF

    IF !EMPTY(wl_key)
	   wl_key1 = "'"+&wl_key+"','"+&wl_key+"'"
       wl_key2 = " KEY "+wl_key1
    ELSE
       wl_key2 = " "
    ENDIF

*********************************** SUB. ROTINAS *********
	ON KEY LABEL F12    DO OBJ_CALC.SPR

	IF "GRUPO.DBF"  $ DBF()
	    Lusrtmp	= nUsr
		ON KEY LABEL F DO OBJ_FLTA.SPR	with grupo.codigo , ;
						grupo.classifica,grupo.descricao,Lusrtmp
		ON KEY LABEL R DO OBJ_RESE.SPR	with grupo.codigo , grupo.classifica
		ON KEY LABEL S DO OBJ_SALD.SPR 	with grupo.classifica, wp_dtoper
		IF USED("PRECO")
			ON KEY LABEL I DO ULSCGC451
			ON KEY LABEL F12    DO ;
				 OBJ_CALC.SPR WITH ;
				 ALLTRIM(TRANSFORM(PRECO.PRECO,"999999999.99"))
		ENDIF
	ENDIF	

	IF FILE(LSleitor)
	    ON KEY LABEL L DO  &LSleitor
	    ON KEY LABEL CTRL-L DO  &LSleitor
		ON ERROR WAIT WINDOW "O AUXILIAR DE BUSCA NAO ESTA DISPONIVEL."
	ENDIF
********************  FORMATACAO *******************

	SET FIELDS TO
	LSaliasant = ALIAS()

	LSaliastmp = LEFT(LS_aliasref+SPACE(8),8)
	LStagtmp   = TAG()

	IF TYPE("wl_frmato") $ "UL" OR EMPTY(wl_frmato)
		SELE indice
		SET ORDER TO TAG dbf_tag
		SEEK LSaliastmp+LStagtmp
		IF FOUND()
			LSvaria = indice.variacao
		ELSE
			LSvaria = 'A'
		ENDIF	
	ELSE
		LSvaria = wl_frmato     && FORMATO SOLICITADO NA CHAMDA DA ROTINA
	ENDIF
**	
    SELE formato
    SET ORDER TO TAG formato
	SEEK LSaliastmp+LSvaria
	IF FOUND()
		LFforma = RTRIM(formato.mascara)  && POSSUI FORMATO DEFINIDO
	ELSE
		LFforma = ""                      && NAO POSSUI FORMATO DEFINIDO
    ENDIF		
	SELE &LSaliasant
****************************************************

	SAVE SCREEN TO VLocDlg

    SET FORMAT TO
	IF TYPE("btnname") <> "U" AND m.btnname = 'LOCATE'
		IF FILE(LSleitor) AND LFatvleitor
			KEYBOARD "L"
	    ENDIF

		DO WHILE .T.


			IF "NOTA" $ DBF()
			
		    	BROWSE &LFforma WINDOW wzlocate &wl_for REST &wl_key2 ;
   					NOAPPEND NODELETE NOEDIT  ;
					&wp_timeout WHEN UPvrsld() COLOR SCHEME 10

			ELSE
			
		    	BROWSE &LFforma WINDOW wzlocate &wl_for REST &wl_key2 ;
   					NOAPPEND NODELETE NOEDIT VALID :F btn_val('ATUALIZA') ;
					&wp_timeout WHEN UPvrsld() COLOR SCHEME 10

			ENDIF
			
			IF READKEY() <> 20
				EXIT
			ENDIF
			DO UPprotege				
		ENDDO
	ELSE
		IF FILE(LSleitor) AND LFatvleitor
			KEYBOARD "L"
	    ENDIF
		DO WHILE .T.
		    BROWSE &LFforma WINDOW wzlocate &wl_for REST &wl_key2 ;
    			NOAPPEND NODELETE NOEDIT &wp_timeout WHEN UPvrsld() ;
    			COLOR SCHEME 10
			IF READKEY() <> 20
				EXIT
			ENDIF
			DO UPprotege				
		ENDDO
 	ENDIF

	RESTORE SCREEN FROM VLocDlg


	SET COLOR OF SCHEME 10 TO ,,,,,,W+/B
	POP MENU _MSYSMENU
	SET SYSMENU OFF
	HIDE MENU _MSYSMENU

	ON ERROR DO UPerrosys

    ON KEY LABEL CTRL-L
    ON KEY LABEL L
    ON KEY LABEL ENTER
    SET FORMAT TO
	SET FIELDS TO
    set order to  tag &VLlocctag
	RELEASE WINDOW wzlocate
	POP KEY 			&& reabilita teclas de atalho def. anteriormente
RETURN


FUNCTION UPvrsld			&& AVISOS PARA BROWSE
	SET COLOR OF SCHEME 10 TO ,,,,,,W+/B
	IF "GRUPO.DBF" $ DBF() AND grupo.cdg_tipo = 4   && PRODUTO
		IF USED("SALDO")
			IF saldo.sld_atu - saldo.reserva <=0
				SET COLOR OF SCHEME 10 TO ,,,,,,GR+/R
			ENDIF
		ENDIF
	ENDIF
RETURN(.T.)

PROCEDURE  ULSCGC451
	*-------------------------------------------------------------*
	*   Rotina  serve de entreposto entre o BROWS e o PROG SCGC451
	* permitindo administrar a situacao de retorno da rotina como
	* exemplo o retorno ao TAG correto para nao afetar o BROW
	*-------------------------------------------------------------*

	PRIVATE LStgant
	LStgant = TAG()

	DO SCGC451.SPR	with grupo.codigo , .T.

	SET ORDER TO TAG &LStgant
RETURN

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UJ           UPLocDefWindow VALID               
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   24   
*        Variable:            UPLocDefWindow                     
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      62                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3uj     &&  UPLocDefWindow VALID
#REGION 2
RETURN
FUNCTION UPLocDefWindow
	*********************************************************************			
	PUSH KEY CLEAR

	SET SYSMENU ON
	PUSH MENU _MSYSMENU
	SET SYSMENU TO _MWINDOW, _MWI_ZOOM,_MWI_MOVE, _MEDIT, _MED_FIND, ;
						_MED_FINDA
	ON KEY LABEL F10    KEYBOARD "{CTRL-F10}"
	HIDE MENU _MSYSMENU


	DEFINE WINDOW wzlocate ;
		FROM 1, 1 ;
		TO 12,79 ;
		TITLE "REGISTROS" ;
		FLOAT ;
        GROW;
		CLOSE ;
		SHADOW ;
		MINIMIZE ;
        ZOOM;
		SYSTEM ;
		COLOR SCHEME 10




    ON KEY LABEL ENTER KEYBOARD CHR(23)
	ON KEY LABEL F12    DO OBJ_CALC.SPR

	IF "GRUPO.DBF"  $ DBF()
	    Lusrtmp	= nUsr
		ON KEY LABEL F DO OBJ_FLTA.SPR	with grupo.codigo , ;
						grupo.classifica,grupo.descricao,Lusrtmp
		ON KEY LABEL R DO OBJ_RESE.SPR	with grupo.codigo , grupo.classifica
		ON KEY LABEL S DO OBJ_SALD.SPR 	with grupo.classifica, wp_dtoper
		IF USED("PRECO")
			ON KEY LABEL I DO ULSCGC451
			ON KEY LABEL F12    DO ;
				 OBJ_CALC.SPR WITH ;
				 ALLTRIM(TRANSFORM(PRECO.PRECO,"999999999.99"))
		ENDIF
	ENDIF	

RETURN

FUNCTION LocDelWindow

	SET COLOR OF SCHEME 10 TO ,,,,,,W+/B
	POP MENU _MSYSMENU
	SET SYSMENU OFF
	HIDE MENU _MSYSMENU

	ON ERROR DO UPerrosys

    ON KEY LABEL CTRL-L
    ON KEY LABEL L
    ON KEY LABEL ENTER
    SET FORMAT TO
	SET FIELDS TO
	RELEASE WINDOW wzlocate
	POP KEY 			&& reabilita teclas de atalho def. anteriormente
RETURN




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UK           UPLocRelWindow VALID               
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   25   
*        Variable:            UPLocRelWindow                     
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      63                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3uk     &&  UPLocRelWindow VALID
#REGION 2
RETURN

FUNCTION UPLocRelWindow

	SET COLOR OF SCHEME 10 TO ,,,,,,W+/B
	POP MENU _MSYSMENU
	SET SYSMENU OFF
	HIDE MENU _MSYSMENU

	ON ERROR DO UPerrosys

    ON KEY LABEL CTRL-L
    ON KEY LABEL L
    ON KEY LABEL ENTER
    SET FORMAT TO
	SET FIELDS TO
	RELEASE WINDOW wzlocate
	POP KEY 			&& reabilita teclas de atalho def. anteriormente
RETURN




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UL           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   26   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      64                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3ul     &&  PADRAO VALID
#REGION 2
RETURN

FUNCTION  UPNovoTmpNome
PARAMETERS  PrmNusr,PrmdirTmp,PrmAlsTmp,PrmChar


	ULCriaDirTmp  = "L:\TMP\"+STRTRAN(STR(PrmNusr,5)," ","0")
	

	PrmdirTmp  = ULCriaDirTmp+"\"


	ULtmp_FILE = PrmdirTmp ;
				  +"\";
				  +STRTRAN(STR(PrmNusr,5)," ","0")+".TXT"


	IF !FILE(ULtmp_FILE)
		!MKDIR &ULCriaDirTmp
		!DIR &ULtmp_FILE > &ULtmp_FILE
	ENDIF

	PrmAlsTmp = chr(PrmChar)+SUBS(SYS(3),1,7)
	
	
	
RETURN(.T.)

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UM           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_A,     Record Number:   27   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      65                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3um     &&  PADRAO VALID
#REGION 2
RETURN

FUNCTION  UPDeltmp

	*------------------------------------------*
	* MANUTENCAO TEMPORARIOS
	********************************************

	PRIVATE LS_Nm_Del
    PRIVATE LStime


	PrmdirTmp  = "L:\TMP\"+STRTRAN(STR(nUsr,5)," ","0")
	ULtmp_FILE = PrmdirTmp ;
				  +"\*.*"


	LS_Nm_Del = ""
    LStime = time()

	IF SUBS(LStime,4,2) $ "/00/"

		LS_Nm_Del = "\TMP\_DEL"+strtran(SUBS(LStime,1,5),":","")+".DEL"

		IF !FILE(LS_Nm_Del)
			!DEL &ULtmp_FILE  /Q >  &LS_Nm_Del
		ENDIF
		
	ENDIF

return(.t.)

*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UN           UPambientaliza VALID               
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:    3   
*        Variable:            UPambientaliza                     
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      66                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3un     &&  UPambientaliza VALID
#REGION 3
RETURN

PROCEDURE UPambientaliza
	*-----------------------------------------------------------
	*   SE WP_DIRCENTRAL JA EXISTIR SIGNIFICA QUE O SISTEMA JA FOI
	* AMBIENTALIZADO
	*-----------------------------------------------------------

	IF TYPE("wp_dircentral") <> "U"
		RETURN
	ENDIF


	*-----------------------------------------------------------
	*
	*   Empresa : INFO-2001
	*   Data    : 27/06/1995
	*   Autor   : Sergio de rezende alves
	*   Modulo  :
	*   Funcao  : Inicializa Ambiente para Execucao do Sistema
	*	
	*-----------------------------------------------------------

	*#WNAME wz_win
	*#READCLAUSE NOLOCK
	*~ WIZARDSCREEN


	#DEFINE C_DBFEMPTY		'Database is empty, add a record?'
	#DEFINE C_READONLY 		'Table is read-only. No editing allowed.'
	#DEFINE C_NOTABLE 		'No table selected. Open table or run query.'





	ON KEY LABEL F1		DO HLP2000.SPR WITH  POPUP(),PROMPT(),PROGRAM(),;
							WONTOP(),VARREAD()





	=UPPublicVar()



	CONTA = 0
	ABARRA = ""



	=UPSetSistema()


	=UPSetFox()


    *---------------------------------------------------------*
	*    BLOCO PRINCIPAL
    *---------------------------------------------------------*
	=UPVTMeses()
	=UPVTEstados()

	=UPapaga()

	=UPArqComuns()


	if !UPLoginInicial()
		 close databases
	     return
	endif

    *---------------------------------------------------------*


	DO UPcapparam	&& MONTAR PARAM.DA EMP.NO DIRETO DE DADOS SELECIONADO
    =upapaga()


    *---------------------------------------------------------*
	if  !NetUse("cadmenu") OR;
		!NetUse("acessos") OR;
	    !NetUse("indice")  OR;
 		!NetUse("formato")  OR;
	 	!NetUse("parametr")
		close databases
	    quit
	endif


    *---------------------------------------------------------*
	*-------------->> ARQUIVO DE RECURSOS

	=UPRecursosFOX()
	

	KEYBOARD "{ENTER}"
	do obj_cone.spr
	IF EMPTY(wp_dtoper)
		DO ULfechamn
	    clear all
    	set sysmenu to default
	    =upapaga()
    	quit
	endif
	
	
	IF EMPTY(wp_empresa)
		do obj_atva.spr
		IF LASTKEY() <> 13
			DO ULfechamn
	    	clear all
	    	set sysmenu to default
			=upapaga()
		    quit
		ENDIF
	ENDIF

	*--------------------------------------------------------------------*
	*  DIRECIONA TABELA DE PRECOS CONFORME A DATA DE WP_DTOPER           *
	*--------------------------------------------------------------------*

	=W_DEFPROC("PRECO.SPR")
	=PRtabvigor(wp_dtoper,wp_tabela,wp_serie)


	=W_DEFPROC("ROTINAS.SPR")
	DO UPcapparam	&& MONTAR PARAM.DA EMP.NO DIRETO DE DADOS SELECIONADO



	*--------------------------------------------------------------------*
	*  VERIFICA SE EXITEM DADOS EM SCGC\AUTOMATC  PARA IMPORTACAO
	*--------------------------------------------------------------------*

	=W_DEFPROC("ROTINAS.SPR")
	DO UPtrasnfdb WITH wp_empresa,wp_dtoper,wp_dirdat, 2



	DO UPaltdir

    =upapaga()


RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3UO           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:    4   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      67                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3uo     &&  PADRAO VALID
#REGION 3
RETURN

PROCEDURE UPmudausr
		DEACTIVATE  MENU _MSYSMENU
		SET SYSMENU OFF
		DO OBJ_SENH.SPR

		=UPaltdir()  && FORCAR A RECARGA DE PARAMETROS E MONTAGEM DO MENU


RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3W3           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:    5   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      68                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3w3     &&  PADRAO VALID
#REGION 3
RETURN

*		   <<<<  ROTINA PARA REDEFINIR A PROCEDURE >>>>>>
*	
*		Todas as PROCEDURES TEM ESTA FUNCAO
*
*
****************************************************************

FUNCTION antW_DEFPROC
	PARAMETERS LSnmprocedure
	PRIVATE LprocAtl,LprocAtl2,Lpos,Lnewproc

	LprocAtl = UPPER(set("PROCEDURE"))
	LprocAtl2 = STRTRAN(LprocAtl,".SPR","")
	IF LprocAtl = LprocAtl2
		LprocAtl2 = STRTRAN(LprocAtl,".SPX","")
		IF LprocAtl = LprocAtl2
			LprocAtl2 = STRTRAN(LprocAtl,".PRG","")
		ENDIF
	ENDIF	
	Lpos = RAT("\",LprocAtl2,1)+1
    LprocAtl = SUBS(LprocAtl2,Lpos)

	LSnmprocedure = UPPER(LSnmprocedure)
	Lnewproc = STRTRAN(LSnmprocedure,".SPR","")
	IF Lnewproc = LSnmprocedure
		Lnewproc = STRTRAN(LSnmprocedure,".SPX","")
		IF Lnewproc = LSnmprocedure
			Lnewproc = STRTRAN(LSnmprocedure,".PRG","")
		ENDIF
	ENDIF	

	IF Lnewproc = "ROTINAS"
		REturn
	ENDIF
	*IF (Lnewproc $  "TRIBUTAR")
	*	SET STEP ON
	*ENDIF

	DO CASE
	   	CASE "ACESSO" = LprocAtl
			IF ;
					Lnewproc = "ACESSO"  ;
				OR  Lnewproc = "PRECO"   ;
				OR  Lnewproc = "USUARIO"
				Lnewproc = "ACESSO"
			ELSE
				SET PROCEDURE TO &LSnmprocedure
			ENDIF
	   	CASE "ORCAMENT" = LprocAtl

			IF ;
					Lnewproc = "ORCAMENT"  ;
				OR  Lnewproc = "PRECO"  ;
				OR  Lnewproc = "TRIBUTAR"  ;
				OR  Lnewproc = "ESTOQUE"  ;
				OR  Lnewproc = "MOVIMENT"  ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "NOTAENT"  ;
				OR  Lnewproc = "ESTOQUE"  ;
				OR  Lnewproc = "AUTOPROC"  ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "ORCAMENT"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "DOCFISCA" = LprocAtl

			IF ;
					Lnewproc = "NOTA"  ;
				OR  Lnewproc = "CUPOM"     ;
				OR  Lnewproc = "NOTAENT"     ;
				OR  Lnewproc = "TRIBUTAR"     ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "ITEMMOV"     ;
				OR  Lnewproc = "TIPOOPER"  ;
				OR  Lnewproc = "GRFISCAL"     ;
				OR  Lnewproc = "DOCFISIT"  ;
				OR  Lnewproc = "GRUPO"     ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "DOCFISCA"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "NOTA" = LprocAtl

			IF ;
					Lnewproc = "NOTA"  ;
				OR  Lnewproc = "MOVIMENT"  ;
				OR  Lnewproc = "PRECO"     ;
				OR  Lnewproc = "ESTOQUE"   ;
				OR  Lnewproc = "ORCAMENT"  ;
				OR  Lnewproc = "TRIBUTAR"  ;
				OR  Lnewproc = "DUPLICAT"  ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "GRUPO"     ;
				OR  Lnewproc = "GRFISCAL"  ;
				OR  Lnewproc = "ECF"       ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "NOTA"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF
	   	CASE "NOTAITE" = LprocAtl
			IF ;
					Lnewproc = "NOTAENT"  ;
				Lnewproc = "NOTAITE"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "NOTAENT" = LprocAtl
			IF ;
					Lnewproc = "NOTAENT"  ;
				OR  Lnewproc = "MOVIMENT"  ;
				OR  Lnewproc = "PRECO"  ;
				OR  Lnewproc = "ESTOQUE"  ;
				OR  Lnewproc = "NOTAITE"  ;
				OR  Lnewproc = "TRIBUTAR" ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "NOTAENT"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF
	   	CASE  LprocAtl  $ "ITEMMOV/SALDO"

			IF ;
				Lnewproc = "SALDO"  ;
				Lnewproc = "ITEMMOV"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "DOCFISCA" $ LprocAtl
			IF (Lnewproc = "DOCFISIT" OR  Lnewproc = "DOCFISTB")
				Lnewproc = "DOCFISCA"
			ELSE
				SET PROCEDURE TO &LSnmprocedure
			ENDIF


		OTHERWISE
			SET PROCEDURE TO &LSnmprocedure
	ENDCASE
*    IF !("ROTINAS" $ UPPER(LSnmprocedure))
*			SET PROCEDURE TO &LSnmprocedure
*	ELSE
*		WAIT WINDOW "NO  ROTINAS" NOWAIT
*	ENDIF
RETURN(0)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3W4           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:    6   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      69                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3w4     &&  PADRAO VALID
#REGION 3
RETURN

PROCEDURE UPcapparam  && NAS MUDANCAS DE DIRETORIO OS PAR. SAO AUALIZADOS


	=W_DEFPROC("PARAMETR.SPR")
	IF !PMcapparam(wp_empresa)
	    wp_msg  = "Nao foi Possivel Acessar Arquivo de Parametros."
   		DO OBJ_ALER.SPR WITH  wp_msg
		return
	ENDIF
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3W5           UPareaWork VALID                   
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:    7   
*        Variable:            UPareaWork                         
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      70                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3w5     &&  UPareaWork VALID
#REGION 3
RETURN

PROCEDURE UPareaWork



	=W_DEFPROC("rotinas.spr")
	PRIVATE LSalias
	PRIVATE LFAreaWork

	*-----------------------------------------------------------*
	LSalias	= ALIAS()

	*-----------------------------------------------------------*
	PUSH KEY CLEAR		&& desabilita teclas de atalho def. anteriormente



	*------------------------------------------------------------*

	LFAreaWork		= NetArq("areawork")
	*--------------------------------------------------------
    IF (LFareaWork) > 100000  && HOUVE FALHA ABERT
		=UP_fecha("areawork")
		IF !EMPTY(LSalias) AND USED(LSalias)
			SELECT &LSalias
		ENDIF
		RETURN(.f.)
	ENDIF





	SELE areawork
	SET ORDER TO TAG descricao
	GO TOP


 	DO loc_dlog WITH .T.
	
    IF LASTKEY() <> 27
      wp_dirdat = ALLTRIM(areawork.diretorio)
	  DO UPaltdir
	ENDIF


	CLEAR FIELDS
	SET FIELDS OFF
	*--------------------------------------------------------------*
	POP KEY 	&& reabilita teclas de atalho def. anteriormente
	*-----------------------------------------------------------*
	=UP_fecha("areawork")
	IF !EMPTY(LSalias) AND USED(LSalias)
		SELECT &LSalias
	ENDIF

	
RETURN(.T.)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3W6           UPloja VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:    8   
*        Variable:            UPloja                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      71                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3w6     &&  UPloja VALID
#REGION 3
RETURN
PROCEDURE UPloja
	IF wp_dirdat = wp_dirloja
		wp_dirdat = wp_dircentral
	ELSE
		wp_dirdat = wp_dirloja
	ENDIF
	DO UPaltdir
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3W7           UPareaWork VALID                   
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:    9   
*        Variable:            UPareaWork                         
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      72                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3w7     &&  UPareaWork VALID
#REGION 3
RETURN

PROCEDURE UPareaWork



	=W_DEFPROC("rotinas.spr")
	PRIVATE LSalias
	PRIVATE LFAreaWork

	*-----------------------------------------------------------*
	LSalias	= ALIAS()

	*-----------------------------------------------------------*
	PUSH KEY CLEAR		&& desabilita teclas de atalho def. anteriormente



	*------------------------------------------------------------*

	LFAreaWork		= NetArq("areawork")
	*--------------------------------------------------------
    IF (LFareaWork) > 100000  && HOUVE FALHA ABERT
		=UP_fecha("areawork")
		IF !EMPTY(LSalias) AND USED(LSalias)
			SELECT &LSalias
		ENDIF
		RETURN(.f.)
	ENDIF





	SELE areawork
	SET ORDER TO TAG descricao
	GO TOP


 	DO loc_dlog WITH .T.
	
    IF LASTKEY() <> 27
      wp_dirdat = ALLTRIM(areawork.diretorio)
	  DO UPaltdir
	ENDIF


	CLEAR FIELDS
	SET FIELDS OFF
	*--------------------------------------------------------------*
	POP KEY 	&& reabilita teclas de atalho def. anteriormente
	*-----------------------------------------------------------*
	=UP_fecha("areawork")
	IF !EMPTY(LSalias) AND USED(LSalias)
		SELECT &LSalias
	ENDIF

	
RETURN(.T.)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3W8           UPCentral VALID                    
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   10   
*        Variable:            UPCentral                          
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      73                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*

FUNCTION _4gg0nz3w8     &&  UPCentral VALID
#REGION 3
RETURN

PROCEDURE UPcentral
	wp_dirdat = wp_dircentral
	DO UPaltdir
RETURN



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3W9           UPOutras VALID                     
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   11   
*        Variable:            UPOutras                           
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      74                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3w9     &&  UPOutras VALID
#REGION 3
RETURN

PROCEDURE UPoutras
  DEACTIVATE  MENU _MSYSMENU
  wp_dirdat = ALLTRIM(GETDIR("\SCGC\","DIRETORIO DE TRABALHO"))
  DO UPaltdir
RETURN



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3WA           UPaltdir VALID                     
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   12   
*        Variable:            UPaltdir                           
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      75                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3wa     &&  UPaltdir VALID
#REGION 3
RETURN

PROCEDURE UPaltdir		&& altera o diretorio de trabalho
  DEACTIVATE  MENU _MSYSMENU
  close  databases

  =UPapaga()

 *** !NetUse("acessos") OR
 *** !NetUse("parametr")

  if !NetUse("usuario") OR;
 	 !NetUse("indice")  OR;
 	 !NetUse("formato")  OR;
 	 !NetUse("cadmenu")
	 close databases
     return
  endif

  *-------------------------------------------------------------------*
  *    REESTRUTURA PARAMETROS  CONFORME A AREA DE TRABALHO               *
  *-------------------------------------------------------------------*
	DO UPcapparam	&& MONTAR PARAM.DA EMP.NO DIRETO DE DADOS SELECIONADO


	=W_DEFPROC("ACESSO.SPR")
   =ACredmenu(wp_acesso)  && REDEFINE MENU

RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XL           UPVTMeses VALID                    
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   13   
*        Variable:            UPVTMeses                          
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      76                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xl     &&  UPVTMeses VALID
#REGION 3
RETURN

FUNCTION UPVTMeses

	wp_meses(1)     = "Janeiro"
	wp_meses(2)     = "Fevereiro"
	wp_meses(3)     = "Marco"
	wp_meses(4)     = "Abril"
	wp_meses(5)     = "Maio"
	wp_meses(6)     = "Junho"
	wp_meses(7)     = "Julho"
	wp_meses(8)     = "Agosto"
	wp_meses(9)     = "Setembro"
	wp_meses(10)    = "Outubro"
	wp_meses(11)    = "Novembro"
	wp_meses(12)    = "Dezembro"
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XM           UPVTEstados VALID                  
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   14   
*        Variable:            UPVTEstados                        
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      77                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xm     &&  UPVTEstados VALID
#REGION 3
RETURN

FUNCTION UPVTEstados


	wp_estado     	= "AC/AL/AP/AM/BA/CE/DF/ES/GO/MA/MT/MS/"+;
				  "MG/PE/PI/PA/PB/PR/RJ/RN/RS/RO/RR/SC/SP/SE/TO/EX/"
	wp_ufs(1,1)   ="AC"
	wp_ufs(2,1)   ="AL"
	wp_ufs(3,1)   ="AP"
	wp_ufs(4,1)   ="AM"
	wp_ufs(5,1)   ="BA"
	wp_ufs(6,1)   ="CE"
	wp_ufs(7,1)   ="DF"
	wp_ufs(8,1)   ="ES"
	wp_ufs(9,1)   ="GO"
	wp_ufs(10,1)  ="MA"
	wp_ufs(11,1)  ="MT"
	wp_ufs(12,1)  ="MS"
	wp_ufs(13,1)  ="MG"
	wp_ufs(14,1)  ="PE"
	wp_ufs(15,1)  ="PI"
	wp_ufs(16,1)  ="PA"
	wp_ufs(17,1)  ="PB"
	wp_ufs(18,1)  ="PR"
	wp_ufs(19,1)  ="RJ"
	wp_ufs(20,1)  ="RN"
	wp_ufs(21,1)  ="RS"
	wp_ufs(22,1)  ="RO"
	wp_ufs(23,1)  ="RR"
	wp_ufs(24,1)  ="SC"
	wp_ufs(25,1)  ="SP"
	wp_ufs(26,1)  ="SE"
	wp_ufs(27,1)  ="TO"
	wp_ufs(28,1)  ="EX"

	wp_ufs(1,2)   ="ACRE"
	wp_ufs(2,2)   ="ALAGOAS"
	wp_ufs(3,2)   ="AMAPA"
	wp_ufs(4,2)   ="AMAZONAS"
	wp_ufs(5,2)   ="BAHIA"
	wp_ufs(6,2)   ="CEARA"
	wp_ufs(7,2)   ="DISTRITO FEDERAL"
	wp_ufs(8,2)   ="ESPIRITO SANTO"
	wp_ufs(9,2)   ="GOIAS"
	wp_ufs(10,2)  ="MARANHAO"
	wp_ufs(11,2)  ="MATO GROSSO"
	wp_ufs(12,2)  ="MATO GROSSO DO SUL"
	wp_ufs(13,2)  ="MINAS GERAIS"
	wp_ufs(14,2)  ="PERNAMBUCO"
	wp_ufs(15,2)  ="PIAUI"
	wp_ufs(16,2)  ="PARA"
	wp_ufs(17,2)  ="PARAIBA"
	wp_ufs(18,2)  ="PARANA"
	wp_ufs(19,2)  ="RIO DE JANEIRO"
	wp_ufs(20,2)  ="RIO GRANDE DO NORTE"
	wp_ufs(21,2)  ="RIO GRANDE DO SUL"
	wp_ufs(22,2)  ="RONDONIA"
	wp_ufs(23,2)  ="RORAIMA"
	wp_ufs(24,2)  ="SANTA CATARINA"
	wp_ufs(25,2)  ="SAO PAULO"
	wp_ufs(26,2)  ="SERGIPE"
	wp_ufs(27,2)  ="TOCANTINS"
	wp_ufs(28,2)  ="EXTERIOR"
RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XN           UPSetFox VALID                     
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   15   
*        Variable:            UPSetFox                           
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      78                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xn     &&  UPSetFox VALID
#REGION 3
RETURN

FUNCTION UPSetFox

	SET UDFPARMS REFERENCE
	SET HELP OFF
	SET REFRESH TO 0
	SET PDSETUP TO
	SET SYSMENU OFF
	SET CLOCK TO 24,69
	SET HOURS TO 24
	SET CENTUR ON

	CLEAR MACROS


	set decimals to 2
	set talk off
	set status off
	set confirm on
	set exact on
  	set deleted on
  	set exclusive off
  	set echo off
  	set escape off
  	set safety off
  	set date to dmy
  	set bell off
  	set message window inutil
  	set scoreboard off
  	set refresh to 0
  	SET COLOR TO

RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XO           UPSetSistema VALID                 
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   16   
*        Variable:            UPSetSistema                       
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      79                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xo     &&  UPSetSistema VALID
#REGION 3
RETURN

FUNCTION UPSetSistema



	*---------------------
	WP_REDMENU  = .F. 	 	  && NAO REDEFINIR MENU
	WP_POPMENU  = .F.         && NAO RESGATAR MENU COM POP MENU
	*---------------------
	
	wp_estacao 		= 1
	wp_verlibera 	= .F. && DEFAUT E NAO PESQUISAR ARQ. LIBERACAO
	wp_numcontrole	=  0  && arquivo de controle de liberacao em baixo nivel
	wp_seguranca	= .t.
	wp_filaimp		= " "
	wp_rostoimp		= " "
	wp_folhaimp		= " "
	wp_arqname 		= " "

	wp_ECF			= "S"  		 && ASSUME Q. ECF esta conectada ao sistema
	wp_TIPOECF		= "SWEDAV1"  && ASSUME ECF SWEDA esta conectada ao
								&& sistema

	wp_impressora   = 0
	wp_drivstup     = 0		 && 1=DRIV. IMP ATIVO // 0=DRIV. IMP. INATIVO
	wp_destimp      = " "    && destino
	wp_descimp      = " "    && descricao da impressora da rede
	wp_nomeimp      = " "    && nome      da impressora da rede
	wp_servimp      = " "    && servidor  da impressora da rede
	wp_servnum      = "00"   && numero servidor  da impressao
	wp_servspool    = " "    && nome do servidor  spool
	wp_formimp      = "00"    && formulario do usuario
	wp_copimp       = "01 "   && numero de copias
	wp_libimp       = " "   && comando de liberacao da impressao na rede
	wp_pgini 		= 1
	wp_pgfim 		= 9999
	wp_rel          = ""

	wp_flag		 	= .f.
	wp_flgfecha		= .f.      && procedimento nao fecha
	wp_ref_local 	= .f.
	wp_tabela    	= 0
	wp_serie      	= " "
	wp_empresa    	= 0
	wp_nome_emp    	= ""
	wp_sigla_emp    = ""
	wp_tabcst     	= 1
	wp_dtsys      	= date()
	wp_ultlib		= TIME()
	m.wztblarr    	= ''
	m.wzalias     	= SELECT()
	m.isediting   	= .F.
	m.isadding    	= .F.
	m.isreading   	= .F.
	m.is2table    	= .F.


	m.wzolddelete 	= SET('DELETE')

	SET DELETED ON

	m.tempcurs    	= SYS(2015)  &&used if General field
	m.wzlastrec   	= 1

	ON ERROR DO UPerrosys
	m.wzolderror  	= ON('error')


	ON ERROR DO wizerrorhandler
	wzoldesc      	= ON('KEY','ESCAPE')

	ON KEY LABEL ESCAPE
	m.find_drop   	= IIF(_DOS,0,2)

	m.isreadonly  	= IIF(ISREAD(),.T.,.F.)




	VLleitura = ""
	VLlerfim  = ""
	VLcompara = ""
	VLchvlimi = ""

	*--------- DEFINE AMBIENTE DE TRABALHO
	close all database
	=W_DEFPROC("ROTINAS.SPR")

	ON ERROR DO UPerrosys






	*--------- DECLARACAO DE VARIAVEIS

	PUBLIC lMaster, cNivel, nUsr, lOpen, wp_acesso , wp_funcao, wp_nmusr
	PUBLIC lMenu
  	PUBLIC wp_tmpres    && tempo de reserva p/ produt do usuario ativo



	lOpen 	= .f.
  	nUsr 		= 0
  	cNivel 	= ""

  	wp_funcao = 0			&& ORIENTADO P/TRATAMENTO COMISSAO
  	wp_acesso = 0			&& ORIENTADO P/TRATAMENTO ACESSO

  	lMaster 	= .f.
  	lMenu 	    =  .f.
  	wp_nmusr 	= ""




	WP_timeout 		= " TIMEOUT 150 "  && 2:30 DE TEMPO em segundos
	WPprgativo  	= ""
	wp_popup        = ""
	wp_barra        = ""


    *---------------------------------------------------------*
	* ABILITA ARQUIVOS PARA TRANSACAO
    *---------------------------------------------------------*
	wp_seguranca	= .F.  && CONTINUA SEM CRITERIOS DE TRANSACAO

	wp_dirdat = "\scgc\loja\"


RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XP           UPArqComuns VALID                  
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   17   
*        Variable:            UPArqComuns                        
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      80                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xp     &&  UPArqComuns VALID
#REGION 3
RETURN

FUNCTION UPArqComuns

	*-------- prepara vetor com arq.e caminhos comuns as empresas -------*

	IF NetUse("\SCGC\COMUM\arqpad")
	   COUNT TO nTotal 		&& QUANTAS OCORRENCIAS DEVE TER O VETOR
   		IF EMPTY(nTotal)
	  		DIMENSION vArqpad[1,2]
   		ELSE
	  		DIMENSION vArqpad[nTotal,2]
      		COPY TO ARRAY vArqpad FIELDS arquivo, caminho
   		ENDIF
	ENDIF

RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XQ           UPLoginInicial VALID               
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   18   
*        Variable:            UPLoginInicial                     
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      81                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xq     &&  UPLoginInicial VALID
#REGION 3
RETURN

FUNCTION UPLoginInicial

  	if ! file("gencompy.mem")
     	wait "Decodificador NAO Dispon죞el - Chame Suporte <Enter>" window
        return(.f.)
  	endif
	
	if 	 !NetUse("usuario")
	     return(.f.)
	endif

	do obj_senh.spr

	if nUsr = 0 or LASTKEY() <> 13
		 DO ULfechamn   && ROTINA DE  S0000000.mpr  (PROJ: SSI)
	     quit
	endif

	IF !EMPTY(usuario.emp_ini)
		wp_empresa   = usuario.emp_ini
	ENDIF

	IF !EMPTY(usuario.area_ini)
		wp_dirdat   = ALLTRIM(usuario.AREA_ini)
	ELSE
		=W_DEFPROC("PARAMETR.SPR")
		wp_dirdat = PMGetDirDat(wp_empresa)
	ENDIF

RETURN(.t.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XR           UPRecursosFOX VALID                
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   19   
*        Variable:            UPRecursosFOX                      
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      82                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xr     &&  UPRecursosFOX VALID
#REGION 3
RETURN

FUNCTION UPRecursosFOX

	SET COLOR SET TO CATMAN
	=upapaga()

	do obj_esta.spr
	=upapaga()



RETURN(.t.)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3XS           UPPublicVar VALID                  
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   20   
*        Variable:            UPPublicVar                        
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      83                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3xs     &&  UPPublicVar VALID
#REGION 3
RETURN

FUNCTION UPPublicVar

	**** vetores carregam dados de arquivo ARQPAD P/ acelerar pesquisa

	PUBLIC DIMENSION vArqpad[1,2] &&p/arq.comuns as empresas(Ex.grupo -
								  && estq)
 						    && e diretorio dos arq. cumuns
	PUBLIC  wp_dircentral   && caminho p/ abert.arq. da central geral
	PUBLIC  wp_dirdat       && caminho p/ abert.arq. dados p/ trabalho
	PUBLIC  wp_dirloja  	&& Diret. de operacoes da loja	
							&& Exemplo de uso em OBJ_ROL1 e OBJ_SALD
	PUBLIC	wp_cod_loja     && Codigo. da loja que opera em dirloja
	PUBLIC  wp_dirtmp       && caminho p/ abert.arq. temporarios
	PUBLIC  wp_diracel      && caminho p/ abert.arq. acelerados
							&& sao arq. de baixo i/o que podem ficar
							&& arm em memoria (disco virtual)

	PUBLIC  wp_dirapptef       && diretorio comunitacao tef
	PUBLIC  wp_verlibera   	&& .T. pesquis de orcam p/ liberacao EM ROTINAS
	PUBLIC  wp_numcontrole 	&& numero do controle para  arquivo de liberacao

	PUBLIC  wp_string           && string retorno de valor de procedures
	PUBLIC  wp_msg              && string de menssagens
	PUBLIC  wp_flag             && flag de retorno de procedures
	PUBLIC  DIMENSION vAcessos[1,2]  && para controle de acesso
	PUBLIC  DIMENSION vclass[10] && permite a ident. dos niveis de
								&&  classificacao
	PUBLIC  wi_class            && indice para vetor classificacao
	PUBLIC  masc_clas           && mascara para classif. produto
	PUBLIC  masc_codi           && mascara para codigo do produto

	PUBLIC  wp_ECF		        && indica se ECF esta conectada ao sistema
	PUBLIC  wp_TIPOECF		    && indica qual ECF esta conectada ao sistema

	PUBLIC  wp_impressao   && Tipo de imp 1 = LOCAL; 2 = REDE
	PUBLIC  wp_impfat      && direcionamento impressora faturamento
	PUBLIC  wp_imposi      && direcionamento impressora osi
	PUBLIC  wp_imporc      && direcionamento impressora orcamento
	PUBLIC  wp_impestq     && direcionamento impressora estoque
	PUBLIC  wp_imprel      && direcionamento impressora relatorios

	PUBLIC  wp_prtfat      && porta          impressora faturamento
	PUBLIC  wp_prtosi      && porta          impressora osi
	PUBLIC  wp_prtorc      && porta          impressora orcamento
	PUBLIC  wp_prtestq     && porta          impressora estoque
	PUBLIC  wp_prtrel      && porta          impressora relatorios

	PUBLIC  wp_bco1        &&                banco p/ cobranca
	PUBLIC  wp_bco2        &&                banco p/ cobranca
	PUBLIC  wp_bco3        &&                banco p/ cobranca
	PUBLIC  wp_bco4        &&                banco p/ cobranca
	PUBLIC  wp_bco5        &&                banco p/ cobranca





	PUBLIC  wp_arqname     && nome de arquivo p/ impressao em disco
	PUBLIC  wp_impressora  && codigo da impressora da rede
	PUBLIC  wp_drivstup    && 1=DRIV. IMP ATIVO // 0=DRIV. IMP. INATIVO
	PUBLIC  wp_destimp     && nome da saida destino
	PUBLIC  wp_descimp     && descricao da impressora da rede
	PUBLIC  wp_nomeimp     && nome      da impressora da rede
	PUBLIC  wp_servimp     && servidor  da impressora da rede
	PUBLIC  wp_servnum     && numero servidor da impressao
	PUBLIC  wp_servspool   && numero servidor da impressao
	PUBLIC  wp_formimp     && formulario do usuario
	PUBLIC  wp_copimp      && numero de copias
	PUBLIC  wp_libimp      && comando de liberacao da impressao na rede
	PUBLIC  wp_pgini       && indica pagina inicial da impressao
	PUBLIC  wp_pgfim       && indica pagina inicial da impressao
	PUBLIC  wp_rel         && indica nome do relatorio na impressao padrao;
								btn_val PRINT







	PUBLIC	WP_timeout    && contem a expressao que fecha o read em timeout
	PUBLIC	WPprgativo 		   && identifica o programa ativado no menu
	PUBLIC  wp_popup           && identifica o popup ativado
	PUBLIC  wp_barra           && identifica a barra ativada
	PUBLIC  wp_cp1             && identifica a barra ativada
	PUBLIC  wp_cp2             && identifica a barra ativada
	wp_cp1 = 0
	wp_cp2 = 0

	PUBLIC DIMENSION wp_retorno[12] && vetor p/ retornar varios vlres em
									&& funcao

	PUBLIC  WP_REDMENU 	  && PERMITE ACESSO A ROTINA DE REDEFINICAO
	PUBLIC  WP_POPMENU 	  && AUTORIZA RESGATAR MENU NA PROXIMA REDEFINICAO






	*--------- variaveis parametrais

	********* NIVEL DE SEGURANCA DE PROCESSAMENTO *********

	PUBLIC  wp_seguranca    && <.T. EXIGE> ativacao do proc. de transacao ;
							&& nas operacoes que solicitem o processo ;
							&& <.F. PERMITE> que processos continuem mesmo;
							&&com o processo de transacao desativado


	*******************************************************
	PUBLIC  DIMENSION wp_meses[12]  && para nomes em portugues dos meses
	PUBLIC  DIMENSION wp_ufs[28,2]  && para nomes dos estados

	PUBLIC  wp_estacao      && ocorrencia no vetor da estacao atual
	PUBLIC  wp_tabela       && tabela ativa no sistema
	PUBLIC  wp_serie        && serie tabela ativa no sistema
	PUBLIC  wp_empresa      && empresa ativa no sistema
	PUBLIC  wp_nome_emp     && nome da empresa ativa no sistema
	PUBLIC  wp_sigla_emp    && sigla da empresa ativa no sistema
	PUBLIC  wp_tabcst       && qual tabela de sitiacao tributaria (TAB_CST)
	PUBLIC  wp_emptab       && buscar tabela de precos da empresa ..
	PUBLIC  wp_estado       && Siglas dos Estados
	PUBLIC  wp_ref_local    && INDICA CONTROLE DE BOTOES LOCAIS
	PUBLIC  wp_dtsys        && data real de operacao do sistema
	PUBLIC  wp_dtoper       && data operacional do sistema
	PUBLIC  wp_flgfecha     && indica .t. fechamento da rotina por indica;
								cao de procedimentos SETUP

	PUBLIC  wp_ultlib 			&& hora da ultima liberacao de resesrva
	PUBLIC  wp_EXT1
	PUBLIC  wp_EXT2


	PUBLIC  wp_impressora		&& nome do servidor de impressao
	PUBLIC  wp_servimp  		&& nome do servidor de impressao
	PUBLIC  wp_filaimp  		&& nome da fila de impressao
	PUBLIC  wp_copimp 	 		&& numero de copia
	PUBLIC  wp_rostoimp  		&& titulo da folha de rosto
	PUBLIC  wp_folhaimp  		&& indicativo p/ impressao folha rosto


	PUBLIC  VLleitura
	PUBLIC  VLlerfim
	PUBLIC  VLcompara
	PUBLIC  VLchvlimi



	PUBLIC m.isediting,m.isadding,m.isreading,m.is2table,m.isreadonly


RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Z4           UPEmpresa VALID                    
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   21   
*        Variable:            UPEmpresa                          
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      84                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3z4     &&  UPEmpresa VALID
#REGION 3
RETURN

PROCEDURE UPEmpresa
		DEACTIVATE  MENU _MSYSMENU
		SET SYSMENU OFF
		DO OBJ_ATVA.SPR
		=UPaltdir()  && FORCAR A RECARGA DE PARAMETROS E MONTAGEM DO MENU


RETURN


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Z5           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_B,     Record Number:   22   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      85                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3z5     &&  PADRAO VALID
#REGION 3
RETURN

*		   <<<<  ROTINA PARA REDEFINIR A PROCEDURE >>>>>>
*	
*		Todas as PROCEDURES TEM ESTA FUNCAO
*
*
****************************************************************

FUNCTION W_DEFPROC
	PARAMETERS LSnmprocedure
	PRIVATE LprocAtl,LprocAtl2,Lpos,Lnewproc

	LprocAtl = UPPER(set("PROCEDURE"))
	LprocAtl2 = STRTRAN(LprocAtl,".SPR","")
	IF LprocAtl = LprocAtl2
		LprocAtl2 = STRTRAN(LprocAtl,".SPX","")
		IF LprocAtl = LprocAtl2
			LprocAtl2 = STRTRAN(LprocAtl,".PRG","")
		ENDIF
	ENDIF	
	Lpos = RAT("\",LprocAtl2,1)+1
    LprocAtl = SUBS(LprocAtl2,Lpos)

	LSnmprocedure = UPPER(LSnmprocedure)
	Lnewproc = STRTRAN(LSnmprocedure,".SPR","")
	IF Lnewproc = LSnmprocedure
		Lnewproc = STRTRAN(LSnmprocedure,".SPX","")
		IF Lnewproc = LSnmprocedure
			Lnewproc = STRTRAN(LSnmprocedure,".PRG","")
		ENDIF
	ENDIF	

	IF Lnewproc = "ROTINAS"
		REturn
	ENDIF
	*IF (Lnewproc $  "TRIBUTAR")
	*	SET STEP ON
	*ENDIF

	DO CASE
	   	CASE "ACESSO" = LprocAtl
			IF ;
					Lnewproc = "ACESSO"  ;
				OR  Lnewproc = "PRECO"   ;
				OR  Lnewproc = "USUARIO"
				Lnewproc = "ACESSO"
			ELSE
				SET PROCEDURE TO &LSnmprocedure
			ENDIF
	   	CASE "ORCAMENT" = LprocAtl

			IF ;
					Lnewproc = "ORCAMENT"  ;
				OR  Lnewproc = "PRECO"  ;
				OR  Lnewproc = "TRIBUTAR"  ;
				OR  Lnewproc = "ESTOQUE"  ;
				OR  Lnewproc = "MOVIMENT"  ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "NOTAENT"  ;
				OR  Lnewproc = "ESTOQUE"  ;
				OR  Lnewproc = "AUTOPROC"  ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "ORCAMENT"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "DOCFISCA" = LprocAtl

			IF ;
					Lnewproc = "NOTA"  ;
				OR  Lnewproc = "CUPOM"     ;
				OR  Lnewproc = "NOTAENT"     ;
				OR  Lnewproc = "TRIBUTAR"     ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "ITEMMOV"     ;
				OR  Lnewproc = "TIPOOPER"  ;
				OR  Lnewproc = "GRFISCAL"     ;
				OR  Lnewproc = "DOCFISIT"  ;
				OR  Lnewproc = "GRUPO"     ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "DOCFISCA"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "NOTA" = LprocAtl

			IF ;
					Lnewproc = "NOTA"  ;
				OR  Lnewproc = "MOVIMENT"  ;
				OR  Lnewproc = "PRECO"     ;
				OR  Lnewproc = "ESTOQUE"   ;
				OR  Lnewproc = "ORCAMENT"  ;
				OR  Lnewproc = "TRIBUTAR"  ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "FORNECED"  ;
				OR  Lnewproc = "GRFISCAL"  ;
				OR  Lnewproc = "DUPLICAT"  ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "NOTA"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF
	   	CASE "NOTAITE" = LprocAtl
			IF ;
					Lnewproc = "NOTAENT"  ;
				Lnewproc = "NOTAITE"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "NOTAENT" = LprocAtl
			IF ;
					Lnewproc = "NOTAENT"  ;
				OR  Lnewproc = "MOVIMENT"  ;
				OR  Lnewproc = "PRECO"  ;
				OR  Lnewproc = "ESTOQUE"  ;
				OR  Lnewproc = "NOTAITE"  ;
				OR  Lnewproc = "TRIBUTAR" ;
				OR  Lnewproc = "EMPRESA"
				Lnewproc = "NOTAENT"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF
	   	CASE  LprocAtl  $ "ITEMMOV/SALDO"

			IF ;
				Lnewproc = "SALDO"  ;
				Lnewproc = "ITEMMOV"
			ELSE			
				SET PROCEDURE TO &LSnmprocedure
			ENDIF

	   	CASE "DOCFISCA" $ LprocAtl
			IF (Lnewproc = "DOCFISIT" OR  Lnewproc = "DOCFISTB")
				Lnewproc = "DOCFISCA"
			ELSE
				SET PROCEDURE TO &LSnmprocedure
			ENDIF


		OTHERWISE
			SET PROCEDURE TO &LSnmprocedure
	ENDCASE
*    IF !("ROTINAS" $ UPPER(LSnmprocedure))
*			SET PROCEDURE TO &LSnmprocedure
*	ELSE
*		WAIT WINDOW "NO  ROTINAS" NOWAIT
*	ENDIF
RETURN(0)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Z6           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:    3   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      86                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3z6     &&  PADRAO VALID
#REGION 4
RETURN

FUNCTION UPdefbanco
	PARAMETERS LScidade, LSestado

	LNbcpref 	 = 1			&& banco de preferencia da cobranca
	LNbcdisp 	 = 1			&& banco disponivel na cidade
	LNbc_retorno = 0            && codigo do banco indicado
	LSUPdefareant = ALLTRIM(ALIAS()) && PERMITE RETORNAR A AREA ANTER. A CHAMADA
	LFcid_UPdef	= .f.
	IF !USED("cidbanc")
		LFcid_UPdef	= .T.
		IF !NetUse("cidbanc")
			SELE &LSUPdefareant
			RETURN(0)
		ENDIF
	ENDIF
	SELE cidbanc
	SET ORDER TO TAG cidade
	SEEK LSestado+LScidade
	IF !FOUND()
		LNbc_retorno = 0  && carteira
	ELSE
		IF cidbanc.regiao <> 0
			m.regiao = cidbanc.regiao  && sera utilizada na rot chamadora
		ENDIF
		LNbcpref = 1			&& banco de preferencia da cobranca
		LNbcdisp = 1			&& banco disponivel na cidade
		LNbc_retorno = 0  		&& carteira
		DO WHILE LNbcpref < 6
			LSbcpref = "wp_bco"+STR(LNbcpref,1)
			IF &LSbcpref = 0
				EXIT
			ENDIF
			LNbcdisp = 1			&& banco disponivel na cidade
			DO WHILE LNbcdisp < 6
				LSbcdisp = "cidbanc.banco"+STR(LNbcdisp,1)
				IF &LSbcdisp = 0
					EXIT
				ENDIF
				IF &LSbcdisp  = &LSbcpref
					LNbc_retorno = &LSbcdisp		&& banco indicado
					LNbcpref = 6    && forcar a saida do 2o laco
					EXIT
				ENDIF
				LNbcdisp = LNbcdisp + 1
			ENDDO	
			LNbcpref = LNbcpref + 1
		ENDDO	
	ENDIF
	IF LFcid_UPdef		&& .t. =>  DEVE SER FECHADA NA SAIDA
		=UP_fecha("cidbanc")
	ENDIF
	SELE &LSUPdefareant

RETURN(LNbc_retorno)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Z7           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:    4   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      87                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3z7     &&  PADRAO VALID
#REGION 4
RETURN

PROCEDURE UPdadosemp
	*------------------------------------------------------------*
	* CLASSIFICACAO:  [****]   MODULO INDEPENDENTE				 *
	*------------------------------------------------------------*
	* OBJETIVO....: Devolve dados da EMPRESA conforme parametros
	*------------------------------------------------------------*
	* COMENTARIO..: Utiliza o codigo da EMPRESA passado em parame-
	*		e retorna o DADO solicitado
	*	    EX: OBJ_NETR.SPR [BROWSE]  Retorna a SIGLA           *
	*------------------------------------------------------------*
	* OBS........ : O registro da empresa pode retornar  a
	*       posicao que se encontrava no momento da chamada da
	*		rotina para evitar interferencia em controles externos
	*		esse reposicionamento pode ser controlado por parametro
	*
	*------------------------------------------------------------*
	*  TABELAS....: EMPRESA
	*------------------------------------------------------------*
	*  PARAMETROS..:
	*		LNemp..........: Empresa
	*		LSdado.........: Nome do dado solicitado que deve
	*				constar na tabela
	*		LLreposiciona..: .T. = > Reposicionar registro
	*		LSTagLer.......: Indica Qual a Chave para Leitura
	*						 ex: EMPRESA ou CGC (Algumas Rotinas
	*							Nao Passam esse Parametro
	*							entao assume Defaut EMPRESA
	*
	*------------------------------------------------------------*
	*  RETORNO.....:                                             *
	*			(LSretorno)   = CONTEUDO DO COMPO                *
	*------------------------------------------------------------*
	PARAMETERS LNemp,LSdado,LLreposiciona,LSTagLer
	
	PRIVATE LNreposiciona	&& POSICAO DO REGISTRO INICIAL
	PRIVATE LSretorno		&& CONTEUDO DO CAMPO SOLICITADO
	PRIVATE LSarea			&& MACADOR DO ALIAS ANTERIOR P/ RETORNAR
	PRIVATE LStag			&& MACADOR DO TAG ANTERIOR DO ARQ EMPRESA
	PRIVATE LFempresa
	LSarea 		= 	ALIAS()
	LFempresa	= NetArq("empresa")
	IF (LFempresa) > 100000 && HOUVE FALHA DE ABERTURA
		SELE &LSarea	
		RETURN("0")
	ENDIF	

	SELECT  empresa
	DO CASE					&& TESTE P/ RETORNAR VALORES NULOS P/ !FOUND()
		CASE TYPE("LSdado") = "C"
			LSretorno = ""
		CASE TYPE("LSdado") = "N"
			LSretorno = 0
		CASE TYPE("LSdado") = "D"
			LSretorno = {}
		CASE TYPE("LSdado") = "L"
			LSretorno = .F.
	ENDCASE
	LStag  			=	TAG()
	LNreposiciona 	=	RECNO()

	IF TYPE("LSTagLer") = "C"
		SET ORDER TO TAG &LSTagLer
	ELSE
		SET ORDER TO TAG empresa
	ENDIF
	SEEK LNemp
	IF FOUND()
		LSretorno = &LSdado		&& CAPTURA CONTEUDO DO CAMPO SOLICITADO
	ENDIF
	IF LLreposiciona
		GO LNreposiciona
	ENDIF				
	SET ORDER TO TAG &LStag
	=UP_fecha("empresa" ,LFempresa)
	SELE &LSarea	
RETURN(LSretorno)



*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Z8           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:    5   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      88                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3z8     &&  PADRAO VALID
#REGION 4
RETURN

**********************************************************************
*	Rotina para calculo do preco de custo e venda
*	chamado por SCGC807 SCGC800A E SCGC240A
**********************************************************************
* PARAMETROS
*
*	LNqtde		: Quantidade solicitada
*	LNtab		: Preco de tabela
*	LNdesc		: Desconto total (Normal ou Com Vendor ja aplicado)
*	LNalqipi	: Aliquota de IPI
*   LNalqfrt	: Taxa de Frete
*	LNicmralq	: Aliquota do retido
*	LNiva		: IVA ou MARCKUP
*	LNicmcalq	: Aliquota do ICM de Credito
*
* VARIAVEIS LOCAIS
*	LNliq		: Preco de Tabela Aplicado o Desconto
*	LNipi		: Valor do IPI sobre preco liquido
*	LNcti		: Custo inicial
*	LNfret		: Valor do frete
*	LNadic		: Adicional
*	LNicmc		: Valor ICM de Credito
*	LNicmr		: Valor ICM Retido
*	LNcto		: Custo Total
*	LNpis		: Aliquota do PIS
*	LNcofins	: Aliquota de Cofins
*	LNpcomra 	: Preco de Compra
*	LNpvd		: Preco de Venda
*
*******************************************************************

PROCEDURE UPcalcusto
	PARAMETERS LNqtde,LNtab,LNdesc,LNalqipi,LNalqfrt,LNicmralq,;
			   LNiva, LNicmcalq, LNvendor,LNliq,LNipi,;
			   LNcti,LNfret,LNadic,;
			   LNicmc, LNicmr, LNcto,;
			   LNpis,LNcofins,LNmargem;
			   LNpcompra,LNpvd

	PRIVATE ALL

	STORE 0 TO   LNliq,LNipi,LNcti,LNfret,LNadic,LNicmc,LNicmr,LNcto

	LNliq 		= ((LNtab * (1 - LNdesc/100)) * LNqtde ) * LNvendor
	LNipi 		= LNliq * (LNalqipi /100)
	LNcti 		= (LNliq + LNipi)
	LNfret		= LNcti * (LNalqfrt / 100)

	LNadic		= (LNicmralq /100) * ;
					LNcti * (1+(LNiva /100))

	LNicmc		= LNliq * (LNicmcalq / 100)

	LNicmr		= LNadic - LNicmc
	LNcto 		= (LNcti + LNadic + LNfret) - LNicmc
	LNpcompra 	= LNliq
	LNpvd	 	= LNcto / (1- (LNpis/100 + LNcofins/100 + LNmargem/100 ))

RETURN




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3Z9           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:    6   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      89                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3z9     &&  PADRAO VALID
#REGION 4
RETURN

**********************************************************************
*	Rotina para calculo do preco de custo e venda
*	chamado por SCGC807 SCGC800A E SCGC240A
**********************************************************************
* PARAMETROS
*
*	LNqtde		: Quantidade solicitada
*	LNtab		: Preco de tabela
*	LNdesc		: Desconto total (Normal ou Com Vendor ja aplicado)
*	LNalqipi	: Aliquota de IPI
*   LNalqfrt	: Taxa de Frete
*	LNicmralq	: Aliquota do retido
*	LNiva		: IVA ou MARCKUP
*	LNicmcalq	: Aliquota do ICM de Credito
*
* VARIAVEIS LOCAIS
*	LNliq		: Preco de Tabela Aplicado o Desconto
*	LNipi		: Valor do IPI sobre preco liquido
*	LNcti		: Custo inicial
*	LNfret		: Valor do frete
*	LNadic		: Adicional
*	LNicmc		: Valor ICM de Credito
*	LNicmr		: Valor ICM Retido
*	LNcto		: Custo Total
*	LNpis		: Aliquota do PIS
*	LNcofins	: Aliquota de Cofins
*	LNpcomra 	: Preco de Compra
*	LNpvd		: Preco de Venda
*
*******************************************************************

FUNCTION  UPFcalcusto
	PARAMETERS LNqtde,LNtab,LNdesc,LNalqipi,LNalqfrt,LNicmralq,;
			   LNiva, LNicmcalq, LNvendor,LNliq,LNipi,;
			   LNcti,LNfret,LNadic,;
			   LNicmc, LNicmr, LNcto,;
			   LNpis,LNcofins,LNmargem;
			   LNpcompra,LNpvd

	PRIVATE ALL

	STORE 0 TO   LNliq,LNipi,LNcti,LNfret,LNadic,LNicmc,LNicmr,LNcto

	LNliq 		= ((LNtab * (1 - LNdesc/100)) * LNqtde ) * LNvendor
	LNipi 		= LNliq * (LNalqipi /100)
	LNcti 		= (LNliq + LNipi)
	LNfret		= LNcti * (LNalqfrt / 100)

	LNadic		= (LNicmralq /100) * ;
					LNcti * (1+(LNiva /100))

	LNicmc		= LNliq * (LNicmcalq / 100)

	LNicmr		= LNadic - LNicmc
	LNcto 		= (LNcti + LNadic + LNfret) - LNicmc
	LNpcompra 	= LNliq
	LNpvd	 	= LNcto / (1- (LNpis/100 + LNcofins/100 + LNmargem/100 ))

RETURN(LNpcompra)




*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ3ZA           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:    7   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      90                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz3za     &&  PADRAO VALID
#REGION 4
RETURN

FUNCTION ULatunf	&& RETORNA ATE QUE DIA AS NOTAS ESTAO ATUALIZADAS

PARAMETERS LNemp,LDdt
	PRIVATE LNdia

	SELE nota
	SET ORDER TO TAG NOTA
	SET NEAR ON
	SEEK STR(LNemp+1,3)
	SKIP -1
	DO WHILE !BOF() AND nota.status = 2 AND nota.empresa = LNemp ;
		AND	MONTH(nota.data) > MONTH(LDdt)
		SKIP -1
	ENDDO
	IF BOF() OR nota.empresa <> 1	
		LNdia = 99
	ELSE
		LNdia = DAY(nota.data)
	ENDIF
RETURN(LNdia)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ40I           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:    8   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      91                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz40i     &&  PADRAO VALID
#REGION 4
RETURN

FUNCTION UPlerdesti
PARAMETERS ch_desti
	SELECT tab001
	SEEK "DST"+m.ch_desti
    m.descdest = tab001.descricao
	SELE tipooper
RETURN(tab001.descricao)

FUNCTION UPlercontr
PARAMETERS ch_contr
	SELECT tab001
	SEEK "ACI"+m.ch_contr
    m.desccont = tab001.descricao
	SELE tipooper
RETURN(tab001.descricao)

FUNCTION UPlermotiv
PARAMETERS ch_motiv
	SELECT tab001
	SEEK "MTV"+m.ch_motiv
    m.descmoti = tab001.descricao
	SELE tipooper
RETURN(tab001.descricao)

FUNCTION UPlerprodu
PARAMETERS ch_produ
	SELECT tab001
	SEEK "PRO"+m.ch_produ
    m.descprod = tab001.descricao
	SELE tipooper
RETURN(tab001.descricao)

FUNCTION UPleropera
PARAMETERS ch_opera
	SELECT tab001
	SEEK "OPE"+m.ch_opera
    m.descoper = tab001.descricao
	SELE tipooper
RETURN(tab001.descricao)

FUNCTION UPlercondi
PARAMETERS ch_condi
	SELECT tab001
	SEEK "CND"+m.ch_condi
	   m.descond = tab001.descricao
	SELE tipooper
RETURN(tab001.descricao)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ40P           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:    9   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      92                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz40p     &&  PADRAO VALID
#REGION 4
RETURN

****** USADO EM RELATORIOS PARA IDENTIFICAR QUEBRAS
*******   EXEMPLO REL411,REL411A e REL608

FUNCTION UPlecodigo  && RETORNA O NOME DO CODIGO INFORMADO GRUPO//SUBGRUPO
PARAMETERS LScdg
	PRIVATE LSalias, LStagant, LSrgtmp
	PRIVATE LFerro

	LSalias = ALIAS()

	SELE GRUPO
	LStagant = TAG()
	LNrgtmp = RECNO()
	SET ORDER TO TAG classifica

	SEEK LScdg
	LSnome = grupo.descricao

	SET ORDER TO TAG &LStagant
	ON ERROR LFerro = .t.
	GO LNrgtmp
	ON ERROR DO UPerrosys
	
	SELE &LSalias
	
RETURN(LSnome)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ40Q           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:   10   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      93                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz40q     &&  PADRAO VALID
#REGION 4
RETURN

****** USADO NA IMPRESSAO DE NF PARA INCLUIR A CLASSIFICACAO NBM
****** PARA PRODUTOS IMPORTADOS
*******   EXEMPLO RELNFS

FUNCTION UPClasNbm && RETORNA Descricao com clas nbm
PARAMETERS LNemp,LScdg,LNorigem,LSdesc
	PRIVATE LSalias

	LSalias = ALIAS()

	IF NOT USED("TABNBM")
		=NetArq("TABNBM") && REABR
	ENDIF
	IF NOT USED("CLASNBM")
		=NetArq("CLASNBM") && REABR
	ENDIF

	SELE tabnbm
	SET ORDER TO TAG codigo
	SEEK LScdg
	IF !FOUND()
		IF !EMPTY(LSalias) AND USED(LSalias)
			SELECT &LSalias
		ENDIF
		RETURN(LSdesc)
	ENDIF


	SELE clasnbm
	SET ORDER TO TAG chave_id
	SEEK tabnbm.nbm
	IF !FOUND()
		IF !EMPTY(LSalias) AND USED(LSalias)
			SELECT &LSalias
		ENDIF
		RETURN(LSdesc)
	ENDIF

	*--------------------------------------------------------*
	* Foi solicitado que nao se imprimisse o codigo NBM por nao
	* haver espaco no campo da NF. Solicitacao em 22 de set de
	* 2006 (CELIO / ALMIR)
	*--------------------------------------------------------*
	IF 1=1
		LSdesc  =   LSdesc
	ELSE
		LSdesc	=	STRTRAN(LSdesc,"CAMARA ","Cmr")
		LSdesc	=	STRTRAN(LSdesc,"PNEU ","Pne")
		LSdesc  =   "CF"+clasnbm.nbm+LSdesc
	ENDIF

	
	IF !EMPTY(LSalias) AND USED(LSalias)
		SELECT &LSalias
	ENDIF
	
RETURN(LSdesc)


*       靈컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*                                                                
*        _4GG0NZ40R           PADRAO VALID                       
*                                                                
*        Function Origin:                                        
*                                                                
*        From Platform:       MS-DOS                             
*        From Screen:         GERAL_C,     Record Number:   11   
*        Variable:            PADRAO                             
*        Called By:           VALID Clause                       
*        Object Type:         Push Button                        
*        Snippet Number:      94                                 
*                                                                
*       聃컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
*
FUNCTION _4gg0nz40r     &&  PADRAO VALID
#REGION 4
RETURN

FUNCTION UPmsg_cr	&& MENSSAGENS CONFORME STATUS DE CREDITO CLIENTE
PARAMETERS LNtmp	
	DO CASE
		CASE LNtmp = 0
			wp_msg = "Sem restricoes pelo sistema.........."		
		CASE LNtmp = 1
			wp_msg = "Dados nao disponiveis p/ critica....."		
		CASE LNtmp = 2
			wp_msg = "Ultima compra a mais de 24 meses....."		
		CASE LNtmp = 3
			wp_msg = "Credito insuficiente........"		
		CASE LNtmp = 4
			wp_msg = "Duplicata em atrazo a mais de 10 dias.."		
		CASE LNtmp = 5
			wp_msg = "Media de atrazo superior a 15 dias nos ult. dez pgtos..."		
		CASE LNtmp = 6
			wp_msg = "Orcamentos aprovados + debitos superam limite de Credito.."		
		CASE LNtmp = 7
			wp_msg = "Renovar Cadastro...."		
	ENDCASE
	WAIT WINDOW wp_msg
RETURN

